"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"a696fd927c1c\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzPzJkNDEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJhNjk2ZmQ5MjdjMWNcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/websocket.ts":
/*!**************************!*\
  !*** ./lib/websocket.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GMCSWebSocket: function() { return /* binding */ GMCSWebSocket; }\n/* harmony export */ });\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fflate */ \"(app-pages-browser)/./node_modules/fflate/esm/browser.js\");\n/* harmony import */ var _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/stores/simulation */ \"(app-pages-browser)/./lib/stores/simulation.ts\");\n/* harmony import */ var _components_UI_Notification__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/UI/Notification */ \"(app-pages-browser)/./components/UI/Notification.tsx\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\nconst HEADER_UINT32_COUNT = 8;\nconst HEADER_FLOAT_COUNT = 1;\nconst HEADER_BYTES = (HEADER_UINT32_COUNT + HEADER_FLOAT_COUNT) * 4;\nconst FLAG_COMPRESSED = 1 << 0;\nconst parseMs = (value, fallback)=>{\n    const parsed = Number(value);\n    return Number.isFinite(parsed) && parsed > 0 ? parsed : fallback;\n};\nconst DEFAULT_HEARTBEAT_INTERVAL_MS = parseMs(process.env.NEXT_PUBLIC_WS_HEARTBEAT_MS, 10000);\nconst DEFAULT_HEARTBEAT_TIMEOUT_MS = parseMs(process.env.NEXT_PUBLIC_WS_HEARTBEAT_TIMEOUT_MS, 20000);\nconst DEFAULT_RECONNECT_BASE_MS = parseMs(process.env.NEXT_PUBLIC_WS_RECONNECT_BASE_MS, 2000);\nconst DEFAULT_RECONNECT_MAX_MS = parseMs(process.env.NEXT_PUBLIC_WS_RECONNECT_MAX_MS, 15000);\nclass GMCSWebSocket {\n    connect() {\n        if (this.ws) {\n            return;\n        }\n        const storeApi = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState();\n        this.lastConnectionState = storeApi.connected;\n        this.lastSimulationRunning = storeApi.simulationRunning;\n        this.lastStaleState = storeApi.isStale;\n        const phase = this.reconnectAttempts > 0 ? \"reconnecting\" : \"connecting\";\n        storeApi.setConnectionState(phase);\n        const socket = new WebSocket(this.url);\n        socket.binaryType = \"arraybuffer\";\n        socket.onopen = ()=>{\n            const store = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState();\n            store.setConnected(true);\n            store.setConnectionState(\"connected\");\n            store.updateLastUpdateTime(Date.now());\n            this.startStaleMonitor();\n            this.startHeartbeat();\n            this.reconnectAttempts = 0;\n            this.lastHeartbeatAck = Date.now();\n            this.evaluateStateChange();\n        };\n        socket.onclose = ()=>{\n            const store = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState();\n            store.setConnected(false);\n            store.markStale();\n            this.stopHeartbeat();\n            this.stopStaleMonitor();\n            this.scheduleReconnect();\n            this.evaluateStateChange();\n        };\n        socket.onerror = ()=>{\n            socket.close();\n        };\n        socket.onmessage = (event)=>{\n            const data = event.data;\n            if (data instanceof ArrayBuffer) {\n                this.handleBuffer(data);\n            } else if (data instanceof Blob) {\n                data.arrayBuffer().then((buffer)=>this.handleBuffer(buffer));\n            } else if (typeof data === \"string\") {\n                this.handleTextMessage(data);\n            }\n        };\n        this.ws = socket;\n    }\n    disconnect() {\n        if (this.reconnectTimer) {\n            clearTimeout(this.reconnectTimer);\n            this.reconnectTimer = null;\n        }\n        this.stopStaleMonitor();\n        this.stopHeartbeat();\n        if (this.ws) {\n            this.ws.close();\n            this.ws = null;\n        }\n        const store = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState();\n        store.setConnected(false);\n        store.setConnectionState(\"disconnected\");\n    }\n    scheduleReconnect() {\n        if (this.reconnectTimer) {\n            return;\n        }\n        this.reconnectAttempts += 1;\n        const attempt = this.reconnectAttempts;\n        const delay = Math.min(this.baseReconnectDelay * Math.pow(2, attempt - 1), this.maxReconnectDelay);\n        _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState().setConnectionState(\"reconnecting\");\n        this.reconnectTimer = setTimeout(()=>{\n            this.ws = null;\n            this.reconnectTimer = null;\n            this.connect();\n        }, delay);\n    }\n    handleBuffer(buffer) {\n        if (buffer.byteLength < HEADER_BYTES) {\n            return;\n        }\n        const header = new DataView(buffer, 0, HEADER_BYTES);\n        const downW = header.getUint32(0, true);\n        const downH = header.getUint32(1 * 4, true);\n        const activeCount = header.getUint32(2 * 4, true);\n        const capacity = header.getUint32(3 * 4, true);\n        const flags = header.getUint32(4 * 4, true);\n        const payloadSize = header.getUint32(5 * 4, true);\n        const storedSize = header.getUint32(6 * 4, true);\n        const runningFlag = header.getUint32(7 * 4, true);\n        const simTime = header.getFloat32(8 * 4, true);\n        const store = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState();\n        store.setSimulationRunning(Boolean(runningFlag));\n        this.lastHeartbeatAck = Date.now();\n        if (payloadSize === 0 || storedSize === 0) {\n            store.setTimestamp(simTime);\n            return;\n        }\n        let payload = new Uint8Array(buffer, HEADER_BYTES, storedSize);\n        if (flags & FLAG_COMPRESSED) {\n            payload = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.decompressSync)(payload);\n        } else if (payloadSize !== payload.length) {\n            payload = payload.slice(0, payloadSize);\n        }\n        let offset = 0;\n        const fieldCount = downW * downH;\n        const fieldArray = new Float32Array(payload.buffer, payload.byteOffset + offset, fieldCount);\n        const fieldCopy = new Float32Array(fieldArray);\n        offset += fieldCount * 4;\n        const oscArray = new Float32Array(payload.buffer, payload.byteOffset + offset, activeCount * 3);\n        const oscCopy = new Float32Array(oscArray);\n        offset += activeCount * 3 * 4;\n        const posArray = new Float32Array(payload.buffer, payload.byteOffset + offset, activeCount * 3);\n        const posCopy = new Float32Array(posArray);\n        offset += activeCount * 3 * 4;\n        const maskArray = new Float32Array(payload.buffer, payload.byteOffset + offset, activeCount);\n        const maskCopy = new Float32Array(maskArray);\n        const amplitudes = new Float32Array(activeCount);\n        for(let i = 0; i < activeCount; i += 1){\n            var _maskCopy_i;\n            amplitudes[i] = Math.abs(oscCopy[i * 3]) * ((_maskCopy_i = maskCopy[i]) !== null && _maskCopy_i !== void 0 ? _maskCopy_i : 1);\n        }\n        store.setField(fieldCopy, downW, downH);\n        store.setOscillators(posCopy, amplitudes, Math.min(activeCount, _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.MAX_SIMULATION_NODES));\n        store.setTimestamp(simTime);\n        this.evaluateStateChange();\n    }\n    startStaleMonitor() {\n        if (this.staleTimer) {\n            return;\n        }\n        this.staleTimer = setInterval(()=>{\n            const before = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState().isStale;\n            _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState().checkStaleStatus();\n            const after = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState().isStale;\n            if (before !== after) {\n                this.evaluateStateChange();\n            }\n        }, 1000);\n    }\n    stopStaleMonitor() {\n        if (this.staleTimer) {\n            clearInterval(this.staleTimer);\n            this.staleTimer = null;\n        }\n    }\n    startHeartbeat() {\n        if (this.heartbeatTimer || !this.ws) {\n            return;\n        }\n        this.lastHeartbeatAck = Date.now();\n        this.heartbeatTimer = setInterval(()=>{\n            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n                return;\n            }\n            try {\n                this.ws.send(JSON.stringify({\n                    type: \"HEARTBEAT\"\n                }));\n            } catch (error) {\n                console.warn(\"Failed to send heartbeat\", error);\n            }\n            if (this.lastHeartbeatAck !== null && Date.now() - this.lastHeartbeatAck > this.heartbeatTimeoutMs) {\n                this.ws.close();\n            }\n        }, this.heartbeatIntervalMs);\n    }\n    stopHeartbeat() {\n        if (this.heartbeatTimer) {\n            clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = null;\n        }\n        this.lastHeartbeatAck = null;\n    }\n    handleTextMessage(raw) {\n        try {\n            const message = JSON.parse(raw);\n            const store = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState();\n            switch(message.type){\n                case \"STATUS\":\n                    {\n                        if (typeof message.simulation_running === \"boolean\") {\n                            store.setSimulationRunning(message.simulation_running);\n                        }\n                        let touched = false;\n                        if (typeof message.sim_time === \"number\") {\n                            store.setTimestamp(message.sim_time);\n                            touched = true;\n                        }\n                        if (!touched) {\n                            store.updateLastUpdateTime(Date.now());\n                        }\n                        this.lastHeartbeatAck = Date.now();\n                        this.evaluateStateChange();\n                        break;\n                    }\n                case \"PONG\":\n                    if (typeof message.simulation_running === \"boolean\") {\n                        store.setSimulationRunning(message.simulation_running);\n                    }\n                    store.updateLastUpdateTime(Date.now());\n                    this.lastHeartbeatAck = Date.now();\n                    this.evaluateStateChange();\n                    break;\n                case \"HEARTBEAT_ACK\":\n                    this.lastHeartbeatAck = Date.now();\n                    store.updateLastUpdateTime(Date.now());\n                    break;\n                default:\n                    break;\n            }\n        } catch (error) {\n            console.warn(\"Failed to parse WebSocket message\", error);\n        }\n    }\n    evaluateStateChange() {\n        const { connected, simulationRunning, isStale, connectionState } = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState();\n        if (connectionState === \"connected\" && this.lastConnectionPhase && this.lastConnectionPhase !== \"connected\") {\n            this.maybeNotify(\"connection-restored\", ()=>_components_UI_Notification__WEBPACK_IMPORTED_MODULE_1__.notify.success(\"Connected to simulation stream.\"));\n        }\n        if (connectionState === \"reconnecting\") {\n            this.maybeNotify(\"connection-reconnecting\", ()=>_components_UI_Notification__WEBPACK_IMPORTED_MODULE_1__.notify.warning(\"Connection lost. Reconnecting...\"));\n        }\n        if (connectionState === \"stale\") {\n            this.maybeNotify(\"connection-stale\", ()=>_components_UI_Notification__WEBPACK_IMPORTED_MODULE_1__.notify.warning(\"Simulation data stream is stale.\"));\n        }\n        if (connectionState === \"disconnected\" && this.lastConnectionPhase && this.lastConnectionPhase !== \"disconnected\") {\n            this.maybeNotify(\"connection-disconnected\", ()=>_components_UI_Notification__WEBPACK_IMPORTED_MODULE_1__.notify.error(\"Disconnected from simulation stream.\"));\n        }\n        if (this.lastSimulationRunning !== null && simulationRunning !== this.lastSimulationRunning && connectionState === \"connected\") {\n            if (simulationRunning) {\n                this.maybeNotify(\"simulation-running\", ()=>_components_UI_Notification__WEBPACK_IMPORTED_MODULE_1__.notify.success(\"Simulation running.\"));\n            } else if (!isStale) {\n                this.maybeNotify(\"simulation-stopped\", ()=>_components_UI_Notification__WEBPACK_IMPORTED_MODULE_1__.notify.warning(\"Simulation stopped.\"));\n            }\n        }\n        this.lastConnectionPhase = connectionState;\n        this.lastConnectionState = connected;\n        this.lastSimulationRunning = simulationRunning;\n        this.lastStaleState = isStale;\n    }\n    maybeNotify(key, trigger) {\n        let cooldownMs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5000;\n        const now = Date.now();\n        var _this_lastNotificationAt_key;\n        const last = (_this_lastNotificationAt_key = this.lastNotificationAt[key]) !== null && _this_lastNotificationAt_key !== void 0 ? _this_lastNotificationAt_key : 0;\n        if (now - last >= cooldownMs) {\n            trigger();\n            this.lastNotificationAt[key] = now;\n        }\n    }\n    constructor(options = {}){\n        this.ws = null;\n        this.reconnectTimer = null;\n        this.staleTimer = null;\n        this.heartbeatTimer = null;\n        this.lastHeartbeatAck = null;\n        this.lastSimulationRunning = null;\n        this.lastConnectionState = false;\n        this.lastStaleState = false;\n        this.lastConnectionPhase = null;\n        this.lastNotificationAt = {};\n        this.reconnectAttempts = 0;\n        const { url = \"ws://localhost:8000/ws\", reconnectDelay = DEFAULT_RECONNECT_BASE_MS } = options;\n        this.url = url;\n        this.baseReconnectDelay = reconnectDelay;\n        this.maxReconnectDelay = DEFAULT_RECONNECT_MAX_MS;\n        this.heartbeatIntervalMs = DEFAULT_HEARTBEAT_INTERVAL_MS;\n        this.heartbeatTimeoutMs = DEFAULT_HEARTBEAT_TIMEOUT_MS;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU8sQ0FBQztZQUM5RDtRQUNGO1FBRUEsSUFBSSxDQUFDSCxtQkFBbUIsR0FBR0Q7UUFDM0IsSUFBSSxDQUFDakgsbUJBQW1CLEdBQUdDO1FBQzNCLElBQUksQ0FBQ0MscUJBQXFCLEdBQUdDO1FBQzdCLElBQUksQ0FBQ0MsY0FBYyxHQUFHQztJQUN4QjtJQUVROEcsWUFBWUcsR0FBVyxFQUFFQyxPQUFtQixFQUFxQjtZQUFuQkMsYUFBQUEsaUVBQWE7UUFDakUsTUFBTXRHLE1BQU1ELEtBQUtDLEdBQUc7WUFDUDtRQUFiLE1BQU11RyxPQUFPLG9DQUFJLENBQUNDLGtCQUFrQixDQUFDSixJQUFJLGNBQTVCLHlFQUFnQztRQUM3QyxJQUFJcEcsTUFBTXVHLFFBQVFELFlBQVk7WUFDNUJEO1lBQ0EsSUFBSSxDQUFDRyxrQkFBa0IsQ0FBQ0osSUFBSSxHQUFHcEc7UUFDakM7SUFDRjtJQS9TQXlHLFlBQVlDLFVBQWdDLENBQUMsQ0FBQyxDQUFFO2FBaEN4Qy9ILEtBQXVCO2FBRXZCNEMsaUJBQXVEO2FBRXZEZ0QsYUFBb0Q7YUFFcERNLGlCQUF3RDthQUV4RDFFLG1CQUFrQzthQUVsQ25CLHdCQUF3QzthQUV4Q0Ysc0JBQXNCO2FBRXRCSSxpQkFBaUI7YUFFakI4RyxzQkFBOEM7YUFFOUNRLHFCQUE2QyxDQUFDO2FBWTlDbkgsb0JBQW9CO1FBRzFCLE1BQU0sRUFBRUksTUFBTSx3QkFBd0IsRUFBRWtILGlCQUFpQnRJLHlCQUF5QixFQUFFLEdBQUdxSTtRQUN2RixJQUFJLENBQUNqSCxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDb0Msa0JBQWtCLEdBQUc4RTtRQUMxQixJQUFJLENBQUM1RSxpQkFBaUIsR0FBR3hEO1FBQ3pCLElBQUksQ0FBQ2lILG1CQUFtQixHQUFHekg7UUFDM0IsSUFBSSxDQUFDd0gsa0JBQWtCLEdBQUdwSDtJQUM1QjtBQXlTRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvd2Vic29ja2V0LnRzPzIyMWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVjb21wcmVzc1N5bmMgfSBmcm9tIFwiZmZsYXRlXCI7XHJcbmltcG9ydCB7IHVzZVNpbXVsYXRpb25TdG9yZSwgTUFYX1NJTVVMQVRJT05fTk9ERVMgfSBmcm9tIFwiQC9saWIvc3RvcmVzL3NpbXVsYXRpb25cIjtcclxuaW1wb3J0IHR5cGUgeyBDb25uZWN0aW9uU3RhdGUgfSBmcm9tIFwiQC9saWIvc3RvcmVzL3NpbXVsYXRpb25cIjtcclxuaW1wb3J0IHsgbm90aWZ5IH0gZnJvbSBcIkAvY29tcG9uZW50cy9VSS9Ob3RpZmljYXRpb25cIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgR01DU1dlYlNvY2tldE9wdGlvbnMge1xyXG4gIHVybD86IHN0cmluZztcclxuICByZWNvbm5lY3REZWxheT86IG51bWJlcjtcclxufVxyXG5cclxuY29uc3QgSEVBREVSX1VJTlQzMl9DT1VOVCA9IDg7XHJcbmNvbnN0IEhFQURFUl9GTE9BVF9DT1VOVCA9IDE7XHJcbmNvbnN0IEhFQURFUl9CWVRFUyA9IChIRUFERVJfVUlOVDMyX0NPVU5UICsgSEVBREVSX0ZMT0FUX0NPVU5UKSAqIDQ7XHJcbmNvbnN0IEZMQUdfQ09NUFJFU1NFRCA9IDEgPDwgMDtcclxuXHJcbmNvbnN0IHBhcnNlTXMgPSAodmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZmFsbGJhY2s6IG51bWJlcikgPT4ge1xyXG4gIGNvbnN0IHBhcnNlZCA9IE51bWJlcih2YWx1ZSk7XHJcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShwYXJzZWQpICYmIHBhcnNlZCA+IDAgPyBwYXJzZWQgOiBmYWxsYmFjaztcclxufTtcclxuXHJcbmNvbnN0IERFRkFVTFRfSEVBUlRCRUFUX0lOVEVSVkFMX01TID0gcGFyc2VNcyhwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19XU19IRUFSVEJFQVRfTVMsIDEwXzAwMCk7XHJcbmNvbnN0IERFRkFVTFRfSEVBUlRCRUFUX1RJTUVPVVRfTVMgPSBwYXJzZU1zKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1dTX0hFQVJUQkVBVF9USU1FT1VUX01TLCAyMF8wMDApO1xyXG5jb25zdCBERUZBVUxUX1JFQ09OTkVDVF9CQVNFX01TID0gcGFyc2VNcyhwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19XU19SRUNPTk5FQ1RfQkFTRV9NUywgMl8wMDApO1xyXG5jb25zdCBERUZBVUxUX1JFQ09OTkVDVF9NQVhfTVMgPSBwYXJzZU1zKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1dTX1JFQ09OTkVDVF9NQVhfTVMsIDE1XzAwMCk7XHJcblxyXG5leHBvcnQgY2xhc3MgR01DU1dlYlNvY2tldCB7XHJcbiAgcHJpdmF0ZSB3czogV2ViU29ja2V0IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIHByaXZhdGUgcmVjb25uZWN0VGltZXI6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIHByaXZhdGUgc3RhbGVUaW1lcjogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIHByaXZhdGUgaGVhcnRiZWF0VGltZXI6IFJldHVyblR5cGU8dHlwZW9mIHNldEludGVydmFsPiB8IG51bGwgPSBudWxsO1xyXG5cclxuICBwcml2YXRlIGxhc3RIZWFydGJlYXRBY2s6IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG5cclxuICBwcml2YXRlIGxhc3RTaW11bGF0aW9uUnVubmluZzogYm9vbGVhbiB8IG51bGwgPSBudWxsO1xyXG5cclxuICBwcml2YXRlIGxhc3RDb25uZWN0aW9uU3RhdGUgPSBmYWxzZTtcclxuXHJcbiAgcHJpdmF0ZSBsYXN0U3RhbGVTdGF0ZSA9IGZhbHNlO1xyXG5cclxuICBwcml2YXRlIGxhc3RDb25uZWN0aW9uUGhhc2U6IENvbm5lY3Rpb25TdGF0ZSB8IG51bGwgPSBudWxsO1xyXG5cclxuICBwcml2YXRlIGxhc3ROb3RpZmljYXRpb25BdDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IHVybDogc3RyaW5nO1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IGJhc2VSZWNvbm5lY3REZWxheTogbnVtYmVyO1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IG1heFJlY29ubmVjdERlbGF5OiBudW1iZXI7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgaGVhcnRiZWF0SW50ZXJ2YWxNczogbnVtYmVyO1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IGhlYXJ0YmVhdFRpbWVvdXRNczogbnVtYmVyO1xyXG5cclxuICBwcml2YXRlIHJlY29ubmVjdEF0dGVtcHRzID0gMDtcclxuXHJcbiAgY29uc3RydWN0b3Iob3B0aW9uczogR01DU1dlYlNvY2tldE9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgeyB1cmwgPSBcIndzOi8vbG9jYWxob3N0OjgwMDAvd3NcIiwgcmVjb25uZWN0RGVsYXkgPSBERUZBVUxUX1JFQ09OTkVDVF9CQVNFX01TIH0gPSBvcHRpb25zO1xyXG4gICAgdGhpcy51cmwgPSB1cmw7XHJcbiAgICB0aGlzLmJhc2VSZWNvbm5lY3REZWxheSA9IHJlY29ubmVjdERlbGF5O1xyXG4gICAgdGhpcy5tYXhSZWNvbm5lY3REZWxheSA9IERFRkFVTFRfUkVDT05ORUNUX01BWF9NUztcclxuICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9IERFRkFVTFRfSEVBUlRCRUFUX0lOVEVSVkFMX01TO1xyXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lb3V0TXMgPSBERUZBVUxUX0hFQVJUQkVBVF9USU1FT1VUX01TO1xyXG4gIH1cclxuXHJcbiAgY29ubmVjdCgpIHtcclxuICAgIGlmICh0aGlzLndzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdG9yZUFwaSA9IHVzZVNpbXVsYXRpb25TdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgdGhpcy5sYXN0Q29ubmVjdGlvblN0YXRlID0gc3RvcmVBcGkuY29ubmVjdGVkO1xyXG4gICAgdGhpcy5sYXN0U2ltdWxhdGlvblJ1bm5pbmcgPSBzdG9yZUFwaS5zaW11bGF0aW9uUnVubmluZztcclxuICAgIHRoaXMubGFzdFN0YWxlU3RhdGUgPSBzdG9yZUFwaS5pc1N0YWxlO1xyXG5cclxuICAgIGNvbnN0IHBoYXNlID0gdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA+IDAgPyAncmVjb25uZWN0aW5nJyA6ICdjb25uZWN0aW5nJztcclxuICAgIHN0b3JlQXBpLnNldENvbm5lY3Rpb25TdGF0ZShwaGFzZSk7XHJcblxyXG4gICAgY29uc3Qgc29ja2V0ID0gbmV3IFdlYlNvY2tldCh0aGlzLnVybCk7XHJcbiAgICBzb2NrZXQuYmluYXJ5VHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuXHJcbiAgICBzb2NrZXQub25vcGVuID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBzdG9yZSA9IHVzZVNpbXVsYXRpb25TdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICBzdG9yZS5zZXRDb25uZWN0ZWQodHJ1ZSk7XHJcbiAgICAgIHN0b3JlLnNldENvbm5lY3Rpb25TdGF0ZSgnY29ubmVjdGVkJyk7XHJcbiAgICAgIHN0b3JlLnVwZGF0ZUxhc3RVcGRhdGVUaW1lKERhdGUubm93KCkpO1xyXG4gICAgICB0aGlzLnN0YXJ0U3RhbGVNb25pdG9yKCk7XHJcbiAgICAgIHRoaXMuc3RhcnRIZWFydGJlYXQoKTtcclxuICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XHJcbiAgICAgIHRoaXMubGFzdEhlYXJ0YmVhdEFjayA9IERhdGUubm93KCk7XHJcbiAgICAgIHRoaXMuZXZhbHVhdGVTdGF0ZUNoYW5nZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzb2NrZXQub25jbG9zZSA9ICgpID0+IHtcclxuICAgICAgY29uc3Qgc3RvcmUgPSB1c2VTaW11bGF0aW9uU3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgc3RvcmUuc2V0Q29ubmVjdGVkKGZhbHNlKTtcclxuICAgICAgc3RvcmUubWFya1N0YWxlKCk7XHJcbiAgICAgIHRoaXMuc3RvcEhlYXJ0YmVhdCgpO1xyXG4gICAgICB0aGlzLnN0b3BTdGFsZU1vbml0b3IoKTtcclxuICAgICAgdGhpcy5zY2hlZHVsZVJlY29ubmVjdCgpO1xyXG4gICAgICB0aGlzLmV2YWx1YXRlU3RhdGVDaGFuZ2UoKTtcclxuICAgIH07XHJcblxyXG4gICAgc29ja2V0Lm9uZXJyb3IgPSAoKSA9PiB7XHJcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzb2NrZXQub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBldmVudC5kYXRhO1xyXG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVCdWZmZXIoZGF0YSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcclxuICAgICAgICBkYXRhLmFycmF5QnVmZmVyKCkudGhlbigoYnVmZmVyKSA9PiB0aGlzLmhhbmRsZUJ1ZmZlcihidWZmZXIpKTtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlVGV4dE1lc3NhZ2UoZGF0YSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy53cyA9IHNvY2tldDtcclxuICB9XHJcblxyXG4gIGRpc2Nvbm5lY3QoKSB7XHJcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lcikge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lcik7XHJcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3RvcFN0YWxlTW9uaXRvcigpO1xyXG4gICAgdGhpcy5zdG9wSGVhcnRiZWF0KCk7XHJcblxyXG4gICAgaWYgKHRoaXMud3MpIHtcclxuICAgICAgdGhpcy53cy5jbG9zZSgpO1xyXG4gICAgICB0aGlzLndzID0gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0b3JlID0gdXNlU2ltdWxhdGlvblN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICBzdG9yZS5zZXRDb25uZWN0ZWQoZmFsc2UpO1xyXG4gICAgc3RvcmUuc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc2NoZWR1bGVSZWNvbm5lY3QoKSB7XHJcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyArPSAxO1xyXG4gICAgY29uc3QgYXR0ZW1wdCA9IHRoaXMucmVjb25uZWN0QXR0ZW1wdHM7XHJcbiAgICBjb25zdCBkZWxheSA9IE1hdGgubWluKHRoaXMuYmFzZVJlY29ubmVjdERlbGF5ICogTWF0aC5wb3coMiwgYXR0ZW1wdCAtIDEpLCB0aGlzLm1heFJlY29ubmVjdERlbGF5KTtcclxuXHJcbiAgICB1c2VTaW11bGF0aW9uU3RvcmUuZ2V0U3RhdGUoKS5zZXRDb25uZWN0aW9uU3RhdGUoJ3JlY29ubmVjdGluZycpO1xyXG5cclxuICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGhpcy53cyA9IG51bGw7XHJcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBudWxsO1xyXG4gICAgICB0aGlzLmNvbm5lY3QoKTtcclxuICAgIH0sIGRlbGF5KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgaGFuZGxlQnVmZmVyKGJ1ZmZlcjogQXJyYXlCdWZmZXIpIHtcclxuICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA8IEhFQURFUl9CWVRFUykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGVhZGVyID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgMCwgSEVBREVSX0JZVEVTKTtcclxuICAgIGNvbnN0IGRvd25XID0gaGVhZGVyLmdldFVpbnQzMigwLCB0cnVlKTtcclxuICAgIGNvbnN0IGRvd25IID0gaGVhZGVyLmdldFVpbnQzMigxICogNCwgdHJ1ZSk7XHJcbiAgICBjb25zdCBhY3RpdmVDb3VudCA9IGhlYWRlci5nZXRVaW50MzIoMiAqIDQsIHRydWUpO1xyXG4gICAgY29uc3QgY2FwYWNpdHkgPSBoZWFkZXIuZ2V0VWludDMyKDMgKiA0LCB0cnVlKTtcclxuICAgIGNvbnN0IGZsYWdzID0gaGVhZGVyLmdldFVpbnQzMig0ICogNCwgdHJ1ZSk7XHJcbiAgICBjb25zdCBwYXlsb2FkU2l6ZSA9IGhlYWRlci5nZXRVaW50MzIoNSAqIDQsIHRydWUpO1xyXG4gICAgY29uc3Qgc3RvcmVkU2l6ZSA9IGhlYWRlci5nZXRVaW50MzIoNiAqIDQsIHRydWUpO1xyXG4gICAgY29uc3QgcnVubmluZ0ZsYWcgPSBoZWFkZXIuZ2V0VWludDMyKDcgKiA0LCB0cnVlKTtcclxuICAgIGNvbnN0IHNpbVRpbWUgPSBoZWFkZXIuZ2V0RmxvYXQzMig4ICogNCwgdHJ1ZSk7XHJcblxyXG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTaW11bGF0aW9uU3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgIHN0b3JlLnNldFNpbXVsYXRpb25SdW5uaW5nKEJvb2xlYW4ocnVubmluZ0ZsYWcpKTtcclxuICAgIHRoaXMubGFzdEhlYXJ0YmVhdEFjayA9IERhdGUubm93KCk7XHJcblxyXG4gICAgaWYgKHBheWxvYWRTaXplID09PSAwIHx8IHN0b3JlZFNpemUgPT09IDApIHtcclxuICAgICAgc3RvcmUuc2V0VGltZXN0YW1wKHNpbVRpbWUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHBheWxvYWQ6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIsIEhFQURFUl9CWVRFUywgc3RvcmVkU2l6ZSk7XHJcbiAgICBpZiAoZmxhZ3MgJiBGTEFHX0NPTVBSRVNTRUQpIHtcclxuICAgICAgcGF5bG9hZCA9IGRlY29tcHJlc3NTeW5jKHBheWxvYWQpO1xyXG4gICAgfSBlbHNlIGlmIChwYXlsb2FkU2l6ZSAhPT0gcGF5bG9hZC5sZW5ndGgpIHtcclxuICAgICAgcGF5bG9hZCA9IHBheWxvYWQuc2xpY2UoMCwgcGF5bG9hZFNpemUpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgY29uc3QgZmllbGRDb3VudCA9IGRvd25XICogZG93bkg7XHJcbiAgICBjb25zdCBmaWVsZEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShwYXlsb2FkLmJ1ZmZlciwgcGF5bG9hZC5ieXRlT2Zmc2V0ICsgb2Zmc2V0LCBmaWVsZENvdW50KTtcclxuICAgIGNvbnN0IGZpZWxkQ29weSA9IG5ldyBGbG9hdDMyQXJyYXkoZmllbGRBcnJheSk7XHJcbiAgICBvZmZzZXQgKz0gZmllbGRDb3VudCAqIDQ7XHJcblxyXG4gICAgY29uc3Qgb3NjQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHBheWxvYWQuYnVmZmVyLCBwYXlsb2FkLmJ5dGVPZmZzZXQgKyBvZmZzZXQsIGFjdGl2ZUNvdW50ICogMyk7XHJcbiAgICBjb25zdCBvc2NDb3B5ID0gbmV3IEZsb2F0MzJBcnJheShvc2NBcnJheSk7XHJcbiAgICBvZmZzZXQgKz0gYWN0aXZlQ291bnQgKiAzICogNDtcclxuXHJcbiAgICBjb25zdCBwb3NBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkocGF5bG9hZC5idWZmZXIsIHBheWxvYWQuYnl0ZU9mZnNldCArIG9mZnNldCwgYWN0aXZlQ291bnQgKiAzKTtcclxuICAgIGNvbnN0IHBvc0NvcHkgPSBuZXcgRmxvYXQzMkFycmF5KHBvc0FycmF5KTtcclxuICAgIG9mZnNldCArPSBhY3RpdmVDb3VudCAqIDMgKiA0O1xyXG5cclxuICAgIGNvbnN0IG1hc2tBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkocGF5bG9hZC5idWZmZXIsIHBheWxvYWQuYnl0ZU9mZnNldCArIG9mZnNldCwgYWN0aXZlQ291bnQpO1xyXG4gICAgY29uc3QgbWFza0NvcHkgPSBuZXcgRmxvYXQzMkFycmF5KG1hc2tBcnJheSk7XHJcblxyXG4gICAgY29uc3QgYW1wbGl0dWRlcyA9IG5ldyBGbG9hdDMyQXJyYXkoYWN0aXZlQ291bnQpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmVDb3VudDsgaSArPSAxKSB7XHJcbiAgICAgIGFtcGxpdHVkZXNbaV0gPSBNYXRoLmFicyhvc2NDb3B5W2kgKiAzXSkgKiAobWFza0NvcHlbaV0gPz8gMSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RvcmUuc2V0RmllbGQoZmllbGRDb3B5LCBkb3duVywgZG93bkgpO1xyXG4gICAgc3RvcmUuc2V0T3NjaWxsYXRvcnMocG9zQ29weSwgYW1wbGl0dWRlcywgTWF0aC5taW4oYWN0aXZlQ291bnQsIE1BWF9TSU1VTEFUSU9OX05PREVTKSk7XHJcbiAgICBzdG9yZS5zZXRUaW1lc3RhbXAoc2ltVGltZSk7XHJcbiAgICB0aGlzLmV2YWx1YXRlU3RhdGVDaGFuZ2UoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhcnRTdGFsZU1vbml0b3IoKSB7XHJcbiAgICBpZiAodGhpcy5zdGFsZVRpbWVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0YWxlVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGJlZm9yZSA9IHVzZVNpbXVsYXRpb25TdG9yZS5nZXRTdGF0ZSgpLmlzU3RhbGU7XHJcbiAgICAgIHVzZVNpbXVsYXRpb25TdG9yZS5nZXRTdGF0ZSgpLmNoZWNrU3RhbGVTdGF0dXMoKTtcclxuICAgICAgY29uc3QgYWZ0ZXIgPSB1c2VTaW11bGF0aW9uU3RvcmUuZ2V0U3RhdGUoKS5pc1N0YWxlO1xyXG4gICAgICBpZiAoYmVmb3JlICE9PSBhZnRlcikge1xyXG4gICAgICAgIHRoaXMuZXZhbHVhdGVTdGF0ZUNoYW5nZSgpO1xyXG4gICAgICB9XHJcbiAgICB9LCAxMDAwKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RvcFN0YWxlTW9uaXRvcigpIHtcclxuICAgIGlmICh0aGlzLnN0YWxlVGltZXIpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnN0YWxlVGltZXIpO1xyXG4gICAgICB0aGlzLnN0YWxlVGltZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGFydEhlYXJ0YmVhdCgpIHtcclxuICAgIGlmICh0aGlzLmhlYXJ0YmVhdFRpbWVyIHx8ICF0aGlzLndzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxhc3RIZWFydGJlYXRBY2sgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy53cyB8fCB0aGlzLndzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRoaXMud3Muc2VuZChKU09OLnN0cmluZ2lmeSh7IHR5cGU6IFwiSEVBUlRCRUFUXCIgfSkpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBzZW5kIGhlYXJ0YmVhdFwiLCBlcnJvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmxhc3RIZWFydGJlYXRBY2sgIT09IG51bGwgJiYgRGF0ZS5ub3coKSAtIHRoaXMubGFzdEhlYXJ0YmVhdEFjayA+IHRoaXMuaGVhcnRiZWF0VGltZW91dE1zKSB7XHJcbiAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xyXG4gICAgICB9XHJcbiAgICB9LCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdG9wSGVhcnRiZWF0KCkge1xyXG4gICAgaWYgKHRoaXMuaGVhcnRiZWF0VGltZXIpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcclxuICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB0aGlzLmxhc3RIZWFydGJlYXRBY2sgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBoYW5kbGVUZXh0TWVzc2FnZShyYXc6IHN0cmluZykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UocmF3KTtcclxuICAgICAgY29uc3Qgc3RvcmUgPSB1c2VTaW11bGF0aW9uU3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSBcIlNUQVRVU1wiOiB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2Uuc2ltdWxhdGlvbl9ydW5uaW5nID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICBzdG9yZS5zZXRTaW11bGF0aW9uUnVubmluZyhtZXNzYWdlLnNpbXVsYXRpb25fcnVubmluZyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbGV0IHRvdWNoZWQgPSBmYWxzZTtcclxuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5zaW1fdGltZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBzdG9yZS5zZXRUaW1lc3RhbXAobWVzc2FnZS5zaW1fdGltZSk7XHJcbiAgICAgICAgICAgIHRvdWNoZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICghdG91Y2hlZCkge1xyXG4gICAgICAgICAgICBzdG9yZS51cGRhdGVMYXN0VXBkYXRlVGltZShEYXRlLm5vdygpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMubGFzdEhlYXJ0YmVhdEFjayA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICB0aGlzLmV2YWx1YXRlU3RhdGVDaGFuZ2UoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiUE9OR1wiOlxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnNpbXVsYXRpb25fcnVubmluZyA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICAgICAgc3RvcmUuc2V0U2ltdWxhdGlvblJ1bm5pbmcobWVzc2FnZS5zaW11bGF0aW9uX3J1bm5pbmcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc3RvcmUudXBkYXRlTGFzdFVwZGF0ZVRpbWUoRGF0ZS5ub3coKSk7XHJcbiAgICAgICAgICB0aGlzLmxhc3RIZWFydGJlYXRBY2sgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgdGhpcy5ldmFsdWF0ZVN0YXRlQ2hhbmdlKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiSEVBUlRCRUFUX0FDS1wiOlxyXG4gICAgICAgICAgdGhpcy5sYXN0SGVhcnRiZWF0QWNrID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgIHN0b3JlLnVwZGF0ZUxhc3RVcGRhdGVUaW1lKERhdGUubm93KCkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gcGFyc2UgV2ViU29ja2V0IG1lc3NhZ2VcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBldmFsdWF0ZVN0YXRlQ2hhbmdlKCkge1xyXG4gICAgY29uc3QgeyBjb25uZWN0ZWQsIHNpbXVsYXRpb25SdW5uaW5nLCBpc1N0YWxlLCBjb25uZWN0aW9uU3RhdGUgfSA9IHVzZVNpbXVsYXRpb25TdG9yZS5nZXRTdGF0ZSgpO1xyXG5cclxuICAgIGlmIChjb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnICYmIHRoaXMubGFzdENvbm5lY3Rpb25QaGFzZSAmJiB0aGlzLmxhc3RDb25uZWN0aW9uUGhhc2UgIT09ICdjb25uZWN0ZWQnKSB7XHJcbiAgICAgIHRoaXMubWF5YmVOb3RpZnkoJ2Nvbm5lY3Rpb24tcmVzdG9yZWQnLCAoKSA9PiBub3RpZnkuc3VjY2VzcygnQ29ubmVjdGVkIHRvIHNpbXVsYXRpb24gc3RyZWFtLicpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29ubmVjdGlvblN0YXRlID09PSAncmVjb25uZWN0aW5nJykge1xyXG4gICAgICB0aGlzLm1heWJlTm90aWZ5KCdjb25uZWN0aW9uLXJlY29ubmVjdGluZycsICgpID0+IG5vdGlmeS53YXJuaW5nKCdDb25uZWN0aW9uIGxvc3QuIFJlY29ubmVjdGluZy4uLicpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29ubmVjdGlvblN0YXRlID09PSAnc3RhbGUnKSB7XHJcbiAgICAgIHRoaXMubWF5YmVOb3RpZnkoJ2Nvbm5lY3Rpb24tc3RhbGUnLCAoKSA9PiBub3RpZnkud2FybmluZygnU2ltdWxhdGlvbiBkYXRhIHN0cmVhbSBpcyBzdGFsZS4nKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgdGhpcy5sYXN0Q29ubmVjdGlvblBoYXNlICYmIHRoaXMubGFzdENvbm5lY3Rpb25QaGFzZSAhPT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcclxuICAgICAgdGhpcy5tYXliZU5vdGlmeSgnY29ubmVjdGlvbi1kaXNjb25uZWN0ZWQnLCAoKSA9PiBub3RpZnkuZXJyb3IoJ0Rpc2Nvbm5lY3RlZCBmcm9tIHNpbXVsYXRpb24gc3RyZWFtLicpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIHRoaXMubGFzdFNpbXVsYXRpb25SdW5uaW5nICE9PSBudWxsICYmXHJcbiAgICAgIHNpbXVsYXRpb25SdW5uaW5nICE9PSB0aGlzLmxhc3RTaW11bGF0aW9uUnVubmluZyAmJlxyXG4gICAgICBjb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnXHJcbiAgICApIHtcclxuICAgICAgaWYgKHNpbXVsYXRpb25SdW5uaW5nKSB7XHJcbiAgICAgICAgdGhpcy5tYXliZU5vdGlmeSgnc2ltdWxhdGlvbi1ydW5uaW5nJywgKCkgPT4gbm90aWZ5LnN1Y2Nlc3MoJ1NpbXVsYXRpb24gcnVubmluZy4nKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoIWlzU3RhbGUpIHtcclxuICAgICAgICB0aGlzLm1heWJlTm90aWZ5KCdzaW11bGF0aW9uLXN0b3BwZWQnLCAoKSA9PiBub3RpZnkud2FybmluZygnU2ltdWxhdGlvbiBzdG9wcGVkLicpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGFzdENvbm5lY3Rpb25QaGFzZSA9IGNvbm5lY3Rpb25TdGF0ZTtcclxuICAgIHRoaXMubGFzdENvbm5lY3Rpb25TdGF0ZSA9IGNvbm5lY3RlZDtcclxuICAgIHRoaXMubGFzdFNpbXVsYXRpb25SdW5uaW5nID0gc2ltdWxhdGlvblJ1bm5pbmc7XHJcbiAgICB0aGlzLmxhc3RTdGFsZVN0YXRlID0gaXNTdGFsZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgbWF5YmVOb3RpZnkoa2V5OiBzdHJpbmcsIHRyaWdnZXI6ICgpID0+IHZvaWQsIGNvb2xkb3duTXMgPSA1MDAwKSB7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc3QgbGFzdCA9IHRoaXMubGFzdE5vdGlmaWNhdGlvbkF0W2tleV0gPz8gMDtcclxuICAgIGlmIChub3cgLSBsYXN0ID49IGNvb2xkb3duTXMpIHtcclxuICAgICAgdHJpZ2dlcigpO1xyXG4gICAgICB0aGlzLmxhc3ROb3RpZmljYXRpb25BdFtrZXldID0gbm93O1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiZGVjb21wcmVzc1N5bmMiLCJ1c2VTaW11bGF0aW9uU3RvcmUiLCJNQVhfU0lNVUxBVElPTl9OT0RFUyIsIm5vdGlmeSIsIkhFQURFUl9VSU5UMzJfQ09VTlQiLCJIRUFERVJfRkxPQVRfQ09VTlQiLCJIRUFERVJfQllURVMiLCJGTEFHX0NPTVBSRVNTRUQiLCJwYXJzZU1zIiwidmFsdWUiLCJmYWxsYmFjayIsInBhcnNlZCIsIk51bWJlciIsImlzRmluaXRlIiwiREVGQVVMVF9IRUFSVEJFQVRfSU5URVJWQUxfTVMiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfV1NfSEVBUlRCRUFUX01TIiwiREVGQVVMVF9IRUFSVEJFQVRfVElNRU9VVF9NUyIsIk5FWFRfUFVCTElDX1dTX0hFQVJUQkVBVF9USU1FT1VUX01TIiwiREVGQVVMVF9SRUNPTk5FQ1RfQkFTRV9NUyIsIk5FWFRfUFVCTElDX1dTX1JFQ09OTkVDVF9CQVNFX01TIiwiREVGQVVMVF9SRUNPTk5FQ1RfTUFYX01TIiwiTkVYVF9QVUJMSUNfV1NfUkVDT05ORUNUX01BWF9NUyIsIkdNQ1NXZWJTb2NrZXQiLCJjb25uZWN0Iiwid3MiLCJzdG9yZUFwaSIsImdldFN0YXRlIiwibGFzdENvbm5lY3Rpb25TdGF0ZSIsImNvbm5lY3RlZCIsImxhc3RTaW11bGF0aW9uUnVubmluZyIsInNpbXVsYXRpb25SdW5uaW5nIiwibGFzdFN0YWxlU3RhdGUiLCJpc1N0YWxlIiwicGhhc2UiLCJyZWNvbm5lY3RBdHRlbXB0cyIsInNldENvbm5lY3Rpb25TdGF0ZSIsInNvY2tldCIsIldlYlNvY2tldCIsInVybCIsImJpbmFyeVR5cGUiLCJvbm9wZW4iLCJzdG9yZSIsInNldENvbm5lY3RlZCIsInVwZGF0ZUxhc3RVcGRhdGVUaW1lIiwiRGF0ZSIsIm5vdyIsInN0YXJ0U3RhbGVNb25pdG9yIiwic3RhcnRIZWFydGJlYXQiLCJsYXN0SGVhcnRiZWF0QWNrIiwiZXZhbHVhdGVTdGF0ZUNoYW5nZSIsIm9uY2xvc2UiLCJtYXJrU3RhbGUiLCJzdG9wSGVhcnRiZWF0Iiwic3RvcFN0YWxlTW9uaXRvciIsInNjaGVkdWxlUmVjb25uZWN0Iiwib25lcnJvciIsImNsb3NlIiwib25tZXNzYWdlIiwiZXZlbnQiLCJkYXRhIiwiQXJyYXlCdWZmZXIiLCJoYW5kbGVCdWZmZXIiLCJCbG9iIiwiYXJyYXlCdWZmZXIiLCJ0aGVuIiwiYnVmZmVyIiwiaGFuZGxlVGV4dE1lc3NhZ2UiLCJkaXNjb25uZWN0IiwicmVjb25uZWN0VGltZXIiLCJjbGVhclRpbWVvdXQiLCJhdHRlbXB0IiwiZGVsYXkiLCJNYXRoIiwibWluIiwiYmFzZVJlY29ubmVjdERlbGF5IiwicG93IiwibWF4UmVjb25uZWN0RGVsYXkiLCJzZXRUaW1lb3V0IiwiYnl0ZUxlbmd0aCIsImhlYWRlciIsIkRhdGFWaWV3IiwiZG93blciLCJnZXRVaW50MzIiLCJkb3duSCIsImFjdGl2ZUNvdW50IiwiY2FwYWNpdHkiLCJmbGFncyIsInBheWxvYWRTaXplIiwic3RvcmVkU2l6ZSIsInJ1bm5pbmdGbGFnIiwic2ltVGltZSIsImdldEZsb2F0MzIiLCJzZXRTaW11bGF0aW9uUnVubmluZyIsIkJvb2xlYW4iLCJzZXRUaW1lc3RhbXAiLCJwYXlsb2FkIiwiVWludDhBcnJheSIsImxlbmd0aCIsInNsaWNlIiwib2Zmc2V0IiwiZmllbGRDb3VudCIsImZpZWxkQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJieXRlT2Zmc2V0IiwiZmllbGRDb3B5Iiwib3NjQXJyYXkiLCJvc2NDb3B5IiwicG9zQXJyYXkiLCJwb3NDb3B5IiwibWFza0FycmF5IiwibWFza0NvcHkiLCJhbXBsaXR1ZGVzIiwiaSIsImFicyIsInNldEZpZWxkIiwic2V0T3NjaWxsYXRvcnMiLCJzdGFsZVRpbWVyIiwic2V0SW50ZXJ2YWwiLCJiZWZvcmUiLCJjaGVja1N0YWxlU3RhdHVzIiwiYWZ0ZXIiLCJjbGVhckludGVydmFsIiwiaGVhcnRiZWF0VGltZXIiLCJyZWFkeVN0YXRlIiwiT1BFTiIsInNlbmQiLCJKU09OIiwic3RyaW5naWZ5IiwidHlwZSIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJoZWFydGJlYXRUaW1lb3V0TXMiLCJoZWFydGJlYXRJbnRlcnZhbE1zIiwicmF3IiwibWVzc2FnZSIsInBhcnNlIiwic2ltdWxhdGlvbl9ydW5uaW5nIiwidG91Y2hlZCIsInNpbV90aW1lIiwiY29ubmVjdGlvblN0YXRlIiwibGFzdENvbm5lY3Rpb25QaGFzZSIsIm1heWJlTm90aWZ5Iiwic3VjY2VzcyIsIndhcm5pbmciLCJrZXkiLCJ0cmlnZ2VyIiwiY29vbGRvd25NcyIsImxhc3QiLCJsYXN0Tm90aWZpY2F0aW9uQXQiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJyZWNvbm5lY3REZWxheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/websocket.ts\n"));

/***/ })

});