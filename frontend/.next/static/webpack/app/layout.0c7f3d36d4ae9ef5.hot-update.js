"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"bc1ffb61330e\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzPzJkNDEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJiYzFmZmI2MTMzMGVcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/websocket.ts":
/*!**************************!*\
  !*** ./lib/websocket.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GMCSWebSocket: function() { return /* binding */ GMCSWebSocket; }\n/* harmony export */ });\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fflate */ \"(app-pages-browser)/./node_modules/fflate/esm/browser.js\");\n/* harmony import */ var _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/stores/simulation */ \"(app-pages-browser)/./lib/stores/simulation.ts\");\n/* harmony import */ var _components_UI_Notification__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/UI/Notification */ \"(app-pages-browser)/./components/UI/Notification.tsx\");\n\n\n\nconst HEADER_UINT32_COUNT = 8;\nconst HEADER_FLOAT_COUNT = 1;\nconst HEADER_BYTES = (HEADER_UINT32_COUNT + HEADER_FLOAT_COUNT) * 4;\nconst FLAG_COMPRESSED = 1 << 0;\nclass GMCSWebSocket {\n    connect() {\n        if (this.ws) {\n            return;\n        }\n        const initial = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState();\n        this.lastConnectionState = initial.connected;\n        this.lastSimulationRunning = initial.simulationRunning;\n        this.lastStaleState = initial.isStale;\n        const socket = new WebSocket(this.url);\n        socket.binaryType = \"arraybuffer\";\n        socket.onopen = ()=>{\n            const store = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState();\n            store.setConnected(true);\n            store.updateLastUpdateTime(Date.now());\n            this.startStaleMonitor();\n            this.evaluateStateChange();\n        };\n        socket.onclose = ()=>{\n            const store = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState();\n            store.setConnected(false);\n            store.markStale();\n            this.stopStaleMonitor();\n            this.scheduleReconnect();\n            this.evaluateStateChange();\n        };\n        socket.onerror = ()=>{\n            socket.close();\n        };\n        socket.onmessage = (event)=>{\n            const data = event.data;\n            if (data instanceof ArrayBuffer) {\n                this.handleBuffer(data);\n            } else if (data instanceof Blob) {\n                data.arrayBuffer().then((buffer)=>this.handleBuffer(buffer));\n            } else if (typeof data === \"string\") {\n                this.handleTextMessage(data);\n            }\n        };\n        this.ws = socket;\n    }\n    disconnect() {\n        if (this.reconnectTimer) {\n            clearTimeout(this.reconnectTimer);\n            this.reconnectTimer = null;\n        }\n        this.stopStaleMonitor();\n        if (this.ws) {\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    scheduleReconnect() {\n        if (this.reconnectTimer) {\n            return;\n        }\n        this.reconnectTimer = setTimeout(()=>{\n            this.ws = null;\n            this.reconnectTimer = null;\n            this.connect();\n        }, this.reconnectDelay);\n    }\n    handleBuffer(buffer) {\n        if (buffer.byteLength < HEADER_BYTES) {\n            return;\n        }\n        const header = new DataView(buffer, 0, HEADER_BYTES);\n        const downW = header.getUint32(0, true);\n        const downH = header.getUint32(1 * 4, true);\n        const activeCount = header.getUint32(2 * 4, true);\n        const capacity = header.getUint32(3 * 4, true);\n        const flags = header.getUint32(4 * 4, true);\n        const payloadSize = header.getUint32(5 * 4, true);\n        const storedSize = header.getUint32(6 * 4, true);\n        const runningFlag = header.getUint32(7 * 4, true);\n        const simTime = header.getFloat32(8 * 4, true);\n        const store = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState();\n        store.setSimulationRunning(Boolean(runningFlag));\n        if (payloadSize === 0 || storedSize === 0) {\n            store.setTimestamp(simTime);\n            return;\n        }\n        let payload = new Uint8Array(buffer, HEADER_BYTES, storedSize);\n        if (flags & FLAG_COMPRESSED) {\n            payload = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.decompressSync)(payload);\n        } else if (payloadSize !== payload.length) {\n            payload = payload.slice(0, payloadSize);\n        }\n        let offset = 0;\n        const fieldCount = downW * downH;\n        const fieldArray = new Float32Array(payload.buffer, payload.byteOffset + offset, fieldCount);\n        const fieldCopy = new Float32Array(fieldArray);\n        offset += fieldCount * 4;\n        const oscArray = new Float32Array(payload.buffer, payload.byteOffset + offset, activeCount * 3);\n        const oscCopy = new Float32Array(oscArray);\n        offset += activeCount * 3 * 4;\n        const posArray = new Float32Array(payload.buffer, payload.byteOffset + offset, activeCount * 3);\n        const posCopy = new Float32Array(posArray);\n        offset += activeCount * 3 * 4;\n        const maskArray = new Float32Array(payload.buffer, payload.byteOffset + offset, activeCount);\n        const maskCopy = new Float32Array(maskArray);\n        const amplitudes = new Float32Array(activeCount);\n        for(let i = 0; i < activeCount; i += 1){\n            var _maskCopy_i;\n            amplitudes[i] = Math.abs(oscCopy[i * 3]) * ((_maskCopy_i = maskCopy[i]) !== null && _maskCopy_i !== void 0 ? _maskCopy_i : 1);\n        }\n        store.setField(fieldCopy, downW, downH);\n        store.setOscillators(posCopy, amplitudes, Math.min(activeCount, _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.MAX_SIMULATION_NODES));\n        store.setTimestamp(simTime);\n        this.evaluateStateChange();\n    }\n    startStaleMonitor() {\n        if (this.staleTimer) {\n            return;\n        }\n        this.staleTimer = setInterval(()=>{\n            const before = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState().isStale;\n            _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState().checkStaleStatus();\n            const after = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState().isStale;\n            if (before !== after) {\n                this.evaluateStateChange();\n            }\n        }, 1000);\n    }\n    stopStaleMonitor() {\n        if (this.staleTimer) {\n            clearInterval(this.staleTimer);\n            this.staleTimer = null;\n        }\n    }\n    handleTextMessage(raw) {\n        try {\n            const message = JSON.parse(raw);\n            const store = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState();\n            switch(message.type){\n                case \"STATUS\":\n                    {\n                        if (typeof message.simulation_running === \"boolean\") {\n                            store.setSimulationRunning(message.simulation_running);\n                        }\n                        let touched = false;\n                        if (typeof message.sim_time === \"number\") {\n                            store.setTimestamp(message.sim_time);\n                            touched = true;\n                        }\n                        if (!touched) {\n                            store.updateLastUpdateTime(Date.now());\n                        }\n                        this.evaluateStateChange();\n                        break;\n                    }\n                case \"PONG\":\n                    if (typeof message.simulation_running === \"boolean\") {\n                        store.setSimulationRunning(message.simulation_running);\n                    }\n                    store.updateLastUpdateTime(Date.now());\n                    this.evaluateStateChange();\n                    break;\n                default:\n                    break;\n            }\n        } catch (error) {\n            console.warn(\"Failed to parse WebSocket message\", error);\n        }\n    }\n    evaluateStateChange() {\n        const { connected, simulationRunning, isStale } = _lib_stores_simulation__WEBPACK_IMPORTED_MODULE_0__.useSimulationStore.getState();\n        if (this.lastConnectionState !== null && connected !== this.lastConnectionState) {\n            if (connected) {\n                _components_UI_Notification__WEBPACK_IMPORTED_MODULE_1__.notify.success(\"Reconnected to simulation stream.\");\n            } else {\n                _components_UI_Notification__WEBPACK_IMPORTED_MODULE_1__.notify.error(\"Connection to simulation stream lost. Attempting to reconnect...\");\n            }\n        }\n        if (this.lastStaleState !== null && isStale !== this.lastStaleState) {\n            if (isStale && connected) {\n                _components_UI_Notification__WEBPACK_IMPORTED_MODULE_1__.notify.warning(\"Simulation data stream is stale.\");\n            } else if (!isStale) {\n                _components_UI_Notification__WEBPACK_IMPORTED_MODULE_1__.notify.success(\"Simulation data stream restored.\");\n            }\n        }\n        if (this.lastSimulationRunning !== null && simulationRunning !== this.lastSimulationRunning) {\n            if (simulationRunning) {\n                _components_UI_Notification__WEBPACK_IMPORTED_MODULE_1__.notify.success(\"Simulation running.\");\n            } else if (connected && !isStale) {\n                _components_UI_Notification__WEBPACK_IMPORTED_MODULE_1__.notify.warning(\"Simulation stopped.\");\n            }\n        }\n        this.lastConnectionState = connected;\n        this.lastSimulationRunning = simulationRunning;\n        this.lastStaleState = isStale;\n    }\n    constructor(options = {}){\n        this.ws = null;\n        this.reconnectTimer = null;\n        this.staleTimer = null;\n        this.lastSimulationRunning = null;\n        this.lastConnectionState = false;\n        this.lastStaleState = false;\n        const { url = \"ws://localhost:8000/ws/stream\", reconnectDelay = 2000 } = options;\n        this.url = url;\n        this.reconnectDelay = reconnectDelay;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi93ZWJzb2NrZXQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3QztBQUMyQztBQUM3QjtBQU90RCxNQUFNSSxzQkFBc0I7QUFDNUIsTUFBTUMscUJBQXFCO0FBQzNCLE1BQU1DLGVBQWUsQ0FBQ0Ysc0JBQXNCQyxrQkFBaUIsSUFBSztBQUNsRSxNQUFNRSxrQkFBa0IsS0FBSztBQUV0QixNQUFNQztJQXVCWEMsVUFBVTtRQUNSLElBQUksSUFBSSxDQUFDQyxFQUFFLEVBQUU7WUFDWDtRQUNGO1FBRUEsTUFBTUMsVUFBVVYsc0VBQWtCQSxDQUFDVyxRQUFRO1FBQzNDLElBQUksQ0FBQ0MsbUJBQW1CLEdBQUdGLFFBQVFHLFNBQVM7UUFDNUMsSUFBSSxDQUFDQyxxQkFBcUIsR0FBR0osUUFBUUssaUJBQWlCO1FBQ3RELElBQUksQ0FBQ0MsY0FBYyxHQUFHTixRQUFRTyxPQUFPO1FBRXJDLE1BQU1DLFNBQVMsSUFBSUMsVUFBVSxJQUFJLENBQUNDLEdBQUc7UUFDckNGLE9BQU9HLFVBQVUsR0FBRztRQUVwQkgsT0FBT0ksTUFBTSxHQUFHO1lBQ2QsTUFBTUMsUUFBUXZCLHNFQUFrQkEsQ0FBQ1csUUFBUTtZQUN6Q1ksTUFBTUMsWUFBWSxDQUFDO1lBQ25CRCxNQUFNRSxvQkFBb0IsQ0FBQ0MsS0FBS0MsR0FBRztZQUNuQyxJQUFJLENBQUNDLGlCQUFpQjtZQUN0QixJQUFJLENBQUNDLG1CQUFtQjtRQUMxQjtRQUVBWCxPQUFPWSxPQUFPLEdBQUc7WUFDZixNQUFNUCxRQUFRdkIsc0VBQWtCQSxDQUFDVyxRQUFRO1lBQ3pDWSxNQUFNQyxZQUFZLENBQUM7WUFDbkJELE1BQU1RLFNBQVM7WUFDZixJQUFJLENBQUNDLGdCQUFnQjtZQUNyQixJQUFJLENBQUNDLGlCQUFpQjtZQUN0QixJQUFJLENBQUNKLG1CQUFtQjtRQUMxQjtRQUVBWCxPQUFPZ0IsT0FBTyxHQUFHO1lBQ2ZoQixPQUFPaUIsS0FBSztRQUNkO1FBRUFqQixPQUFPa0IsU0FBUyxHQUFHLENBQUNDO1lBQ2xCLE1BQU1DLE9BQU9ELE1BQU1DLElBQUk7WUFDdkIsSUFBSUEsZ0JBQWdCQyxhQUFhO2dCQUMvQixJQUFJLENBQUNDLFlBQVksQ0FBQ0Y7WUFDcEIsT0FBTyxJQUFJQSxnQkFBZ0JHLE1BQU07Z0JBQy9CSCxLQUFLSSxXQUFXLEdBQUdDLElBQUksQ0FBQyxDQUFDQyxTQUFXLElBQUksQ0FBQ0osWUFBWSxDQUFDSTtZQUN4RCxPQUFPLElBQUksT0FBT04sU0FBUyxVQUFVO2dCQUNuQyxJQUFJLENBQUNPLGlCQUFpQixDQUFDUDtZQUN6QjtRQUNGO1FBRUEsSUFBSSxDQUFDN0IsRUFBRSxHQUFHUztJQUNaO0lBRUE0QixhQUFhO1FBQ1gsSUFBSSxJQUFJLENBQUNDLGNBQWMsRUFBRTtZQUN2QkMsYUFBYSxJQUFJLENBQUNELGNBQWM7WUFDaEMsSUFBSSxDQUFDQSxjQUFjLEdBQUc7UUFDeEI7UUFFQSxJQUFJLENBQUNmLGdCQUFnQjtRQUVyQixJQUFJLElBQUksQ0FBQ3ZCLEVBQUUsRUFBRTtZQUNYLElBQUksQ0FBQ0EsRUFBRSxDQUFDMEIsS0FBSztZQUNiLElBQUksQ0FBQzFCLEVBQUUsR0FBRztRQUNaO0lBQ0Y7SUFFUXdCLG9CQUFvQjtRQUMxQixJQUFJLElBQUksQ0FBQ2MsY0FBYyxFQUFFO1lBQ3ZCO1FBQ0Y7UUFFQSxJQUFJLENBQUNBLGNBQWMsR0FBR0UsV0FBVztZQUMvQixJQUFJLENBQUN4QyxFQUFFLEdBQUc7WUFDVixJQUFJLENBQUNzQyxjQUFjLEdBQUc7WUFDdEIsSUFBSSxDQUFDdkMsT0FBTztRQUNkLEdBQUcsSUFBSSxDQUFDMEMsY0FBYztJQUN4QjtJQUVRVixhQUFhSSxNQUFtQixFQUFFO1FBQ3hDLElBQUlBLE9BQU9PLFVBQVUsR0FBRzlDLGNBQWM7WUFDcEM7UUFDRjtRQUVBLE1BQU0rQyxTQUFTLElBQUlDLFNBQVNULFFBQVEsR0FBR3ZDO1FBQ3ZDLE1BQU1pRCxRQUFRRixPQUFPRyxTQUFTLENBQUMsR0FBRztRQUNsQyxNQUFNQyxRQUFRSixPQUFPRyxTQUFTLENBQUMsSUFBSSxHQUFHO1FBQ3RDLE1BQU1FLGNBQWNMLE9BQU9HLFNBQVMsQ0FBQyxJQUFJLEdBQUc7UUFDNUMsTUFBTUcsV0FBV04sT0FBT0csU0FBUyxDQUFDLElBQUksR0FBRztRQUN6QyxNQUFNSSxRQUFRUCxPQUFPRyxTQUFTLENBQUMsSUFBSSxHQUFHO1FBQ3RDLE1BQU1LLGNBQWNSLE9BQU9HLFNBQVMsQ0FBQyxJQUFJLEdBQUc7UUFDNUMsTUFBTU0sYUFBYVQsT0FBT0csU0FBUyxDQUFDLElBQUksR0FBRztRQUMzQyxNQUFNTyxjQUFjVixPQUFPRyxTQUFTLENBQUMsSUFBSSxHQUFHO1FBQzVDLE1BQU1RLFVBQVVYLE9BQU9ZLFVBQVUsQ0FBQyxJQUFJLEdBQUc7UUFFekMsTUFBTXpDLFFBQVF2QixzRUFBa0JBLENBQUNXLFFBQVE7UUFDekNZLE1BQU0wQyxvQkFBb0IsQ0FBQ0MsUUFBUUo7UUFFbkMsSUFBSUYsZ0JBQWdCLEtBQUtDLGVBQWUsR0FBRztZQUN6Q3RDLE1BQU00QyxZQUFZLENBQUNKO1lBQ25CO1FBQ0Y7UUFFQSxJQUFJSyxVQUFzQixJQUFJQyxXQUFXekIsUUFBUXZDLGNBQWN3RDtRQUMvRCxJQUFJRixRQUFRckQsaUJBQWlCO1lBQzNCOEQsVUFBVXJFLHNEQUFjQSxDQUFDcUU7UUFDM0IsT0FBTyxJQUFJUixnQkFBZ0JRLFFBQVFFLE1BQU0sRUFBRTtZQUN6Q0YsVUFBVUEsUUFBUUcsS0FBSyxDQUFDLEdBQUdYO1FBQzdCO1FBRUEsSUFBSVksU0FBUztRQUNiLE1BQU1DLGFBQWFuQixRQUFRRTtRQUMzQixNQUFNa0IsYUFBYSxJQUFJQyxhQUFhUCxRQUFReEIsTUFBTSxFQUFFd0IsUUFBUVEsVUFBVSxHQUFHSixRQUFRQztRQUNqRixNQUFNSSxZQUFZLElBQUlGLGFBQWFEO1FBQ25DRixVQUFVQyxhQUFhO1FBRXZCLE1BQU1LLFdBQVcsSUFBSUgsYUFBYVAsUUFBUXhCLE1BQU0sRUFBRXdCLFFBQVFRLFVBQVUsR0FBR0osUUFBUWYsY0FBYztRQUM3RixNQUFNc0IsVUFBVSxJQUFJSixhQUFhRztRQUNqQ04sVUFBVWYsY0FBYyxJQUFJO1FBRTVCLE1BQU11QixXQUFXLElBQUlMLGFBQWFQLFFBQVF4QixNQUFNLEVBQUV3QixRQUFRUSxVQUFVLEdBQUdKLFFBQVFmLGNBQWM7UUFDN0YsTUFBTXdCLFVBQVUsSUFBSU4sYUFBYUs7UUFDakNSLFVBQVVmLGNBQWMsSUFBSTtRQUU1QixNQUFNeUIsWUFBWSxJQUFJUCxhQUFhUCxRQUFReEIsTUFBTSxFQUFFd0IsUUFBUVEsVUFBVSxHQUFHSixRQUFRZjtRQUNoRixNQUFNMEIsV0FBVyxJQUFJUixhQUFhTztRQUVsQyxNQUFNRSxhQUFhLElBQUlULGFBQWFsQjtRQUNwQyxJQUFLLElBQUk0QixJQUFJLEdBQUdBLElBQUk1QixhQUFhNEIsS0FBSyxFQUFHO2dCQUNLRjtZQUE1Q0MsVUFBVSxDQUFDQyxFQUFFLEdBQUdDLEtBQUtDLEdBQUcsQ0FBQ1IsT0FBTyxDQUFDTSxJQUFJLEVBQUUsSUFBS0YsQ0FBQUEsQ0FBQUEsY0FBQUEsUUFBUSxDQUFDRSxFQUFFLGNBQVhGLHlCQUFBQSxjQUFlO1FBQzdEO1FBRUE1RCxNQUFNaUUsUUFBUSxDQUFDWCxXQUFXdkIsT0FBT0U7UUFDakNqQyxNQUFNa0UsY0FBYyxDQUFDUixTQUFTRyxZQUFZRSxLQUFLSSxHQUFHLENBQUNqQyxhQUFheEQsd0VBQW9CQTtRQUNwRnNCLE1BQU00QyxZQUFZLENBQUNKO1FBQ25CLElBQUksQ0FBQ2xDLG1CQUFtQjtJQUMxQjtJQUVRRCxvQkFBb0I7UUFDMUIsSUFBSSxJQUFJLENBQUMrRCxVQUFVLEVBQUU7WUFDbkI7UUFDRjtRQUVBLElBQUksQ0FBQ0EsVUFBVSxHQUFHQyxZQUFZO1lBQzVCLE1BQU1DLFNBQVM3RixzRUFBa0JBLENBQUNXLFFBQVEsR0FBR00sT0FBTztZQUNwRGpCLHNFQUFrQkEsQ0FBQ1csUUFBUSxHQUFHbUYsZ0JBQWdCO1lBQzlDLE1BQU1DLFFBQVEvRixzRUFBa0JBLENBQUNXLFFBQVEsR0FBR00sT0FBTztZQUNuRCxJQUFJNEUsV0FBV0UsT0FBTztnQkFDcEIsSUFBSSxDQUFDbEUsbUJBQW1CO1lBQzFCO1FBQ0YsR0FBRztJQUNMO0lBRVFHLG1CQUFtQjtRQUN6QixJQUFJLElBQUksQ0FBQzJELFVBQVUsRUFBRTtZQUNuQkssY0FBYyxJQUFJLENBQUNMLFVBQVU7WUFDN0IsSUFBSSxDQUFDQSxVQUFVLEdBQUc7UUFDcEI7SUFDRjtJQUVROUMsa0JBQWtCb0QsR0FBVyxFQUFFO1FBQ3JDLElBQUk7WUFDRixNQUFNQyxVQUFVQyxLQUFLQyxLQUFLLENBQUNIO1lBQzNCLE1BQU0xRSxRQUFRdkIsc0VBQWtCQSxDQUFDVyxRQUFRO1lBRXpDLE9BQVF1RixRQUFRRyxJQUFJO2dCQUNsQixLQUFLO29CQUFVO3dCQUNiLElBQUksT0FBT0gsUUFBUUksa0JBQWtCLEtBQUssV0FBVzs0QkFDbkQvRSxNQUFNMEMsb0JBQW9CLENBQUNpQyxRQUFRSSxrQkFBa0I7d0JBQ3ZEO3dCQUVBLElBQUlDLFVBQVU7d0JBQ2QsSUFBSSxPQUFPTCxRQUFRTSxRQUFRLEtBQUssVUFBVTs0QkFDeENqRixNQUFNNEMsWUFBWSxDQUFDK0IsUUFBUU0sUUFBUTs0QkFDbkNELFVBQVU7d0JBQ1o7d0JBRUEsSUFBSSxDQUFDQSxTQUFTOzRCQUNaaEYsTUFBTUUsb0JBQW9CLENBQUNDLEtBQUtDLEdBQUc7d0JBQ3JDO3dCQUNBLElBQUksQ0FBQ0UsbUJBQW1CO3dCQUN4QjtvQkFDRjtnQkFDQSxLQUFLO29CQUNILElBQUksT0FBT3FFLFFBQVFJLGtCQUFrQixLQUFLLFdBQVc7d0JBQ25EL0UsTUFBTTBDLG9CQUFvQixDQUFDaUMsUUFBUUksa0JBQWtCO29CQUN2RDtvQkFDQS9FLE1BQU1FLG9CQUFvQixDQUFDQyxLQUFLQyxHQUFHO29CQUNuQyxJQUFJLENBQUNFLG1CQUFtQjtvQkFDeEI7Z0JBQ0Y7b0JBQ0U7WUFDSjtRQUNGLEVBQUUsT0FBTzRFLE9BQU87WUFDZEMsUUFBUUMsSUFBSSxDQUFDLHFDQUFxQ0Y7UUFDcEQ7SUFDRjtJQUVRNUUsc0JBQXNCO1FBQzVCLE1BQU0sRUFBRWhCLFNBQVMsRUFBRUUsaUJBQWlCLEVBQUVFLE9BQU8sRUFBRSxHQUFHakIsc0VBQWtCQSxDQUFDVyxRQUFRO1FBRTdFLElBQUksSUFBSSxDQUFDQyxtQkFBbUIsS0FBSyxRQUFRQyxjQUFjLElBQUksQ0FBQ0QsbUJBQW1CLEVBQUU7WUFDL0UsSUFBSUMsV0FBVztnQkFDYlgsK0RBQU1BLENBQUMwRyxPQUFPLENBQUM7WUFDakIsT0FBTztnQkFDTDFHLCtEQUFNQSxDQUFDdUcsS0FBSyxDQUFDO1lBQ2Y7UUFDRjtRQUVBLElBQUksSUFBSSxDQUFDekYsY0FBYyxLQUFLLFFBQVFDLFlBQVksSUFBSSxDQUFDRCxjQUFjLEVBQUU7WUFDbkUsSUFBSUMsV0FBV0osV0FBVztnQkFDeEJYLCtEQUFNQSxDQUFDMkcsT0FBTyxDQUFDO1lBQ2pCLE9BQU8sSUFBSSxDQUFDNUYsU0FBUztnQkFDbkJmLCtEQUFNQSxDQUFDMEcsT0FBTyxDQUFDO1lBQ2pCO1FBQ0Y7UUFFQSxJQUFJLElBQUksQ0FBQzlGLHFCQUFxQixLQUFLLFFBQVFDLHNCQUFzQixJQUFJLENBQUNELHFCQUFxQixFQUFFO1lBQzNGLElBQUlDLG1CQUFtQjtnQkFDckJiLCtEQUFNQSxDQUFDMEcsT0FBTyxDQUFDO1lBQ2pCLE9BQU8sSUFBSS9GLGFBQWEsQ0FBQ0ksU0FBUztnQkFDaENmLCtEQUFNQSxDQUFDMkcsT0FBTyxDQUFDO1lBQ2pCO1FBQ0Y7UUFFQSxJQUFJLENBQUNqRyxtQkFBbUIsR0FBR0M7UUFDM0IsSUFBSSxDQUFDQyxxQkFBcUIsR0FBR0M7UUFDN0IsSUFBSSxDQUFDQyxjQUFjLEdBQUdDO0lBQ3hCO0lBck9BNkYsWUFBWUMsVUFBZ0MsQ0FBQyxDQUFDLENBQUU7YUFoQnhDdEcsS0FBdUI7YUFFdkJzQyxpQkFBdUQ7YUFFdkQ0QyxhQUFvRDthQUVwRDdFLHdCQUF3QzthQUV4Q0Ysc0JBQXNCO2FBRXRCSSxpQkFBaUI7UUFPdkIsTUFBTSxFQUFFSSxNQUFNLCtCQUErQixFQUFFOEIsaUJBQWlCLElBQUksRUFBRSxHQUFHNkQ7UUFDekUsSUFBSSxDQUFDM0YsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQzhCLGNBQWMsR0FBR0E7SUFDeEI7QUFrT0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3dlYnNvY2tldC50cz8yMjFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlY29tcHJlc3NTeW5jIH0gZnJvbSBcImZmbGF0ZVwiO1xyXG5pbXBvcnQgeyB1c2VTaW11bGF0aW9uU3RvcmUsIE1BWF9TSU1VTEFUSU9OX05PREVTIH0gZnJvbSBcIkAvbGliL3N0b3Jlcy9zaW11bGF0aW9uXCI7XHJcbmltcG9ydCB7IG5vdGlmeSB9IGZyb20gXCJAL2NvbXBvbmVudHMvVUkvTm90aWZpY2F0aW9uXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEdNQ1NXZWJTb2NrZXRPcHRpb25zIHtcclxuICB1cmw/OiBzdHJpbmc7XHJcbiAgcmVjb25uZWN0RGVsYXk/OiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IEhFQURFUl9VSU5UMzJfQ09VTlQgPSA4O1xyXG5jb25zdCBIRUFERVJfRkxPQVRfQ09VTlQgPSAxO1xyXG5jb25zdCBIRUFERVJfQllURVMgPSAoSEVBREVSX1VJTlQzMl9DT1VOVCArIEhFQURFUl9GTE9BVF9DT1VOVCkgKiA0O1xyXG5jb25zdCBGTEFHX0NPTVBSRVNTRUQgPSAxIDw8IDA7XHJcblxyXG5leHBvcnQgY2xhc3MgR01DU1dlYlNvY2tldCB7XHJcbiAgcHJpdmF0ZSB3czogV2ViU29ja2V0IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIHByaXZhdGUgcmVjb25uZWN0VGltZXI6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIHByaXZhdGUgc3RhbGVUaW1lcjogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIHByaXZhdGUgbGFzdFNpbXVsYXRpb25SdW5uaW5nOiBib29sZWFuIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIHByaXZhdGUgbGFzdENvbm5lY3Rpb25TdGF0ZSA9IGZhbHNlO1xyXG5cclxuICBwcml2YXRlIGxhc3RTdGFsZVN0YXRlID0gZmFsc2U7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgdXJsOiBzdHJpbmc7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgcmVjb25uZWN0RGVsYXk6IG51bWJlcjtcclxuXHJcbiAgY29uc3RydWN0b3Iob3B0aW9uczogR01DU1dlYlNvY2tldE9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgeyB1cmwgPSBcIndzOi8vbG9jYWxob3N0OjgwMDAvd3Mvc3RyZWFtXCIsIHJlY29ubmVjdERlbGF5ID0gMjAwMCB9ID0gb3B0aW9ucztcclxuICAgIHRoaXMudXJsID0gdXJsO1xyXG4gICAgdGhpcy5yZWNvbm5lY3REZWxheSA9IHJlY29ubmVjdERlbGF5O1xyXG4gIH1cclxuXHJcbiAgY29ubmVjdCgpIHtcclxuICAgIGlmICh0aGlzLndzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpbml0aWFsID0gdXNlU2ltdWxhdGlvblN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICB0aGlzLmxhc3RDb25uZWN0aW9uU3RhdGUgPSBpbml0aWFsLmNvbm5lY3RlZDtcclxuICAgIHRoaXMubGFzdFNpbXVsYXRpb25SdW5uaW5nID0gaW5pdGlhbC5zaW11bGF0aW9uUnVubmluZztcclxuICAgIHRoaXMubGFzdFN0YWxlU3RhdGUgPSBpbml0aWFsLmlzU3RhbGU7XHJcblxyXG4gICAgY29uc3Qgc29ja2V0ID0gbmV3IFdlYlNvY2tldCh0aGlzLnVybCk7XHJcbiAgICBzb2NrZXQuYmluYXJ5VHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuXHJcbiAgICBzb2NrZXQub25vcGVuID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBzdG9yZSA9IHVzZVNpbXVsYXRpb25TdG9yZS5nZXRTdGF0ZSgpO1xyXG4gICAgICBzdG9yZS5zZXRDb25uZWN0ZWQodHJ1ZSk7XHJcbiAgICAgIHN0b3JlLnVwZGF0ZUxhc3RVcGRhdGVUaW1lKERhdGUubm93KCkpO1xyXG4gICAgICB0aGlzLnN0YXJ0U3RhbGVNb25pdG9yKCk7XHJcbiAgICAgIHRoaXMuZXZhbHVhdGVTdGF0ZUNoYW5nZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzb2NrZXQub25jbG9zZSA9ICgpID0+IHtcclxuICAgICAgY29uc3Qgc3RvcmUgPSB1c2VTaW11bGF0aW9uU3RvcmUuZ2V0U3RhdGUoKTtcclxuICAgICAgc3RvcmUuc2V0Q29ubmVjdGVkKGZhbHNlKTtcclxuICAgICAgc3RvcmUubWFya1N0YWxlKCk7XHJcbiAgICAgIHRoaXMuc3RvcFN0YWxlTW9uaXRvcigpO1xyXG4gICAgICB0aGlzLnNjaGVkdWxlUmVjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuZXZhbHVhdGVTdGF0ZUNoYW5nZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzb2NrZXQub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgc29ja2V0LmNsb3NlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNvY2tldC5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGE7XHJcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZUJ1ZmZlcihkYXRhKTtcclxuICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQmxvYikge1xyXG4gICAgICAgIGRhdGEuYXJyYXlCdWZmZXIoKS50aGVuKChidWZmZXIpID0+IHRoaXMuaGFuZGxlQnVmZmVyKGJ1ZmZlcikpO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVUZXh0TWVzc2FnZShkYXRhKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLndzID0gc29ja2V0O1xyXG4gIH1cclxuXHJcbiAgZGlzY29ubmVjdCgpIHtcclxuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVyKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVyKTtcclxuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdG9wU3RhbGVNb25pdG9yKCk7XHJcblxyXG4gICAgaWYgKHRoaXMud3MpIHtcclxuICAgICAgdGhpcy53cy5jbG9zZSgpO1xyXG4gICAgICB0aGlzLndzID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgc2NoZWR1bGVSZWNvbm5lY3QoKSB7XHJcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzLndzID0gbnVsbDtcclxuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGw7XHJcbiAgICAgIHRoaXMuY29ubmVjdCgpO1xyXG4gICAgfSwgdGhpcy5yZWNvbm5lY3REZWxheSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGhhbmRsZUJ1ZmZlcihidWZmZXI6IEFycmF5QnVmZmVyKSB7XHJcbiAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPCBIRUFERVJfQllURVMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhlYWRlciA9IG5ldyBEYXRhVmlldyhidWZmZXIsIDAsIEhFQURFUl9CWVRFUyk7XHJcbiAgICBjb25zdCBkb3duVyA9IGhlYWRlci5nZXRVaW50MzIoMCwgdHJ1ZSk7XHJcbiAgICBjb25zdCBkb3duSCA9IGhlYWRlci5nZXRVaW50MzIoMSAqIDQsIHRydWUpO1xyXG4gICAgY29uc3QgYWN0aXZlQ291bnQgPSBoZWFkZXIuZ2V0VWludDMyKDIgKiA0LCB0cnVlKTtcclxuICAgIGNvbnN0IGNhcGFjaXR5ID0gaGVhZGVyLmdldFVpbnQzMigzICogNCwgdHJ1ZSk7XHJcbiAgICBjb25zdCBmbGFncyA9IGhlYWRlci5nZXRVaW50MzIoNCAqIDQsIHRydWUpO1xyXG4gICAgY29uc3QgcGF5bG9hZFNpemUgPSBoZWFkZXIuZ2V0VWludDMyKDUgKiA0LCB0cnVlKTtcclxuICAgIGNvbnN0IHN0b3JlZFNpemUgPSBoZWFkZXIuZ2V0VWludDMyKDYgKiA0LCB0cnVlKTtcclxuICAgIGNvbnN0IHJ1bm5pbmdGbGFnID0gaGVhZGVyLmdldFVpbnQzMig3ICogNCwgdHJ1ZSk7XHJcbiAgICBjb25zdCBzaW1UaW1lID0gaGVhZGVyLmdldEZsb2F0MzIoOCAqIDQsIHRydWUpO1xyXG5cclxuICAgIGNvbnN0IHN0b3JlID0gdXNlU2ltdWxhdGlvblN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICBzdG9yZS5zZXRTaW11bGF0aW9uUnVubmluZyhCb29sZWFuKHJ1bm5pbmdGbGFnKSk7XHJcblxyXG4gICAgaWYgKHBheWxvYWRTaXplID09PSAwIHx8IHN0b3JlZFNpemUgPT09IDApIHtcclxuICAgICAgc3RvcmUuc2V0VGltZXN0YW1wKHNpbVRpbWUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHBheWxvYWQ6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIsIEhFQURFUl9CWVRFUywgc3RvcmVkU2l6ZSk7XHJcbiAgICBpZiAoZmxhZ3MgJiBGTEFHX0NPTVBSRVNTRUQpIHtcclxuICAgICAgcGF5bG9hZCA9IGRlY29tcHJlc3NTeW5jKHBheWxvYWQpO1xyXG4gICAgfSBlbHNlIGlmIChwYXlsb2FkU2l6ZSAhPT0gcGF5bG9hZC5sZW5ndGgpIHtcclxuICAgICAgcGF5bG9hZCA9IHBheWxvYWQuc2xpY2UoMCwgcGF5bG9hZFNpemUpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgY29uc3QgZmllbGRDb3VudCA9IGRvd25XICogZG93bkg7XHJcbiAgICBjb25zdCBmaWVsZEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShwYXlsb2FkLmJ1ZmZlciwgcGF5bG9hZC5ieXRlT2Zmc2V0ICsgb2Zmc2V0LCBmaWVsZENvdW50KTtcclxuICAgIGNvbnN0IGZpZWxkQ29weSA9IG5ldyBGbG9hdDMyQXJyYXkoZmllbGRBcnJheSk7XHJcbiAgICBvZmZzZXQgKz0gZmllbGRDb3VudCAqIDQ7XHJcblxyXG4gICAgY29uc3Qgb3NjQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHBheWxvYWQuYnVmZmVyLCBwYXlsb2FkLmJ5dGVPZmZzZXQgKyBvZmZzZXQsIGFjdGl2ZUNvdW50ICogMyk7XHJcbiAgICBjb25zdCBvc2NDb3B5ID0gbmV3IEZsb2F0MzJBcnJheShvc2NBcnJheSk7XHJcbiAgICBvZmZzZXQgKz0gYWN0aXZlQ291bnQgKiAzICogNDtcclxuXHJcbiAgICBjb25zdCBwb3NBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkocGF5bG9hZC5idWZmZXIsIHBheWxvYWQuYnl0ZU9mZnNldCArIG9mZnNldCwgYWN0aXZlQ291bnQgKiAzKTtcclxuICAgIGNvbnN0IHBvc0NvcHkgPSBuZXcgRmxvYXQzMkFycmF5KHBvc0FycmF5KTtcclxuICAgIG9mZnNldCArPSBhY3RpdmVDb3VudCAqIDMgKiA0O1xyXG5cclxuICAgIGNvbnN0IG1hc2tBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkocGF5bG9hZC5idWZmZXIsIHBheWxvYWQuYnl0ZU9mZnNldCArIG9mZnNldCwgYWN0aXZlQ291bnQpO1xyXG4gICAgY29uc3QgbWFza0NvcHkgPSBuZXcgRmxvYXQzMkFycmF5KG1hc2tBcnJheSk7XHJcblxyXG4gICAgY29uc3QgYW1wbGl0dWRlcyA9IG5ldyBGbG9hdDMyQXJyYXkoYWN0aXZlQ291bnQpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmVDb3VudDsgaSArPSAxKSB7XHJcbiAgICAgIGFtcGxpdHVkZXNbaV0gPSBNYXRoLmFicyhvc2NDb3B5W2kgKiAzXSkgKiAobWFza0NvcHlbaV0gPz8gMSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RvcmUuc2V0RmllbGQoZmllbGRDb3B5LCBkb3duVywgZG93bkgpO1xyXG4gICAgc3RvcmUuc2V0T3NjaWxsYXRvcnMocG9zQ29weSwgYW1wbGl0dWRlcywgTWF0aC5taW4oYWN0aXZlQ291bnQsIE1BWF9TSU1VTEFUSU9OX05PREVTKSk7XHJcbiAgICBzdG9yZS5zZXRUaW1lc3RhbXAoc2ltVGltZSk7XHJcbiAgICB0aGlzLmV2YWx1YXRlU3RhdGVDaGFuZ2UoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhcnRTdGFsZU1vbml0b3IoKSB7XHJcbiAgICBpZiAodGhpcy5zdGFsZVRpbWVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0YWxlVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGJlZm9yZSA9IHVzZVNpbXVsYXRpb25TdG9yZS5nZXRTdGF0ZSgpLmlzU3RhbGU7XHJcbiAgICAgIHVzZVNpbXVsYXRpb25TdG9yZS5nZXRTdGF0ZSgpLmNoZWNrU3RhbGVTdGF0dXMoKTtcclxuICAgICAgY29uc3QgYWZ0ZXIgPSB1c2VTaW11bGF0aW9uU3RvcmUuZ2V0U3RhdGUoKS5pc1N0YWxlO1xyXG4gICAgICBpZiAoYmVmb3JlICE9PSBhZnRlcikge1xyXG4gICAgICAgIHRoaXMuZXZhbHVhdGVTdGF0ZUNoYW5nZSgpO1xyXG4gICAgICB9XHJcbiAgICB9LCAxMDAwKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RvcFN0YWxlTW9uaXRvcigpIHtcclxuICAgIGlmICh0aGlzLnN0YWxlVGltZXIpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnN0YWxlVGltZXIpO1xyXG4gICAgICB0aGlzLnN0YWxlVGltZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBoYW5kbGVUZXh0TWVzc2FnZShyYXc6IHN0cmluZykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UocmF3KTtcclxuICAgICAgY29uc3Qgc3RvcmUgPSB1c2VTaW11bGF0aW9uU3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSBcIlNUQVRVU1wiOiB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2Uuc2ltdWxhdGlvbl9ydW5uaW5nID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICBzdG9yZS5zZXRTaW11bGF0aW9uUnVubmluZyhtZXNzYWdlLnNpbXVsYXRpb25fcnVubmluZyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbGV0IHRvdWNoZWQgPSBmYWxzZTtcclxuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5zaW1fdGltZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBzdG9yZS5zZXRUaW1lc3RhbXAobWVzc2FnZS5zaW1fdGltZSk7XHJcbiAgICAgICAgICAgIHRvdWNoZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICghdG91Y2hlZCkge1xyXG4gICAgICAgICAgICBzdG9yZS51cGRhdGVMYXN0VXBkYXRlVGltZShEYXRlLm5vdygpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuZXZhbHVhdGVTdGF0ZUNoYW5nZSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJQT05HXCI6XHJcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2Uuc2ltdWxhdGlvbl9ydW5uaW5nID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICBzdG9yZS5zZXRTaW11bGF0aW9uUnVubmluZyhtZXNzYWdlLnNpbXVsYXRpb25fcnVubmluZyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzdG9yZS51cGRhdGVMYXN0VXBkYXRlVGltZShEYXRlLm5vdygpKTtcclxuICAgICAgICAgIHRoaXMuZXZhbHVhdGVTdGF0ZUNoYW5nZSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gcGFyc2UgV2ViU29ja2V0IG1lc3NhZ2VcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBldmFsdWF0ZVN0YXRlQ2hhbmdlKCkge1xyXG4gICAgY29uc3QgeyBjb25uZWN0ZWQsIHNpbXVsYXRpb25SdW5uaW5nLCBpc1N0YWxlIH0gPSB1c2VTaW11bGF0aW9uU3RvcmUuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICBpZiAodGhpcy5sYXN0Q29ubmVjdGlvblN0YXRlICE9PSBudWxsICYmIGNvbm5lY3RlZCAhPT0gdGhpcy5sYXN0Q29ubmVjdGlvblN0YXRlKSB7XHJcbiAgICAgIGlmIChjb25uZWN0ZWQpIHtcclxuICAgICAgICBub3RpZnkuc3VjY2VzcygnUmVjb25uZWN0ZWQgdG8gc2ltdWxhdGlvbiBzdHJlYW0uJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbm90aWZ5LmVycm9yKCdDb25uZWN0aW9uIHRvIHNpbXVsYXRpb24gc3RyZWFtIGxvc3QuIEF0dGVtcHRpbmcgdG8gcmVjb25uZWN0Li4uJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5sYXN0U3RhbGVTdGF0ZSAhPT0gbnVsbCAmJiBpc1N0YWxlICE9PSB0aGlzLmxhc3RTdGFsZVN0YXRlKSB7XHJcbiAgICAgIGlmIChpc1N0YWxlICYmIGNvbm5lY3RlZCkge1xyXG4gICAgICAgIG5vdGlmeS53YXJuaW5nKCdTaW11bGF0aW9uIGRhdGEgc3RyZWFtIGlzIHN0YWxlLicpO1xyXG4gICAgICB9IGVsc2UgaWYgKCFpc1N0YWxlKSB7XHJcbiAgICAgICAgbm90aWZ5LnN1Y2Nlc3MoJ1NpbXVsYXRpb24gZGF0YSBzdHJlYW0gcmVzdG9yZWQuJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5sYXN0U2ltdWxhdGlvblJ1bm5pbmcgIT09IG51bGwgJiYgc2ltdWxhdGlvblJ1bm5pbmcgIT09IHRoaXMubGFzdFNpbXVsYXRpb25SdW5uaW5nKSB7XHJcbiAgICAgIGlmIChzaW11bGF0aW9uUnVubmluZykge1xyXG4gICAgICAgIG5vdGlmeS5zdWNjZXNzKCdTaW11bGF0aW9uIHJ1bm5pbmcuJyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGVkICYmICFpc1N0YWxlKSB7XHJcbiAgICAgICAgbm90aWZ5Lndhcm5pbmcoJ1NpbXVsYXRpb24gc3RvcHBlZC4nKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGFzdENvbm5lY3Rpb25TdGF0ZSA9IGNvbm5lY3RlZDtcclxuICAgIHRoaXMubGFzdFNpbXVsYXRpb25SdW5uaW5nID0gc2ltdWxhdGlvblJ1bm5pbmc7XHJcbiAgICB0aGlzLmxhc3RTdGFsZVN0YXRlID0gaXNTdGFsZTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbImRlY29tcHJlc3NTeW5jIiwidXNlU2ltdWxhdGlvblN0b3JlIiwiTUFYX1NJTVVMQVRJT05fTk9ERVMiLCJub3RpZnkiLCJIRUFERVJfVUlOVDMyX0NPVU5UIiwiSEVBREVSX0ZMT0FUX0NPVU5UIiwiSEVBREVSX0JZVEVTIiwiRkxBR19DT01QUkVTU0VEIiwiR01DU1dlYlNvY2tldCIsImNvbm5lY3QiLCJ3cyIsImluaXRpYWwiLCJnZXRTdGF0ZSIsImxhc3RDb25uZWN0aW9uU3RhdGUiLCJjb25uZWN0ZWQiLCJsYXN0U2ltdWxhdGlvblJ1bm5pbmciLCJzaW11bGF0aW9uUnVubmluZyIsImxhc3RTdGFsZVN0YXRlIiwiaXNTdGFsZSIsInNvY2tldCIsIldlYlNvY2tldCIsInVybCIsImJpbmFyeVR5cGUiLCJvbm9wZW4iLCJzdG9yZSIsInNldENvbm5lY3RlZCIsInVwZGF0ZUxhc3RVcGRhdGVUaW1lIiwiRGF0ZSIsIm5vdyIsInN0YXJ0U3RhbGVNb25pdG9yIiwiZXZhbHVhdGVTdGF0ZUNoYW5nZSIsIm9uY2xvc2UiLCJtYXJrU3RhbGUiLCJzdG9wU3RhbGVNb25pdG9yIiwic2NoZWR1bGVSZWNvbm5lY3QiLCJvbmVycm9yIiwiY2xvc2UiLCJvbm1lc3NhZ2UiLCJldmVudCIsImRhdGEiLCJBcnJheUJ1ZmZlciIsImhhbmRsZUJ1ZmZlciIsIkJsb2IiLCJhcnJheUJ1ZmZlciIsInRoZW4iLCJidWZmZXIiLCJoYW5kbGVUZXh0TWVzc2FnZSIsImRpc2Nvbm5lY3QiLCJyZWNvbm5lY3RUaW1lciIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJyZWNvbm5lY3REZWxheSIsImJ5dGVMZW5ndGgiLCJoZWFkZXIiLCJEYXRhVmlldyIsImRvd25XIiwiZ2V0VWludDMyIiwiZG93bkgiLCJhY3RpdmVDb3VudCIsImNhcGFjaXR5IiwiZmxhZ3MiLCJwYXlsb2FkU2l6ZSIsInN0b3JlZFNpemUiLCJydW5uaW5nRmxhZyIsInNpbVRpbWUiLCJnZXRGbG9hdDMyIiwic2V0U2ltdWxhdGlvblJ1bm5pbmciLCJCb29sZWFuIiwic2V0VGltZXN0YW1wIiwicGF5bG9hZCIsIlVpbnQ4QXJyYXkiLCJsZW5ndGgiLCJzbGljZSIsIm9mZnNldCIsImZpZWxkQ291bnQiLCJmaWVsZEFycmF5IiwiRmxvYXQzMkFycmF5IiwiYnl0ZU9mZnNldCIsImZpZWxkQ29weSIsIm9zY0FycmF5Iiwib3NjQ29weSIsInBvc0FycmF5IiwicG9zQ29weSIsIm1hc2tBcnJheSIsIm1hc2tDb3B5IiwiYW1wbGl0dWRlcyIsImkiLCJNYXRoIiwiYWJzIiwic2V0RmllbGQiLCJzZXRPc2NpbGxhdG9ycyIsIm1pbiIsInN0YWxlVGltZXIiLCJzZXRJbnRlcnZhbCIsImJlZm9yZSIsImNoZWNrU3RhbGVTdGF0dXMiLCJhZnRlciIsImNsZWFySW50ZXJ2YWwiLCJyYXciLCJtZXNzYWdlIiwiSlNPTiIsInBhcnNlIiwidHlwZSIsInNpbXVsYXRpb25fcnVubmluZyIsInRvdWNoZWQiLCJzaW1fdGltZSIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJzdWNjZXNzIiwid2FybmluZyIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/websocket.ts\n"));

/***/ })

});