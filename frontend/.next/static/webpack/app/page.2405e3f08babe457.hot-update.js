"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/NodeGraph/NodePresets.ts":
/*!*********************************************!*\
  !*** ./components/NodeGraph/NodePresets.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALGORITHM_IDS: function() { return /* binding */ ALGORITHM_IDS; },\n/* harmony export */   ALGORITHM_NAMES: function() { return /* binding */ ALGORITHM_NAMES; },\n/* harmony export */   NODE_PRESETS: function() { return /* binding */ NODE_PRESETS; }\n/* harmony export */ });\nconst NODE_PRESETS = {\n    system: [\n        {\n            type: \"custom\",\n            name: \"Audio Settings\",\n            description: \"Control audio input/output and routing\",\n            config: {\n                inputEnabled: true,\n                outputEnabled: true,\n                inputGain: 1.0,\n                outputVolume: 0.7,\n                sampleRate: 48000,\n                bufferSize: 256,\n                inputDevice: \"default\",\n                outputDevice: \"default\"\n            },\n            inputs: [\n                {\n                    name: \"audio_in\",\n                    type: \"audio\"\n                },\n                {\n                    name: \"gain_mod\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"audio_out\",\n                    type: \"audio\"\n                },\n                {\n                    name: \"level\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"System\",\n            howItWorks: \"Manages audio I/O for the entire system. Connect audio sources to audio_in, and route audio_out to other processing nodes or outputs. The level output provides real-time audio level monitoring. Gain can be modulated via the gain_mod input.\"\n        },\n        {\n            type: \"custom\",\n            name: \"Sampler Config\",\n            description: \"Configure sampler backend, blocking strategy, and multi-chain parallelism\",\n            config: {\n                backend: \"thrml\",\n                num_chains: -1,\n                blocking_strategy: \"checkerboard\",\n                auto_adapt_strategy: false,\n                clamp_mode: false,\n                export_benchmarks: false\n            },\n            inputs: [\n                {\n                    name: \"enable_clamp\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"chain_count\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"samples_per_sec\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"ess_per_sec\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"autocorr\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"System\",\n            howItWorks: \"Controls the sampler backend configuration for THRML and other computational substrates. Set the backend type (thrml, photonic, neuromorphic, quantum), configure multi-chain parallelism (-1 for auto-detect, 1 for single, >1 for specific count), and choose a blocking strategy (checkerboard, random, stripes, supercell, graph-coloring). Outputs provide real-time performance metrics. Enable clamp_mode for conditional sampling (inpainting, constrained synthesis).\"\n        }\n    ],\n    oscillators: [\n        {\n            type: \"oscillator\",\n            name: \"Chua Oscillator\",\n            description: \"Chaotic oscillator with three equilibrium points\",\n            config: {\n                alpha: 15.6,\n                beta: 28.0,\n                m0: -1.143,\n                m1: -0.714\n            },\n            inputs: [],\n            outputs: [\n                {\n                    name: \"x\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"y\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"z\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"Source\",\n            equations: [\n                \"dx/dt = α(y - x - f(x))\",\n                \"dy/dt = x - y + z\",\n                \"dz/dt = -βy\",\n                \"f(x) = m₁x + 0.5(m₀ - m₁)(|x + 1| - |x - 1|)\"\n            ],\n            howItWorks: \"The Chua circuit is a simple electronic circuit that exhibits classic chaotic behavior. It uses a nonlinear resistor (Chua diode) to create a piecewise-linear function f(x), which drives the system into chaotic oscillations. The three state variables (x, y, z) represent voltages across capacitors and current through an inductor.\"\n        },\n        {\n            type: \"oscillator\",\n            name: \"Lorenz Attractor\",\n            description: \"Classic chaotic system\",\n            config: {\n                sigma: 10.0,\n                rho: 28.0,\n                beta: 8 / 3\n            },\n            inputs: [],\n            outputs: [\n                {\n                    name: \"x\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"y\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"z\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"Source\",\n            equations: [\n                \"dx/dt = σ(y - x)\",\n                \"dy/dt = x(ρ - z) - y\",\n                \"dz/dt = xy - βz\"\n            ],\n            howItWorks: 'Originally derived from atmospheric convection equations, the Lorenz system exhibits sensitive dependence on initial conditions - the \"butterfly effect\". The attractor has a distinctive double-spiral structure. Parameter σ represents the Prandtl number, ρ the Rayleigh number, and β relates to physical dimensions.'\n        },\n        {\n            type: \"oscillator\",\n            name: \"Van der Pol\",\n            description: \"Non-conservative oscillator\",\n            config: {\n                mu: 1.0\n            },\n            inputs: [],\n            outputs: [\n                {\n                    name: \"x\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"dx\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"Source\"\n        }\n    ],\n    algorithms: [\n        // Wave Processing & Dynamics\n        {\n            type: \"algorithm\",\n            name: \"Waveshaper\",\n            description: \"Non-linear waveshaping for any signal\",\n            config: {\n                gain: 2.0,\n                mix: 0.5\n            },\n            inputs: [\n                {\n                    name: \"input\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"output\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"Wave Processing\",\n            equations: [\n                \"y = tanh(gain \\xd7 x)\",\n                \"output = mix \\xd7 y + (1 - mix) \\xd7 x\"\n            ],\n            howItWorks: \"Applies hyperbolic tangent saturation to create harmonic distortion on any waveform. The gain parameter controls the amount of nonlinearity, while mix blends between the processed and dry signals. Works on chaotic oscillators, photonic signals, or any time-varying waveform.\"\n        },\n        {\n            type: \"algorithm\",\n            name: \"Resonator\",\n            description: \"Resonant filter for waveform emphasis\",\n            config: {\n                frequency: 440.0,\n                Q: 10.0\n            },\n            inputs: [\n                {\n                    name: \"input\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"output\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"Wave Processing\",\n            equations: [\n                \"H(ω) = 1 / (1 + jQ(ω/ω₀ - ω₀/ω))\",\n                \"ω₀ = 2πf₀\"\n            ],\n            howItWorks: \"A resonant bandpass filter that emphasizes frequency components near f₀ in any waveform. The Q factor controls the sharpness of the resonance - higher Q creates a narrower, more pronounced peak. At high Q values, the filter can self-oscillate. Works on any oscillator output or signal chain.\"\n        },\n        {\n            type: \"algorithm\",\n            name: \"Hilbert Transform\",\n            description: \"Phase shift and envelope extraction\",\n            config: {\n                order: 64\n            },\n            inputs: [\n                {\n                    name: \"input\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"output\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"envelope\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"Wave Processing\"\n        },\n        {\n            type: \"algorithm\",\n            name: \"Compressor\",\n            description: \"Dynamic range compression for waveforms\",\n            config: {\n                threshold: -20.0,\n                ratio: 4.0,\n                attack: 10.0,\n                release: 100.0,\n                knee: 6.0,\n                makeupGain: 0.0\n            },\n            inputs: [\n                {\n                    name: \"input\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"output\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"gain_reduction\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"Wave Processing\",\n            equations: [\n                \"if input_dB > threshold:\",\n                \"  gain_reduction = (input_dB - threshold) \\xd7 (1 - 1/ratio)\",\n                \"output_dB = input_dB - gain_reduction + makeup_gain\"\n            ],\n            howItWorks: \"Reduces the dynamic range of any waveform by attenuating amplitudes above the threshold. The ratio determines how much compression is applied. Attack and release control response time. Can be used to tame chaotic oscillator peaks, smooth photonic signals, or control any time-varying amplitude.\"\n        },\n        {\n            type: \"algorithm\",\n            name: \"Limiter\",\n            description: \"Hard limiting for waveform control\",\n            config: {\n                threshold: -3.0,\n                attack: 0.5,\n                release: 50.0,\n                ceiling: -0.1\n            },\n            inputs: [\n                {\n                    name: \"input\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"output\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"limiting\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"Wave Processing\",\n            equations: [\n                \"ratio = ∞:1 (or very high, e.g., 100:1)\",\n                \"output = min(input, ceiling)\",\n                \"if input > threshold: apply gain reduction\"\n            ],\n            howItWorks: \"A compressor with an extremely high ratio (approaching ∞:1) that prevents any waveform from exceeding a set ceiling. Very fast attack time ensures no peaks get through. Useful for protecting downstream systems from extreme amplitudes in chaotic or nonlinear dynamics.\"\n        },\n        {\n            type: \"algorithm\",\n            name: \"Expander\",\n            description: \"Dynamic range expansion for waveforms\",\n            config: {\n                threshold: -40.0,\n                ratio: 2.0,\n                attack: 5.0,\n                release: 50.0,\n                knee: 6.0\n            },\n            inputs: [\n                {\n                    name: \"input\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"output\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"gain_change\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"Wave Processing\",\n            equations: [\n                \"if input_dB < threshold:\",\n                \"  gain_increase = (threshold - input_dB) \\xd7 (ratio - 1)\",\n                \"output_dB = input_dB - gain_increase\"\n            ],\n            howItWorks: \"Opposite of compression - increases dynamic range by attenuating signals below the threshold. Can be used to enhance contrast in waveforms, suppress low-amplitude noise, or add emphasis to transient features in any signal type.\"\n        },\n        {\n            type: \"algorithm\",\n            name: \"Gate\",\n            description: \"Threshold gate for waveform control\",\n            config: {\n                threshold: -50.0,\n                attack: 1.0,\n                hold: 10.0,\n                release: 100.0,\n                range: -80.0\n            },\n            inputs: [\n                {\n                    name: \"input\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"sidechain\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"output\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"gate_state\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"Wave Processing\",\n            equations: [\n                \"if input_dB > threshold: gate_open = true\",\n                \"if input_dB < threshold - range: gate_open = false\",\n                \"output = input \\xd7 gate_envelope\"\n            ],\n            howItWorks: \"Silences waveforms below a threshold, effectively removing low-amplitude components. Attack controls gate opening speed, hold keeps it open for minimum time, and release determines closing smoothness. Sidechain input allows external trigger control. Works on any signal type.\"\n        },\n        // Photonic Algorithms\n        {\n            type: \"algorithm\",\n            name: \"Optical Kerr Effect\",\n            description: \"Intensity-dependent refractive index\",\n            config: {\n                n2: 2.6e-20\n            },\n            inputs: [\n                {\n                    name: \"field\",\n                    type: \"complex\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"field\",\n                    type: \"complex\"\n                }\n            ],\n            category: \"Photonic\",\n            equations: [\n                \"n(I) = n₀ + n₂I\",\n                \"φ = n₂I \\xd7 L \\xd7 k₀\",\n                \"E_out = E_in \\xd7 exp(iφ)\"\n            ],\n            howItWorks: \"The Kerr effect causes the refractive index to change with light intensity. This creates a nonlinear phase shift proportional to the optical power. Used in optical switching, self-focusing, and soliton formation. The n₂ coefficient determines the strength of the nonlinearity.\"\n        },\n        {\n            type: \"algorithm\",\n            name: \"Four-Wave Mixing\",\n            description: \"Non-linear optical interaction\",\n            config: {\n                chi3: 1e-22\n            },\n            inputs: [\n                {\n                    name: \"pump\",\n                    type: \"complex\"\n                },\n                {\n                    name: \"signal\",\n                    type: \"complex\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"idler\",\n                    type: \"complex\"\n                }\n            ],\n            category: \"Photonic\"\n        }\n    ],\n    pbit_dynamics: [\n        {\n            type: \"algorithm\",\n            name: \"P-Bit Compressor\",\n            description: \"Probability distribution compression for p-bits\",\n            config: {\n                threshold: 0.5,\n                ratio: 4.0,\n                attack: 5.0,\n                release: 50.0,\n                bias: 0.0\n            },\n            inputs: [\n                {\n                    name: \"p_in\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"modulation\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"p_out\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"compression\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"P-Bit\",\n            equations: [\n                \"if P(1) > threshold:\",\n                \"  compression = (P(1) - threshold) \\xd7 (1 - 1/ratio)\",\n                \"P_out(1) = P(1) - compression + bias\"\n            ],\n            howItWorks: 'Compresses the probability distribution of p-bits, reducing the dynamic range of flip probabilities. When p-bits are too \"hot\" (high flip rate), compression cools them down. Useful for stabilizing THRML networks and preventing runaway thermal fluctuations. The compression output tracks how much the distribution is being squeezed.'\n        },\n        {\n            type: \"algorithm\",\n            name: \"P-Bit Limiter\",\n            description: \"Hard limit on p-bit flip probability\",\n            config: {\n                threshold: 0.8,\n                attack: 1.0,\n                release: 20.0,\n                ceiling: 0.95\n            },\n            inputs: [\n                {\n                    name: \"p_in\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"p_out\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"limiting\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"P-Bit\",\n            equations: [\n                \"P_out(1) = min(P_in(1), ceiling)\",\n                \"P_out(0) = max(P_in(0), 1 - ceiling)\",\n                \"limiting = amount of probability clipped\"\n            ],\n            howItWorks: \"Prevents p-bit probabilities from reaching extreme values (too close to 0 or 1), which can cause numerical instability in THRML systems. Acts as a safety mechanism to maintain healthy thermal noise levels. The ceiling parameter ensures p-bits always retain some uncertainty, preserving their probabilistic nature.\"\n        },\n        {\n            type: \"algorithm\",\n            name: \"P-Bit Expander\",\n            description: \"Expand probability distribution for enhanced fluctuations\",\n            config: {\n                threshold: 0.3,\n                ratio: 2.0,\n                attack: 5.0,\n                release: 50.0\n            },\n            inputs: [\n                {\n                    name: \"p_in\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"p_out\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"expansion\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"P-Bit\",\n            equations: [\n                \"if P(1) < threshold:\",\n                \"  expansion = (threshold - P(1)) \\xd7 (ratio - 1)\",\n                \"P_out(1) = P(1) + expansion\"\n            ],\n            howItWorks: 'Amplifies thermal fluctuations by expanding the probability distribution of low-activity p-bits. Useful for \"heating up\" regions of the THRML network that have become too cold or stuck. Helps escape local minima in energy landscapes by increasing exploration. Can enhance the representational capacity of p-bit arrays.'\n        },\n        {\n            type: \"algorithm\",\n            name: \"P-Bit Gate\",\n            description: \"Threshold-based p-bit activation gate\",\n            config: {\n                threshold: 0.4,\n                attack: 2.0,\n                hold: 10.0,\n                release: 30.0,\n                range: 0.1\n            },\n            inputs: [\n                {\n                    name: \"p_in\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"sidechain\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"p_out\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"gate_state\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"P-Bit\",\n            equations: [\n                \"if P(1) > threshold: gate_open = true\",\n                \"if P(1) < threshold - range: gate_open = false\",\n                \"P_out = P_in \\xd7 gate_envelope\"\n            ],\n            howItWorks: \"Selectively activates or deactivates p-bits based on their flip probability. Below threshold, p-bits are forced into a low-entropy state (close to 0 or 1). Above threshold, they operate normally. Sidechain input allows one set of p-bits to control another, enabling conditional computation and attention mechanisms in THRML networks.\"\n        },\n        {\n            type: \"algorithm\",\n            name: \"P-Bit Threshold\",\n            description: \"Binary thresholding for p-bit states\",\n            config: {\n                threshold: 0.5,\n                hysteresis: 0.1,\n                smoothing: 0.0\n            },\n            inputs: [\n                {\n                    name: \"p_in\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"binary\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"analog\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"P-Bit\",\n            equations: [\n                \"if P(1) > threshold + hysteresis: output = 1\",\n                \"if P(1) < threshold - hysteresis: output = 0\",\n                \"else: maintain previous state\"\n            ],\n            howItWorks: \"Converts probabilistic p-bits into deterministic binary values using a threshold with hysteresis (Schmitt trigger behavior). The hysteresis prevents oscillation around the threshold. Useful for reading out final states from THRML computation or creating discrete control signals. The analog output provides a smoothed version for monitoring.\"\n        }\n    ],\n    thrml: [\n        {\n            type: \"thrml\",\n            name: \"Spin Glass EBM\",\n            description: \"Ising-like energy-based model\",\n            config: {\n                nodes: 64,\n                temperature: 1.0,\n                gibbs_steps: 5\n            },\n            inputs: [\n                {\n                    name: \"bias\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"spins\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"energy\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"THRML\",\n            equations: [\n                \"E(s) = -∑ᵢⱼ Jᵢⱼsᵢsⱼ - ∑ᵢ hᵢsᵢ\",\n                \"P(s) = exp(-E(s)/T) / Z\",\n                \"P(sᵢ = 1) = σ(2∑ⱼ Jᵢⱼsⱼ + hᵢ) / T)\"\n            ],\n            howItWorks: \"An Ising-type energy-based model where binary spins (\\xb11) interact through learned coupling weights J. Uses block Gibbs sampling to generate samples from the Boltzmann distribution. Temperature T controls the stochasticity - low T produces deterministic states, high T produces random exploration. Connect the bias input to modulate p-bit flip probabilities, and use spins/energy outputs to drive visualizers or other nodes.\"\n        },\n        {\n            type: \"thrml\",\n            name: \"Continuous EBM\",\n            description: \"Continuous-valued probabilistic model\",\n            config: {\n                nodes: 64,\n                temperature: 1.0,\n                gibbs_steps: 5\n            },\n            inputs: [\n                {\n                    name: \"input\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"output\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"energy\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"THRML\",\n            equations: [\n                \"E(x) = \\xbdxᵀAx + bᵀx\",\n                \"P(x) = exp(-E(x)/T) / Z\",\n                \"xᵢ ~ N(μᵢ, T)\"\n            ],\n            howItWorks: \"A continuous-valued energy-based model where variables can take any real value. The quadratic energy function creates Gaussian-like distributions. Uses Langevin dynamics or continuous Gibbs sampling to generate samples. Useful for modeling continuous signals and real-valued data. Connect input from signal sources, and use output to modulate other parameters or feed visualizers.\"\n        },\n        {\n            type: \"thrml\",\n            name: \"Heterogeneous Model\",\n            description: \"Mixed discrete and continuous nodes\",\n            config: {\n                spin_nodes: 32,\n                continuous_nodes: 32,\n                temperature: 1.0\n            },\n            inputs: [\n                {\n                    name: \"input\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"spins\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"continuous\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"THRML\",\n            equations: [\n                \"E(s,x) = Eₛ(s) + Eₓ(x) + Eₛₓ(s,x)\",\n                \"P(s,x) = exp(-E(s,x)/T) / Z\",\n                \"Eₛₓ = ∑ᵢⱼ Jᵢⱼsᵢxⱼ\"\n            ],\n            howItWorks: \"Combines binary spins and continuous variables in a single energy-based model. Allows modeling of hybrid systems where some variables are discrete (spins) and others are continuous (real values). The cross-coupling terms Eₛₓ allow spins to influence continuous variables and vice versa. Use input for analog modulation and read spins/continuous outputs for different signal types.\"\n        },\n        {\n            type: \"thrml\",\n            name: \"Categorical EBM\",\n            description: \"Multi-state categorical variables (beyond binary)\",\n            config: {\n                nodes: 64,\n                num_states: 5,\n                temperature: 1.0,\n                gibbs_steps: 5\n            },\n            inputs: [\n                {\n                    name: \"bias\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"observations\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"states\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"class_probs\",\n                    type: \"matrix\"\n                },\n                {\n                    name: \"energy\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"THRML\",\n            howItWorks: \"Like Spin Glass but each variable can take multiple discrete values (e.g., 0,1,2,3,4 instead of just \\xb11). Uses CategoricalGibbsConditional for sampling. Perfect for classification tasks, symbolic reasoning, or modeling discrete multi-state systems like nucleotide sequences or musical notes.\"\n        },\n        {\n            type: \"thrml\",\n            name: \"Block Sampling Config\",\n            description: \"Configure blocking strategies for THRML sampling\",\n            config: {\n                strategy: \"checkerboard\",\n                block_size: 8,\n                n_colors: 2\n            },\n            inputs: [\n                {\n                    name: \"model_state\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"blocked_state\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"effective_sample_rate\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"THRML\",\n            howItWorks: \"Configures block partitioning strategies for parallel Gibbs sampling. Checkerboard creates 2-color alternating blocks. Random partitions nodes randomly. Stripes creates linear partitions. Supercell uses grid-based blocks. Graph-coloring optimally colors interaction graph. Different strategies trade off parallelism vs. mixing speed.\"\n        },\n        {\n            type: \"thrml\",\n            name: \"Conditional Sampler\",\n            description: \"Sample with clamped/observed variables\",\n            config: {\n                clamp_mask: [],\n                clamp_values: []\n            },\n            inputs: [\n                {\n                    name: \"base_state\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"observations\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"conditioned_state\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"log_prob\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"THRML\",\n            howItWorks: \"Samples from conditional distributions by clamping observed variables. Essential for inpainting (fill missing data), constrained generation (force certain outputs), or Bayesian inference (condition on evidence). Clamp_mask specifies which variables to fix, clamp_values sets their values. Log_prob tracks conditional likelihood.\"\n        },\n        {\n            type: \"thrml\",\n            name: \"Multi-Chain Sampler\",\n            description: \"Run multiple independent sampling chains\",\n            config: {\n                n_chains: 8,\n                chain_length: 100,\n                parallel: true\n            },\n            inputs: [\n                {\n                    name: \"model_state\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"chain_samples\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"chain_energies\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"r_hat\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"THRML\",\n            howItWorks: \"Runs multiple MCMC chains in parallel for better exploration and convergence diagnostics. R_hat output measures chain convergence (< 1.1 = good). Exploits GPU parallelism for massive speedup. Essential for reliable inference and detecting multimodal distributions. Each chain starts from different initialization.\"\n        },\n        {\n            type: \"thrml\",\n            name: \"Annealing Scheduler\",\n            description: \"Dynamic temperature scheduling for sampling\",\n            config: {\n                schedule_type: \"linear\",\n                T_start: 10.0,\n                T_end: 0.1,\n                steps: 1000\n            },\n            inputs: [\n                {\n                    name: \"model_state\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"progress\",\n                    type: \"scalar\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"annealed_state\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"current_temp\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"acceptance_rate\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"THRML\",\n            howItWorks: \"Implements simulated annealing or parallel tempering. Start hot (high T) for exploration, cool down (low T) for exploitation. Linear/exponential schedules gradually reduce temperature. Cyclic schedules can escape local minima. Parallel tempering swaps states between temperatures for better mixing and mode discovery.\"\n        },\n        {\n            type: \"thrml\",\n            name: \"Moment Accumulator\",\n            description: \"Track mean, variance, correlations over sampling\",\n            config: {\n                window_size: 1000\n            },\n            inputs: [\n                {\n                    name: \"samples\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"mean\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"variance\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"correlations\",\n                    type: \"matrix\"\n                }\n            ],\n            category: \"THRML\",\n            howItWorks: \"Accumulates first and second moments (mean, variance) and cross-correlations from THRML samples. Essential for moment matching training, convergence monitoring, and understanding learned distributions. Correlations reveal interaction structure. Window_size controls temporal averaging - larger = more stable, smaller = more responsive.\"\n        },\n        {\n            type: \"thrml\",\n            name: \"Weighted Factor\",\n            description: \"Define weighted interaction factors\",\n            config: {\n                factor_type: \"pairwise\",\n                weight: 1.0\n            },\n            inputs: [\n                {\n                    name: \"variables\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"weight_mod\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"energy_contribution\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"factor_graph\",\n                    type: \"custom\"\n                }\n            ],\n            category: \"THRML\",\n            howItWorks: \"Creates weighted factor graph edges between variables. Pairwise factors couple pairs of spins. Higher-order factors create multi-body interactions. Weight_mod input allows dynamic modulation of interaction strength. Energy_contribution shows factor contribution to total energy. Essential for building structured PGMs.\"\n        },\n        {\n            type: \"thrml\",\n            name: \"Higher-Order Interactions\",\n            description: \"Multi-body spin interactions beyond pairwise\",\n            config: {\n                order: 3,\n                coupling_strength: 0.5\n            },\n            inputs: [\n                {\n                    name: \"spin_groups\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"interaction_energy\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"modified_spins\",\n                    type: \"discrete\"\n                }\n            ],\n            category: \"THRML\",\n            howItWorks: \"Implements multi-body interactions (3-spin, 4-spin, etc.) beyond standard pairwise Ising. Required for modeling complex systems like frustrated magnets, error correction codes, or constraint satisfaction problems. Order parameter sets interaction size. More expressive than pairwise but computationally heavier.\"\n        },\n        {\n            type: \"thrml\",\n            name: \"Ising Trainer\",\n            description: \"Train Ising model with moment matching\",\n            config: {\n                learning_rate: 0.01,\n                n_chains: 4,\n                cd_steps: 10\n            },\n            inputs: [\n                {\n                    name: \"data_samples\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"trigger\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"trained_weights\",\n                    type: \"matrix\"\n                },\n                {\n                    name: \"kl_divergence\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"grad_norm\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"THRML\",\n            howItWorks: \"Trains Ising model weights using contrastive divergence to match data moments. N_chains controls parallel chain count for gradient estimation. CD_steps sets number of Gibbs steps per update. KL_divergence tracks training progress. Grad_norm monitors gradient magnitude for learning rate tuning.\"\n        },\n        {\n            type: \"thrml\",\n            name: \"Persistent CD Trainer\",\n            description: \"PCD training with persistent chains\",\n            config: {\n                learning_rate: 0.01,\n                n_persistent_chains: 10,\n                k_steps: 1\n            },\n            inputs: [\n                {\n                    name: \"data_batch\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"train_trigger\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"updated_weights\",\n                    type: \"matrix\"\n                },\n                {\n                    name: \"fantasy_particles\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"reconstruction_error\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"THRML\",\n            howItWorks: \"Like CD-k but maintains persistent fantasy particles that continuously explore model distribution. More stable gradients than CD. Fantasy particles show what the model generates without data influence. Better for deep energy-based models. Each persistent chain maintains its own trajectory across updates.\"\n        },\n        {\n            type: \"thrml\",\n            name: \"Sampling Profiler\",\n            description: \"Measure sampling efficiency and performance\",\n            config: {\n                window_size: 1000,\n                track_autocorr: true,\n                track_ess: true\n            },\n            inputs: [\n                {\n                    name: \"samples\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"samples_per_sec\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"ess_per_sec\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"autocorr_time\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"acceptance_rate\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"THRML\",\n            howItWorks: \"Tracks MCMC performance metrics. ESS (Effective Sample Size) measures effective independent samples accounting for autocorrelation. Samples_per_sec shows raw throughput. Autocorr_time indicates mixing speed - lower is better. Essential for tuning sampler parameters, comparing backends, and production monitoring.\"\n        },\n        {\n            type: \"thrml\",\n            name: \"Graph Coloring Optimizer\",\n            description: \"Find optimal block partitions for sampling\",\n            config: {\n                method: \"graph_coloring\",\n                min_colors: 2,\n                max_colors: 8,\n                recompute_interval: 100\n            },\n            inputs: [\n                {\n                    name: \"interaction_graph\",\n                    type: \"matrix\"\n                },\n                {\n                    name: \"trigger\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"block_assignment\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"n_colors\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"parallelism_factor\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"THRML\",\n            howItWorks: \"Automatically finds optimal block partitions for parallel Gibbs sampling. Graph coloring ensures no connected variables share a block (independence). Metis uses graph partitioning. Spectral uses eigendecomposition. Fewer colors = more parallelism. Dynamically adapts to changing interaction structures via trigger input.\"\n        },\n        {\n            type: \"thrml\",\n            name: \"State Validator\",\n            description: \"Verify and repair THRML block states\",\n            config: {\n                repair_invalid: true,\n                check_interval: 10\n            },\n            inputs: [\n                {\n                    name: \"block_state\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"valid_state\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"is_valid\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"n_violations\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"THRML\",\n            howItWorks: \"Checks block state validity: correct dimensions, value ranges, block structure, NaN/Inf detection. Repairs invalid states if repair_invalid is enabled. Prevents downstream errors from corrupted states. Essential for debugging complex THRML pipelines. Check_interval controls validation frequency for performance.\"\n        }\n    ],\n    visualizers: [\n        {\n            type: \"visualizer\",\n            name: \"Oscilloscope\",\n            description: \"Time-domain waveform display\",\n            config: {\n                buffer_size: 1024,\n                channels: 3,\n                width: 500,\n                height: 350,\n                active: true\n            },\n            inputs: [\n                {\n                    name: \"x\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"y\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"z\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [],\n            category: \"Visualizer\"\n        },\n        {\n            type: \"visualizer\",\n            name: \"Spectrogram\",\n            description: \"Frequency-time analysis\",\n            config: {\n                fft_size: 2048,\n                overlap: 0.75,\n                width: 500,\n                height: 350,\n                active: true\n            },\n            inputs: [\n                {\n                    name: \"signal\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [],\n            category: \"Visualizer\"\n        },\n        {\n            type: \"visualizer\",\n            name: \"Phase Space 3D\",\n            description: \"3D attractor visualization\",\n            config: {\n                width: 500,\n                height: 500,\n                active: true\n            },\n            inputs: [\n                {\n                    name: \"x\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"y\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"z\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [],\n            category: \"Visualizer\"\n        },\n        {\n            type: \"visualizer\",\n            name: \"Energy Graph\",\n            description: \"THRML energy over time\",\n            config: {\n                width: 500,\n                height: 300,\n                active: true\n            },\n            inputs: [\n                {\n                    name: \"energy\",\n                    type: \"scalar\"\n                }\n            ],\n            outputs: [],\n            category: \"Visualizer\"\n        },\n        {\n            type: \"visualizer\",\n            name: \"Spin State Matrix\",\n            description: \"THRML spin visualization\",\n            config: {\n                grid_size: 8,\n                width: 400,\n                height: 400,\n                active: true\n            },\n            inputs: [\n                {\n                    name: \"spins\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [],\n            category: \"Visualizer\"\n        },\n        {\n            type: \"visualizer\",\n            name: \"Correlation Matrix\",\n            description: \"Node correlation heatmap\",\n            config: {\n                grid_size: 8,\n                width: 400,\n                height: 400,\n                active: true\n            },\n            inputs: [\n                {\n                    name: \"correlations\",\n                    type: \"matrix\"\n                }\n            ],\n            outputs: [],\n            category: \"Visualizer\"\n        },\n        {\n            type: \"visualizer\",\n            name: \"Waveform Monitor\",\n            description: \"Single-channel waveform\",\n            config: {\n                buffer_size: 512,\n                width: 450,\n                height: 250,\n                active: true\n            },\n            inputs: [\n                {\n                    name: \"signal\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [],\n            category: \"Visualizer\"\n        },\n        {\n            type: \"visualizer\",\n            name: \"XY Plot\",\n            description: \"Lissajous figure display\",\n            config: {\n                width: 450,\n                height: 450,\n                active: true\n            },\n            inputs: [\n                {\n                    name: \"x\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"y\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [],\n            category: \"Visualizer\"\n        },\n        {\n            type: \"visualizer\",\n            name: \"P-Bit Mapper\",\n            description: \"P-bit state grid visualization\",\n            config: {\n                grid_size: 8,\n                color_scheme: \"red-green\",\n                update_rate: 100,\n                width: 400,\n                height: 400,\n                active: true\n            },\n            inputs: [\n                {\n                    name: \"states\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [],\n            category: \"Visualizer\"\n        }\n    ],\n    ml_nodes: [\n        {\n            type: \"ml\",\n            name: \"MLP Predictor\",\n            description: \"Multi-layer perceptron for prediction\",\n            config: {\n                input_dim: 10,\n                hidden_dims: [\n                    64,\n                    32\n                ],\n                output_dim: 3,\n                model_path: null,\n                learning_rate: 0.001\n            },\n            inputs: [\n                {\n                    name: \"features\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"train_trigger\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"prediction\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"loss\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"ML\",\n            howItWorks: \"Multi-layer perceptron neural network for general-purpose prediction. Feed chaotic time series or any signal array into features input. Predictions flow from oscillator states through hidden layers to output. Use train_trigger to enable/disable online learning. Loss output tracks prediction error for monitoring.\"\n        },\n        {\n            type: \"ml\",\n            name: \"CNN Classifier\",\n            description: \"Convolutional neural network for pattern recognition\",\n            config: {\n                channels: [\n                    16,\n                    32\n                ],\n                kernel_size: 3,\n                output_classes: 5,\n                model_path: null\n            },\n            inputs: [\n                {\n                    name: \"time_series\",\n                    type: \"signal_array\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"class_probs\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"predicted_class\",\n                    type: \"discrete\"\n                }\n            ],\n            category: \"ML\",\n            howItWorks: \"Convolutional neural network designed for time-series pattern recognition. Automatically learns hierarchical features from chaotic oscillator trajectories. Useful for classifying attractor regimes, detecting bifurcations, or recognizing emergent patterns in THRML networks. Outputs class probabilities and most likely class.\"\n        },\n        {\n            type: \"ml\",\n            name: \"Transformer Encoder\",\n            description: \"BERT-style transformer for sequence processing\",\n            config: {\n                model_name: \"bert-base\",\n                hidden_size: 768,\n                num_heads: 12,\n                num_layers: 6\n            },\n            inputs: [\n                {\n                    name: \"sequence\",\n                    type: \"signal_array\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"embeddings\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"attention_weights\",\n                    type: \"matrix\"\n                }\n            ],\n            category: \"ML\",\n            howItWorks: \"Transformer encoder with multi-head self-attention for processing sequential data from oscillators or THRML samples. Captures long-range dependencies in chaotic dynamics. Can learn temporal structure in music, detect patterns in neural activity, or process any time-series data. Attention weights reveal which time steps influence predictions.\"\n        },\n        {\n            type: \"ml\",\n            name: \"Diffusion Generator\",\n            description: \"DDPM/DDIM diffusion model for generation\",\n            config: {\n                timesteps: 1000,\n                data_shape: [\n                    1,\n                    256\n                ],\n                beta_schedule: \"cosine\",\n                num_inference_steps: 50\n            },\n            inputs: [\n                {\n                    name: \"noise\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"guidance\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"generated\",\n                    type: \"signal_array\"\n                }\n            ],\n            category: \"ML\",\n            howItWorks: \"Diffusion probabilistic model for generating novel patterns. Starts from random noise and gradually denoises to create structured outputs. Guidance input allows chaos or THRML energy to steer generation toward specific regions of the learned distribution. Useful for creative synthesis, pattern discovery, or data augmentation.\"\n        },\n        {\n            type: \"ml\",\n            name: \"GAN Generator\",\n            description: \"Generative adversarial network\",\n            config: {\n                latent_dim: 100,\n                output_length: 256,\n                architecture: \"dcgan\"\n            },\n            inputs: [\n                {\n                    name: \"latent\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"chaos_noise\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"generated\",\n                    type: \"signal_array\"\n                }\n            ],\n            category: \"ML\",\n            howItWorks: \"Generative adversarial network trained to produce realistic patterns. Latent input controls generation style. Chaos_noise input can use chaotic oscillators as a unique noise source, creating diverse outputs that traditional GANs cannot produce. Excellent for sprite generation, world creation, or novel pattern synthesis.\"\n        },\n        {\n            type: \"ml\",\n            name: \"RL Controller\",\n            description: \"PPO/SAC reinforcement learning agent\",\n            config: {\n                state_dim: 3,\n                action_dim: 1,\n                algorithm: \"ppo\",\n                learning_rate: 0.0003,\n                gamma: 0.99\n            },\n            inputs: [\n                {\n                    name: \"state\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"reward\",\n                    type: \"scalar\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"action\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"value\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"ML\",\n            howItWorks: \"Reinforcement learning agent that learns to control systems through trial and error. Feed oscillator states as observations, define rewards (e.g., energy minimization, stability), and the agent learns optimal control policies. Output actions modulate oscillator parameters. Value estimates track expected future rewards.\"\n        },\n        {\n            type: \"ml\",\n            name: \"Autoencoder\",\n            description: \"Dimensionality reduction and compression\",\n            config: {\n                input_dim: 100,\n                latent_dim: 10,\n                architecture: \"vanilla\"\n            },\n            inputs: [\n                {\n                    name: \"input\",\n                    type: \"signal_array\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"latent\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"reconstructed\",\n                    type: \"signal_array\"\n                }\n            ],\n            category: \"ML\",\n            howItWorks: \"Autoencoder compresses high-dimensional data into low-dimensional latent representations. Useful for visualizing attractor structures, finding compact representations of THRML states, or preprocessing for other ML models. Latent output reveals intrinsic dimensionality of chaotic dynamics.\"\n        }\n    ],\n    analysis_nodes: [\n        {\n            type: \"analysis\",\n            name: \"FFT Analyzer\",\n            description: \"Fast Fourier Transform spectral analysis\",\n            config: {\n                size: 2048,\n                window: \"hann\",\n                overlap: 0.5\n            },\n            inputs: [\n                {\n                    name: \"signal\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"magnitude\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"phase\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"peak_freq\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"spectral_centroid\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"Analysis\",\n            howItWorks: \"Transforms time-domain signals to frequency domain using Fast Fourier Transform. Reveals harmonic structure, dominant frequencies, and spectral content of oscillator outputs or audio signals. Peak frequency tracks the strongest spectral component. Spectral centroid indicates brightness or center of mass of the spectrum.\"\n        },\n        {\n            type: \"analysis\",\n            name: \"Pattern Recognizer\",\n            description: \"Detect repeating patterns in time series\",\n            config: {\n                window_size: 100,\n                threshold: 0.8,\n                num_patterns: 10\n            },\n            inputs: [\n                {\n                    name: \"signal\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"patterns\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"confidence\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"period\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"Analysis\",\n            howItWorks: \"Uses autocorrelation and template matching to identify repeating patterns in chaotic or periodic signals. Outputs detected pattern IDs, confidence scores, and estimated periods. Useful for finding quasi-periodic orbits, detecting bifurcations, or identifying musical motifs in generated audio.\"\n        },\n        {\n            type: \"analysis\",\n            name: \"Lyapunov Calculator\",\n            description: \"Compute largest Lyapunov exponent\",\n            config: {\n                window: 1000,\n                neighbors: 10,\n                embedding_dim: 3\n            },\n            inputs: [\n                {\n                    name: \"trajectory\",\n                    type: \"signal_array\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"lyapunov\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"is_chaotic\",\n                    type: \"discrete\"\n                }\n            ],\n            category: \"Analysis\",\n            howItWorks: \"Calculates the largest Lyapunov exponent to quantify chaos. Positive exponents indicate chaotic dynamics (sensitive dependence on initial conditions), zero indicates marginal stability, negative indicates convergence. Is_chaotic output provides binary classification. Essential for analyzing dynamical regime transitions.\"\n        },\n        {\n            type: \"analysis\",\n            name: \"Attractor Analyzer\",\n            description: \"Characterize strange attractors\",\n            config: {\n                embedding_dim: 3,\n                time_delay: 10\n            },\n            inputs: [\n                {\n                    name: \"time_series\",\n                    type: \"signal_array\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"correlation_dim\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"entropy\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"Analysis\",\n            howItWorks: \"Reconstructs phase space using time-delay embedding and estimates attractor properties. Correlation dimension reveals fractal structure. Entropy quantifies unpredictability. Helps classify oscillator regimes and detect transitions between periodic, quasi-periodic, and chaotic behavior.\"\n        },\n        {\n            type: \"analysis\",\n            name: \"Energy Surface Scanner\",\n            description: \"Map and analyze THRML energy landscape\",\n            config: {\n                scan_resolution: 32,\n                num_samples: 1000,\n                compute_barriers: true\n            },\n            inputs: [\n                {\n                    name: \"model_state\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"weights\",\n                    type: \"matrix\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"energy_histogram\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"min_energy\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"max_energy\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"energy_barriers\",\n                    type: \"signal_array\"\n                }\n            ],\n            category: \"Analysis\",\n            howItWorks: \"Samples the energy landscape to find minima, barriers, and metastable states. Useful for understanding model capacity, detecting mode collapse, or finding ground states. Energy barriers indicate difficulty of mixing between modes. Scan_resolution controls granularity of landscape mapping.\"\n        },\n        {\n            type: \"analysis\",\n            name: \"Convergence Detector\",\n            description: \"Estimate MCMC mixing and convergence time\",\n            config: {\n                check_interval: 100,\n                max_lag: 50,\n                threshold: 0.01\n            },\n            inputs: [\n                {\n                    name: \"sample_stream\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"mixing_time\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"converged\",\n                    type: \"discrete\"\n                },\n                {\n                    name: \"autocorr_func\",\n                    type: \"signal_array\"\n                }\n            ],\n            category: \"Analysis\",\n            howItWorks: \"Estimates how long it takes for the chain to forget initial conditions. Tracks autocorrelation function decay. Signals convergence when autocorrelation drops below threshold. Critical for knowing when to trust your samples. Max_lag sets how far back to look for correlations.\"\n        }\n    ],\n    control_nodes: [\n        {\n            type: \"control\",\n            name: \"Parameter Optimizer\",\n            description: \"Gradient-based parameter optimization\",\n            config: {\n                learning_rate: 0.01,\n                target_metric: \"energy\",\n                optimizer: \"adam\",\n                momentum: 0.9\n            },\n            inputs: [\n                {\n                    name: \"current_value\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"target_value\",\n                    type: \"scalar\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"control_signal\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"error\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"Control\",\n            howItWorks: \"Gradient descent controller that adjusts parameters to minimize error between current and target values. Can optimize THRML energy, stabilize oscillators, or tune any continuous parameter. Supports multiple optimizers (SGD, Adam, RMSprop). Error output tracks convergence progress.\"\n        },\n        {\n            type: \"control\",\n            name: \"Chaos Controller\",\n            description: \"Control and stabilize chaotic dynamics\",\n            config: {\n                method: \"pyragas\",\n                strength: 0.1,\n                delay: 100\n            },\n            inputs: [\n                {\n                    name: \"state\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"target\",\n                    type: \"signal_array\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"control\",\n                    type: \"signal_array\"\n                }\n            ],\n            category: \"Control\",\n            howItWorks: \"Implements Pyragas or OGY chaos control methods. Stabilizes unstable periodic orbits embedded in chaotic attractors using small perturbations. Delay parameter sets the feedback time scale. Useful for taming chaos when needed or navigating between different dynamical regimes.\"\n        },\n        {\n            type: \"control\",\n            name: \"PID Controller\",\n            description: \"Proportional-Integral-Derivative feedback control\",\n            config: {\n                Kp: 1.0,\n                Ki: 0.1,\n                Kd: 0.01,\n                setpoint: 0.0\n            },\n            inputs: [\n                {\n                    name: \"measurement\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"control\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"error\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"Control\",\n            howItWorks: \"Classic PID controller for maintaining a desired setpoint. Proportional term responds to current error, integral term eliminates steady-state error, derivative term reduces overshoot. Tune Kp, Ki, Kd for stability. Applicable to oscillator control, THRML temperature regulation, or any feedback system.\"\n        },\n        {\n            type: \"control\",\n            name: \"Adaptive Gibbs Steps\",\n            description: \"Dynamically adjust number of sampling steps\",\n            config: {\n                min_steps: 1,\n                max_steps: 50,\n                target_acceptance: 0.5,\n                adaptation_rate: 0.1\n            },\n            inputs: [\n                {\n                    name: \"current_acceptance\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"error_signal\",\n                    type: \"scalar\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"n_steps\",\n                    type: \"scalar\"\n                },\n                {\n                    name: \"step_size\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"Control\",\n            howItWorks: \"Automatically tunes sampling steps based on acceptance rate and error metrics. More steps when acceptance is low (poor mixing). Fewer steps when acceptance is good (efficient sampling). Saves computation while maintaining quality. Adaptation_rate controls how quickly the controller responds to changes.\"\n        }\n    ],\n    generator_nodes: [\n        {\n            type: \"generator\",\n            name: \"Noise Generator\",\n            description: \"Generate various types of noise\",\n            config: {\n                type: \"white\",\n                amplitude: 1.0,\n                seed: 42\n            },\n            inputs: [\n                {\n                    name: \"amplitude_mod\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"noise\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"Generator\",\n            howItWorks: \"Generates noise signals: white (flat spectrum), pink (1/f), brown (1/f\\xb2), or perlin (smooth). Amplitude modulation input allows dynamic control. Useful for testing systems, adding stochasticity, or as input to generative models. Seed ensures reproducibility.\"\n        },\n        {\n            type: \"generator\",\n            name: \"Pattern Generator\",\n            description: \"Generate test signals and patterns\",\n            config: {\n                pattern: \"sine\",\n                frequency: 440,\n                amplitude: 1.0,\n                phase: 0.0\n            },\n            inputs: [\n                {\n                    name: \"freq_mod\",\n                    type: \"signal\"\n                },\n                {\n                    name: \"amp_mod\",\n                    type: \"signal\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"pattern\",\n                    type: \"signal\"\n                }\n            ],\n            category: \"Generator\",\n            howItWorks: \"Generates standard test signals: sine, square, triangle, sawtooth, or custom patterns. Frequency and amplitude can be modulated in real-time. Essential for testing, calibration, or as driving forces for oscillators. Phase parameter sets initial offset.\"\n        },\n        {\n            type: \"generator\",\n            name: \"Sequence Generator\",\n            description: \"Generate structured sequences\",\n            config: {\n                length: 100,\n                pattern_type: \"arithmetic\",\n                start: 0,\n                step: 1\n            },\n            inputs: [\n                {\n                    name: \"trigger\",\n                    type: \"discrete\"\n                }\n            ],\n            outputs: [\n                {\n                    name: \"sequence\",\n                    type: \"signal_array\"\n                },\n                {\n                    name: \"position\",\n                    type: \"scalar\"\n                }\n            ],\n            category: \"Generator\",\n            howItWorks: \"Creates structured number sequences: arithmetic progressions, geometric series, fibonacci, or custom patterns. Trigger input restarts sequence. Useful for generating test data, creating rhythmic patterns, or providing controlled inputs to ML models or oscillators.\"\n        }\n    ]\n};\nconst ALGORITHM_IDS = {\n    // Audio/Signal Processing (0-6)\n    PASSTHROUGH: 0,\n    TANH_SATURATE: 1,\n    SOFT_CLIP: 2,\n    FOLD: 3,\n    RING_MOD: 4,\n    DELAY: 5,\n    ALLPASS: 6,\n    // Extended Audio (7-13)\n    RESONATOR: 7,\n    HILBERT: 8,\n    RECTIFIER: 9,\n    QUANTIZER: 10,\n    SLEW_LIMITER: 11,\n    CROSS_MOD: 12,\n    BIPOLAR_FOLD: 13,\n    // Photonic (14-20)\n    OPTICAL_KERR: 14,\n    ELECTRO_OPTIC: 15,\n    OPTICAL_SWITCH: 16,\n    FOUR_WAVE_MIXING: 17,\n    RAMAN_AMPLIFIER: 18,\n    SATURATION: 19,\n    OPTICAL_GAIN: 20\n};\nconst ALGORITHM_NAMES = {\n    [ALGORITHM_IDS.PASSTHROUGH]: \"Passthrough\",\n    [ALGORITHM_IDS.TANH_SATURATE]: \"Tanh Saturate\",\n    [ALGORITHM_IDS.SOFT_CLIP]: \"Soft Clip\",\n    [ALGORITHM_IDS.FOLD]: \"Fold\",\n    [ALGORITHM_IDS.RING_MOD]: \"Ring Modulator\",\n    [ALGORITHM_IDS.DELAY]: \"Delay\",\n    [ALGORITHM_IDS.ALLPASS]: \"Allpass Filter\",\n    [ALGORITHM_IDS.RESONATOR]: \"Resonator\",\n    [ALGORITHM_IDS.HILBERT]: \"Hilbert Transform\",\n    [ALGORITHM_IDS.RECTIFIER]: \"Rectifier\",\n    [ALGORITHM_IDS.QUANTIZER]: \"Quantizer\",\n    [ALGORITHM_IDS.SLEW_LIMITER]: \"Slew Limiter\",\n    [ALGORITHM_IDS.CROSS_MOD]: \"Cross Modulator\",\n    [ALGORITHM_IDS.BIPOLAR_FOLD]: \"Bipolar Fold\",\n    [ALGORITHM_IDS.OPTICAL_KERR]: \"Optical Kerr Effect\",\n    [ALGORITHM_IDS.ELECTRO_OPTIC]: \"Electro-Optic Modulator\",\n    [ALGORITHM_IDS.OPTICAL_SWITCH]: \"Optical Switch\",\n    [ALGORITHM_IDS.FOUR_WAVE_MIXING]: \"Four-Wave Mixing\",\n    [ALGORITHM_IDS.RAMAN_AMPLIFIER]: \"Raman Amplifier\",\n    [ALGORITHM_IDS.SATURATION]: \"Saturation\",\n    [ALGORITHM_IDS.OPTICAL_GAIN]: \"Optical Gain\"\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvTm9kZUdyYXBoL05vZGVQcmVzZXRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQVlPLE1BQU1BLGVBQTZDO0lBQ3hEQyxRQUFRO1FBQ047WUFDRUMsTUFBTTtZQUNOQyxNQUFNO1lBQ05DLGFBQWE7WUFDYkMsUUFBUTtnQkFDTkMsY0FBYztnQkFDZEMsZUFBZTtnQkFDZkMsV0FBVztnQkFDWEMsY0FBYztnQkFDZEMsWUFBWTtnQkFDWkMsWUFBWTtnQkFDWkMsYUFBYTtnQkFDYkMsY0FBYztZQUNoQjtZQUNBQyxRQUFRO2dCQUNOO29CQUFFWCxNQUFNO29CQUFZRCxNQUFNO2dCQUFRO2dCQUNsQztvQkFBRUMsTUFBTTtvQkFBWUQsTUFBTTtnQkFBUzthQUNwQztZQUNEYSxTQUFTO2dCQUNQO29CQUFFWixNQUFNO29CQUFhRCxNQUFNO2dCQUFRO2dCQUNuQztvQkFBRUMsTUFBTTtvQkFBU0QsTUFBTTtnQkFBUzthQUNqQztZQUNEYyxVQUFVO1lBQ1ZDLFlBQVk7UUFDZDtRQUNBO1lBQ0VmLE1BQU07WUFDTkMsTUFBTTtZQUNOQyxhQUFhO1lBQ2JDLFFBQVE7Z0JBQ05hLFNBQVM7Z0JBQ1RDLFlBQVksQ0FBQztnQkFDYkMsbUJBQW1CO2dCQUNuQkMscUJBQXFCO2dCQUNyQkMsWUFBWTtnQkFDWkMsbUJBQW1CO1lBQ3JCO1lBQ0FULFFBQVE7Z0JBQ047b0JBQUVYLE1BQU07b0JBQWdCRCxNQUFNO2dCQUFXO2dCQUN6QztvQkFBRUMsTUFBTTtvQkFBZUQsTUFBTTtnQkFBUzthQUN2QztZQUNEYSxTQUFTO2dCQUNQO29CQUFFWixNQUFNO29CQUFtQkQsTUFBTTtnQkFBUztnQkFDMUM7b0JBQUVDLE1BQU07b0JBQWVELE1BQU07Z0JBQVM7Z0JBQ3RDO29CQUFFQyxNQUFNO29CQUFZRCxNQUFNO2dCQUFTO2FBQ3BDO1lBQ0RjLFVBQVU7WUFDVkMsWUFBWTtRQUNkO0tBQ0Q7SUFDRE8sYUFBYTtRQUNYO1lBQ0V0QixN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cGFjazovL19OX0UvLi9jb21wb25lbnRzL05vZGVHcmFwaC9Ob2RlUHJlc2V0cy50cz9hY2EwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgTm9kZVByZXNldCB7XHJcbiAgdHlwZTogJ29zY2lsbGF0b3InIHwgJ2FsZ29yaXRobScgfCAndGhybWwnIHwgJ3Zpc3VhbGl6ZXInIHwgJ2N1c3RvbScgfCAnbWwnIHwgJ2FuYWx5c2lzJyB8ICdjb250cm9sJyB8ICdnZW5lcmF0b3InO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG4gIGNvbmZpZzogUmVjb3JkPHN0cmluZywgYW55PjtcclxuICBpbnB1dHM6IEFycmF5PHsgbmFtZTogc3RyaW5nOyB0eXBlOiBzdHJpbmcgfT47XHJcbiAgb3V0cHV0czogQXJyYXk8eyBuYW1lOiBzdHJpbmc7IHR5cGU6IHN0cmluZyB9PjtcclxuICBjYXRlZ29yeTogc3RyaW5nO1xyXG4gIGVxdWF0aW9ucz86IHN0cmluZ1tdO1xyXG4gIGhvd0l0V29ya3M/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBOT0RFX1BSRVNFVFM6IFJlY29yZDxzdHJpbmcsIE5vZGVQcmVzZXRbXT4gPSB7XHJcbiAgc3lzdGVtOiBbXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdjdXN0b20nLFxyXG4gICAgICBuYW1lOiAnQXVkaW8gU2V0dGluZ3MnLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ0NvbnRyb2wgYXVkaW8gaW5wdXQvb3V0cHV0IGFuZCByb3V0aW5nJyxcclxuICAgICAgY29uZmlnOiB7XHJcbiAgICAgICAgaW5wdXRFbmFibGVkOiB0cnVlLFxyXG4gICAgICAgIG91dHB1dEVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgaW5wdXRHYWluOiAxLjAsXHJcbiAgICAgICAgb3V0cHV0Vm9sdW1lOiAwLjcsXHJcbiAgICAgICAgc2FtcGxlUmF0ZTogNDgwMDAsXHJcbiAgICAgICAgYnVmZmVyU2l6ZTogMjU2LFxyXG4gICAgICAgIGlucHV0RGV2aWNlOiAnZGVmYXVsdCcsXHJcbiAgICAgICAgb3V0cHV0RGV2aWNlOiAnZGVmYXVsdCdcclxuICAgICAgfSxcclxuICAgICAgaW5wdXRzOiBbXHJcbiAgICAgICAgeyBuYW1lOiAnYXVkaW9faW4nLCB0eXBlOiAnYXVkaW8nIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnZ2Fpbl9tb2QnLCB0eXBlOiAnc2lnbmFsJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdhdWRpb19vdXQnLCB0eXBlOiAnYXVkaW8nIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnbGV2ZWwnLCB0eXBlOiAnc2lnbmFsJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIGNhdGVnb3J5OiAnU3lzdGVtJyxcclxuICAgICAgaG93SXRXb3JrczogJ01hbmFnZXMgYXVkaW8gSS9PIGZvciB0aGUgZW50aXJlIHN5c3RlbS4gQ29ubmVjdCBhdWRpbyBzb3VyY2VzIHRvIGF1ZGlvX2luLCBhbmQgcm91dGUgYXVkaW9fb3V0IHRvIG90aGVyIHByb2Nlc3Npbmcgbm9kZXMgb3Igb3V0cHV0cy4gVGhlIGxldmVsIG91dHB1dCBwcm92aWRlcyByZWFsLXRpbWUgYXVkaW8gbGV2ZWwgbW9uaXRvcmluZy4gR2FpbiBjYW4gYmUgbW9kdWxhdGVkIHZpYSB0aGUgZ2Fpbl9tb2QgaW5wdXQuJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2N1c3RvbScsXHJcbiAgICAgIG5hbWU6ICdTYW1wbGVyIENvbmZpZycsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ29uZmlndXJlIHNhbXBsZXIgYmFja2VuZCwgYmxvY2tpbmcgc3RyYXRlZ3ksIGFuZCBtdWx0aS1jaGFpbiBwYXJhbGxlbGlzbScsXHJcbiAgICAgIGNvbmZpZzoge1xyXG4gICAgICAgIGJhY2tlbmQ6ICd0aHJtbCcsXHJcbiAgICAgICAgbnVtX2NoYWluczogLTEsXHJcbiAgICAgICAgYmxvY2tpbmdfc3RyYXRlZ3k6ICdjaGVja2VyYm9hcmQnLFxyXG4gICAgICAgIGF1dG9fYWRhcHRfc3RyYXRlZ3k6IGZhbHNlLFxyXG4gICAgICAgIGNsYW1wX21vZGU6IGZhbHNlLFxyXG4gICAgICAgIGV4cG9ydF9iZW5jaG1hcmtzOiBmYWxzZVxyXG4gICAgICB9LFxyXG4gICAgICBpbnB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdlbmFibGVfY2xhbXAnLCB0eXBlOiAnZGlzY3JldGUnIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnY2hhaW5fY291bnQnLCB0eXBlOiAnc2lnbmFsJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdzYW1wbGVzX3Blcl9zZWMnLCB0eXBlOiAnc2lnbmFsJyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ2Vzc19wZXJfc2VjJywgdHlwZTogJ3NpZ25hbCcgfSxcclxuICAgICAgICB7IG5hbWU6ICdhdXRvY29ycicsIHR5cGU6ICdzaWduYWwnIH1cclxuICAgICAgXSxcclxuICAgICAgY2F0ZWdvcnk6ICdTeXN0ZW0nLFxyXG4gICAgICBob3dJdFdvcmtzOiAnQ29udHJvbHMgdGhlIHNhbXBsZXIgYmFja2VuZCBjb25maWd1cmF0aW9uIGZvciBUSFJNTCBhbmQgb3RoZXIgY29tcHV0YXRpb25hbCBzdWJzdHJhdGVzLiBTZXQgdGhlIGJhY2tlbmQgdHlwZSAodGhybWwsIHBob3RvbmljLCBuZXVyb21vcnBoaWMsIHF1YW50dW0pLCBjb25maWd1cmUgbXVsdGktY2hhaW4gcGFyYWxsZWxpc20gKC0xIGZvciBhdXRvLWRldGVjdCwgMSBmb3Igc2luZ2xlLCA+MSBmb3Igc3BlY2lmaWMgY291bnQpLCBhbmQgY2hvb3NlIGEgYmxvY2tpbmcgc3RyYXRlZ3kgKGNoZWNrZXJib2FyZCwgcmFuZG9tLCBzdHJpcGVzLCBzdXBlcmNlbGwsIGdyYXBoLWNvbG9yaW5nKS4gT3V0cHV0cyBwcm92aWRlIHJlYWwtdGltZSBwZXJmb3JtYW5jZSBtZXRyaWNzLiBFbmFibGUgY2xhbXBfbW9kZSBmb3IgY29uZGl0aW9uYWwgc2FtcGxpbmcgKGlucGFpbnRpbmcsIGNvbnN0cmFpbmVkIHN5bnRoZXNpcykuJ1xyXG4gICAgfVxyXG4gIF0sXHJcbiAgb3NjaWxsYXRvcnM6IFtcclxuICAgIHtcclxuICAgICAgdHlwZTogJ29zY2lsbGF0b3InLFxyXG4gICAgICBuYW1lOiAnQ2h1YSBPc2NpbGxhdG9yJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdDaGFvdGljIG9zY2lsbGF0b3Igd2l0aCB0aHJlZSBlcXVpbGlicml1bSBwb2ludHMnLFxyXG4gICAgICBjb25maWc6IHsgYWxwaGE6IDE1LjYsIGJldGE6IDI4LjAsIG0wOiAtMS4xNDMsIG0xOiAtMC43MTQgfSxcclxuICAgICAgaW5wdXRzOiBbXSxcclxuICAgICAgb3V0cHV0czogW3sgbmFtZTogJ3gnLCB0eXBlOiAnc2lnbmFsJyB9LCB7IG5hbWU6ICd5JywgdHlwZTogJ3NpZ25hbCcgfSwgeyBuYW1lOiAneicsIHR5cGU6ICdzaWduYWwnIH1dLFxyXG4gICAgICBjYXRlZ29yeTogJ1NvdXJjZScsXHJcbiAgICAgIGVxdWF0aW9uczogW1xyXG4gICAgICAgICdkeC9kdCA9IM6xKHkgLSB4IC0gZih4KSknLFxyXG4gICAgICAgICdkeS9kdCA9IHggLSB5ICsgeicsXHJcbiAgICAgICAgJ2R6L2R0ID0gLc6yeScsXHJcbiAgICAgICAgJ2YoeCkgPSBt4oKBeCArIDAuNSht4oKAIC0gbeKCgSkofHggKyAxfCAtIHx4IC0gMXwpJ1xyXG4gICAgICBdLFxyXG4gICAgICBob3dJdFdvcmtzOiAnVGhlIENodWEgY2lyY3VpdCBpcyBhIHNpbXBsZSBlbGVjdHJvbmljIGNpcmN1aXQgdGhhdCBleGhpYml0cyBjbGFzc2ljIGNoYW90aWMgYmVoYXZpb3IuIEl0IHVzZXMgYSBub25saW5lYXIgcmVzaXN0b3IgKENodWEgZGlvZGUpIHRvIGNyZWF0ZSBhIHBpZWNld2lzZS1saW5lYXIgZnVuY3Rpb24gZih4KSwgd2hpY2ggZHJpdmVzIHRoZSBzeXN0ZW0gaW50byBjaGFvdGljIG9zY2lsbGF0aW9ucy4gVGhlIHRocmVlIHN0YXRlIHZhcmlhYmxlcyAoeCwgeSwgeikgcmVwcmVzZW50IHZvbHRhZ2VzIGFjcm9zcyBjYXBhY2l0b3JzIGFuZCBjdXJyZW50IHRocm91Z2ggYW4gaW5kdWN0b3IuJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ29zY2lsbGF0b3InLFxyXG4gICAgICBuYW1lOiAnTG9yZW56IEF0dHJhY3RvcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ2xhc3NpYyBjaGFvdGljIHN5c3RlbScsXHJcbiAgICAgIGNvbmZpZzogeyBzaWdtYTogMTAuMCwgcmhvOiAyOC4wLCBiZXRhOiA4IC8gMyB9LFxyXG4gICAgICBpbnB1dHM6IFtdLFxyXG4gICAgICBvdXRwdXRzOiBbeyBuYW1lOiAneCcsIHR5cGU6ICdzaWduYWwnIH0sIHsgbmFtZTogJ3knLCB0eXBlOiAnc2lnbmFsJyB9LCB7IG5hbWU6ICd6JywgdHlwZTogJ3NpZ25hbCcgfV0sXHJcbiAgICAgIGNhdGVnb3J5OiAnU291cmNlJyxcclxuICAgICAgZXF1YXRpb25zOiBbXHJcbiAgICAgICAgJ2R4L2R0ID0gz4MoeSAtIHgpJyxcclxuICAgICAgICAnZHkvZHQgPSB4KM+BIC0geikgLSB5JyxcclxuICAgICAgICAnZHovZHQgPSB4eSAtIM6yeidcclxuICAgICAgXSxcclxuICAgICAgaG93SXRXb3JrczogJ09yaWdpbmFsbHkgZGVyaXZlZCBmcm9tIGF0bW9zcGhlcmljIGNvbnZlY3Rpb24gZXF1YXRpb25zLCB0aGUgTG9yZW56IHN5c3RlbSBleGhpYml0cyBzZW5zaXRpdmUgZGVwZW5kZW5jZSBvbiBpbml0aWFsIGNvbmRpdGlvbnMgLSB0aGUgXCJidXR0ZXJmbHkgZWZmZWN0XCIuIFRoZSBhdHRyYWN0b3IgaGFzIGEgZGlzdGluY3RpdmUgZG91YmxlLXNwaXJhbCBzdHJ1Y3R1cmUuIFBhcmFtZXRlciDPgyByZXByZXNlbnRzIHRoZSBQcmFuZHRsIG51bWJlciwgz4EgdGhlIFJheWxlaWdoIG51bWJlciwgYW5kIM6yIHJlbGF0ZXMgdG8gcGh5c2ljYWwgZGltZW5zaW9ucy4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnb3NjaWxsYXRvcicsXHJcbiAgICAgIG5hbWU6ICdWYW4gZGVyIFBvbCcsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnTm9uLWNvbnNlcnZhdGl2ZSBvc2NpbGxhdG9yJyxcclxuICAgICAgY29uZmlnOiB7IG11OiAxLjAgfSxcclxuICAgICAgaW5wdXRzOiBbXSxcclxuICAgICAgb3V0cHV0czogW3sgbmFtZTogJ3gnLCB0eXBlOiAnc2lnbmFsJyB9LCB7IG5hbWU6ICdkeCcsIHR5cGU6ICdzaWduYWwnIH1dLFxyXG4gICAgICBjYXRlZ29yeTogJ1NvdXJjZScsXHJcbiAgICB9LFxyXG4gIF0sXHJcblxyXG4gIGFsZ29yaXRobXM6IFtcclxuICAgIC8vIFdhdmUgUHJvY2Vzc2luZyAmIER5bmFtaWNzXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdhbGdvcml0aG0nLFxyXG4gICAgICBuYW1lOiAnV2F2ZXNoYXBlcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnTm9uLWxpbmVhciB3YXZlc2hhcGluZyBmb3IgYW55IHNpZ25hbCcsXHJcbiAgICAgIGNvbmZpZzogeyBnYWluOiAyLjAsIG1peDogMC41IH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ2lucHV0JywgdHlwZTogJ3NpZ25hbCcgfV0sXHJcbiAgICAgIG91dHB1dHM6IFt7IG5hbWU6ICdvdXRwdXQnLCB0eXBlOiAnc2lnbmFsJyB9XSxcclxuICAgICAgY2F0ZWdvcnk6ICdXYXZlIFByb2Nlc3NpbmcnLFxyXG4gICAgICBlcXVhdGlvbnM6IFtcclxuICAgICAgICAneSA9IHRhbmgoZ2FpbiDDlyB4KScsXHJcbiAgICAgICAgJ291dHB1dCA9IG1peCDDlyB5ICsgKDEgLSBtaXgpIMOXIHgnXHJcbiAgICAgIF0sXHJcbiAgICAgIGhvd0l0V29ya3M6ICdBcHBsaWVzIGh5cGVyYm9saWMgdGFuZ2VudCBzYXR1cmF0aW9uIHRvIGNyZWF0ZSBoYXJtb25pYyBkaXN0b3J0aW9uIG9uIGFueSB3YXZlZm9ybS4gVGhlIGdhaW4gcGFyYW1ldGVyIGNvbnRyb2xzIHRoZSBhbW91bnQgb2Ygbm9ubGluZWFyaXR5LCB3aGlsZSBtaXggYmxlbmRzIGJldHdlZW4gdGhlIHByb2Nlc3NlZCBhbmQgZHJ5IHNpZ25hbHMuIFdvcmtzIG9uIGNoYW90aWMgb3NjaWxsYXRvcnMsIHBob3RvbmljIHNpZ25hbHMsIG9yIGFueSB0aW1lLXZhcnlpbmcgd2F2ZWZvcm0uJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2FsZ29yaXRobScsXHJcbiAgICAgIG5hbWU6ICdSZXNvbmF0b3InLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ1Jlc29uYW50IGZpbHRlciBmb3Igd2F2ZWZvcm0gZW1waGFzaXMnLFxyXG4gICAgICBjb25maWc6IHsgZnJlcXVlbmN5OiA0NDAuMCwgUTogMTAuMCB9LFxyXG4gICAgICBpbnB1dHM6IFt7IG5hbWU6ICdpbnB1dCcsIHR5cGU6ICdzaWduYWwnIH1dLFxyXG4gICAgICBvdXRwdXRzOiBbeyBuYW1lOiAnb3V0cHV0JywgdHlwZTogJ3NpZ25hbCcgfV0sXHJcbiAgICAgIGNhdGVnb3J5OiAnV2F2ZSBQcm9jZXNzaW5nJyxcclxuICAgICAgZXF1YXRpb25zOiBbXHJcbiAgICAgICAgJ0goz4kpID0gMSAvICgxICsgalEoz4kvz4nigoAgLSDPieKCgC/PiSkpJyxcclxuICAgICAgICAnz4nigoAgPSAyz4Bm4oKAJ1xyXG4gICAgICBdLFxyXG4gICAgICBob3dJdFdvcmtzOiAnQSByZXNvbmFudCBiYW5kcGFzcyBmaWx0ZXIgdGhhdCBlbXBoYXNpemVzIGZyZXF1ZW5jeSBjb21wb25lbnRzIG5lYXIgZuKCgCBpbiBhbnkgd2F2ZWZvcm0uIFRoZSBRIGZhY3RvciBjb250cm9scyB0aGUgc2hhcnBuZXNzIG9mIHRoZSByZXNvbmFuY2UgLSBoaWdoZXIgUSBjcmVhdGVzIGEgbmFycm93ZXIsIG1vcmUgcHJvbm91bmNlZCBwZWFrLiBBdCBoaWdoIFEgdmFsdWVzLCB0aGUgZmlsdGVyIGNhbiBzZWxmLW9zY2lsbGF0ZS4gV29ya3Mgb24gYW55IG9zY2lsbGF0b3Igb3V0cHV0IG9yIHNpZ25hbCBjaGFpbi4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnYWxnb3JpdGhtJyxcclxuICAgICAgbmFtZTogJ0hpbGJlcnQgVHJhbnNmb3JtJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdQaGFzZSBzaGlmdCBhbmQgZW52ZWxvcGUgZXh0cmFjdGlvbicsXHJcbiAgICAgIGNvbmZpZzogeyBvcmRlcjogNjQgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAnaW5wdXQnLCB0eXBlOiAnc2lnbmFsJyB9XSxcclxuICAgICAgb3V0cHV0czogW3sgbmFtZTogJ291dHB1dCcsIHR5cGU6ICdzaWduYWwnIH0sIHsgbmFtZTogJ2VudmVsb3BlJywgdHlwZTogJ3NpZ25hbCcgfV0sXHJcbiAgICAgIGNhdGVnb3J5OiAnV2F2ZSBQcm9jZXNzaW5nJyxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdhbGdvcml0aG0nLFxyXG4gICAgICBuYW1lOiAnQ29tcHJlc3NvcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnRHluYW1pYyByYW5nZSBjb21wcmVzc2lvbiBmb3Igd2F2ZWZvcm1zJyxcclxuICAgICAgY29uZmlnOiB7IHRocmVzaG9sZDogLTIwLjAsIHJhdGlvOiA0LjAsIGF0dGFjazogMTAuMCwgcmVsZWFzZTogMTAwLjAsIGtuZWU6IDYuMCwgbWFrZXVwR2FpbjogMC4wIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ2lucHV0JywgdHlwZTogJ3NpZ25hbCcgfV0sXHJcbiAgICAgIG91dHB1dHM6IFt7IG5hbWU6ICdvdXRwdXQnLCB0eXBlOiAnc2lnbmFsJyB9LCB7IG5hbWU6ICdnYWluX3JlZHVjdGlvbicsIHR5cGU6ICdzaWduYWwnIH1dLFxyXG4gICAgICBjYXRlZ29yeTogJ1dhdmUgUHJvY2Vzc2luZycsXHJcbiAgICAgIGVxdWF0aW9uczogW1xyXG4gICAgICAgICdpZiBpbnB1dF9kQiA+IHRocmVzaG9sZDonLFxyXG4gICAgICAgICcgIGdhaW5fcmVkdWN0aW9uID0gKGlucHV0X2RCIC0gdGhyZXNob2xkKSDDlyAoMSAtIDEvcmF0aW8pJyxcclxuICAgICAgICAnb3V0cHV0X2RCID0gaW5wdXRfZEIgLSBnYWluX3JlZHVjdGlvbiArIG1ha2V1cF9nYWluJ1xyXG4gICAgICBdLFxyXG4gICAgICBob3dJdFdvcmtzOiAnUmVkdWNlcyB0aGUgZHluYW1pYyByYW5nZSBvZiBhbnkgd2F2ZWZvcm0gYnkgYXR0ZW51YXRpbmcgYW1wbGl0dWRlcyBhYm92ZSB0aGUgdGhyZXNob2xkLiBUaGUgcmF0aW8gZGV0ZXJtaW5lcyBob3cgbXVjaCBjb21wcmVzc2lvbiBpcyBhcHBsaWVkLiBBdHRhY2sgYW5kIHJlbGVhc2UgY29udHJvbCByZXNwb25zZSB0aW1lLiBDYW4gYmUgdXNlZCB0byB0YW1lIGNoYW90aWMgb3NjaWxsYXRvciBwZWFrcywgc21vb3RoIHBob3RvbmljIHNpZ25hbHMsIG9yIGNvbnRyb2wgYW55IHRpbWUtdmFyeWluZyBhbXBsaXR1ZGUuJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2FsZ29yaXRobScsXHJcbiAgICAgIG5hbWU6ICdMaW1pdGVyJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdIYXJkIGxpbWl0aW5nIGZvciB3YXZlZm9ybSBjb250cm9sJyxcclxuICAgICAgY29uZmlnOiB7IHRocmVzaG9sZDogLTMuMCwgYXR0YWNrOiAwLjUsIHJlbGVhc2U6IDUwLjAsIGNlaWxpbmc6IC0wLjEgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAnaW5wdXQnLCB0eXBlOiAnc2lnbmFsJyB9XSxcclxuICAgICAgb3V0cHV0czogW3sgbmFtZTogJ291dHB1dCcsIHR5cGU6ICdzaWduYWwnIH0sIHsgbmFtZTogJ2xpbWl0aW5nJywgdHlwZTogJ3NpZ25hbCcgfV0sXHJcbiAgICAgIGNhdGVnb3J5OiAnV2F2ZSBQcm9jZXNzaW5nJyxcclxuICAgICAgZXF1YXRpb25zOiBbXHJcbiAgICAgICAgJ3JhdGlvID0g4oieOjEgKG9yIHZlcnkgaGlnaCwgZS5nLiwgMTAwOjEpJyxcclxuICAgICAgICAnb3V0cHV0ID0gbWluKGlucHV0LCBjZWlsaW5nKScsXHJcbiAgICAgICAgJ2lmIGlucHV0ID4gdGhyZXNob2xkOiBhcHBseSBnYWluIHJlZHVjdGlvbidcclxuICAgICAgXSxcclxuICAgICAgaG93SXRXb3JrczogJ0EgY29tcHJlc3NvciB3aXRoIGFuIGV4dHJlbWVseSBoaWdoIHJhdGlvIChhcHByb2FjaGluZyDiiJ46MSkgdGhhdCBwcmV2ZW50cyBhbnkgd2F2ZWZvcm0gZnJvbSBleGNlZWRpbmcgYSBzZXQgY2VpbGluZy4gVmVyeSBmYXN0IGF0dGFjayB0aW1lIGVuc3VyZXMgbm8gcGVha3MgZ2V0IHRocm91Z2guIFVzZWZ1bCBmb3IgcHJvdGVjdGluZyBkb3duc3RyZWFtIHN5c3RlbXMgZnJvbSBleHRyZW1lIGFtcGxpdHVkZXMgaW4gY2hhb3RpYyBvciBub25saW5lYXIgZHluYW1pY3MuJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2FsZ29yaXRobScsXHJcbiAgICAgIG5hbWU6ICdFeHBhbmRlcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnRHluYW1pYyByYW5nZSBleHBhbnNpb24gZm9yIHdhdmVmb3JtcycsXHJcbiAgICAgIGNvbmZpZzogeyB0aHJlc2hvbGQ6IC00MC4wLCByYXRpbzogMi4wLCBhdHRhY2s6IDUuMCwgcmVsZWFzZTogNTAuMCwga25lZTogNi4wIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ2lucHV0JywgdHlwZTogJ3NpZ25hbCcgfV0sXHJcbiAgICAgIG91dHB1dHM6IFt7IG5hbWU6ICdvdXRwdXQnLCB0eXBlOiAnc2lnbmFsJyB9LCB7IG5hbWU6ICdnYWluX2NoYW5nZScsIHR5cGU6ICdzaWduYWwnIH1dLFxyXG4gICAgICBjYXRlZ29yeTogJ1dhdmUgUHJvY2Vzc2luZycsXHJcbiAgICAgIGVxdWF0aW9uczogW1xyXG4gICAgICAgICdpZiBpbnB1dF9kQiA8IHRocmVzaG9sZDonLFxyXG4gICAgICAgICcgIGdhaW5faW5jcmVhc2UgPSAodGhyZXNob2xkIC0gaW5wdXRfZEIpIMOXIChyYXRpbyAtIDEpJyxcclxuICAgICAgICAnb3V0cHV0X2RCID0gaW5wdXRfZEIgLSBnYWluX2luY3JlYXNlJ1xyXG4gICAgICBdLFxyXG4gICAgICBob3dJdFdvcmtzOiAnT3Bwb3NpdGUgb2YgY29tcHJlc3Npb24gLSBpbmNyZWFzZXMgZHluYW1pYyByYW5nZSBieSBhdHRlbnVhdGluZyBzaWduYWxzIGJlbG93IHRoZSB0aHJlc2hvbGQuIENhbiBiZSB1c2VkIHRvIGVuaGFuY2UgY29udHJhc3QgaW4gd2F2ZWZvcm1zLCBzdXBwcmVzcyBsb3ctYW1wbGl0dWRlIG5vaXNlLCBvciBhZGQgZW1waGFzaXMgdG8gdHJhbnNpZW50IGZlYXR1cmVzIGluIGFueSBzaWduYWwgdHlwZS4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnYWxnb3JpdGhtJyxcclxuICAgICAgbmFtZTogJ0dhdGUnLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ1RocmVzaG9sZCBnYXRlIGZvciB3YXZlZm9ybSBjb250cm9sJyxcclxuICAgICAgY29uZmlnOiB7IHRocmVzaG9sZDogLTUwLjAsIGF0dGFjazogMS4wLCBob2xkOiAxMC4wLCByZWxlYXNlOiAxMDAuMCwgcmFuZ2U6IC04MC4wIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ2lucHV0JywgdHlwZTogJ3NpZ25hbCcgfSwgeyBuYW1lOiAnc2lkZWNoYWluJywgdHlwZTogJ3NpZ25hbCcgfV0sXHJcbiAgICAgIG91dHB1dHM6IFt7IG5hbWU6ICdvdXRwdXQnLCB0eXBlOiAnc2lnbmFsJyB9LCB7IG5hbWU6ICdnYXRlX3N0YXRlJywgdHlwZTogJ3NpZ25hbCcgfV0sXHJcbiAgICAgIGNhdGVnb3J5OiAnV2F2ZSBQcm9jZXNzaW5nJyxcclxuICAgICAgZXF1YXRpb25zOiBbXHJcbiAgICAgICAgJ2lmIGlucHV0X2RCID4gdGhyZXNob2xkOiBnYXRlX29wZW4gPSB0cnVlJyxcclxuICAgICAgICAnaWYgaW5wdXRfZEIgPCB0aHJlc2hvbGQgLSByYW5nZTogZ2F0ZV9vcGVuID0gZmFsc2UnLFxyXG4gICAgICAgICdvdXRwdXQgPSBpbnB1dCDDlyBnYXRlX2VudmVsb3BlJ1xyXG4gICAgICBdLFxyXG4gICAgICBob3dJdFdvcmtzOiAnU2lsZW5jZXMgd2F2ZWZvcm1zIGJlbG93IGEgdGhyZXNob2xkLCBlZmZlY3RpdmVseSByZW1vdmluZyBsb3ctYW1wbGl0dWRlIGNvbXBvbmVudHMuIEF0dGFjayBjb250cm9scyBnYXRlIG9wZW5pbmcgc3BlZWQsIGhvbGQga2VlcHMgaXQgb3BlbiBmb3IgbWluaW11bSB0aW1lLCBhbmQgcmVsZWFzZSBkZXRlcm1pbmVzIGNsb3Npbmcgc21vb3RobmVzcy4gU2lkZWNoYWluIGlucHV0IGFsbG93cyBleHRlcm5hbCB0cmlnZ2VyIGNvbnRyb2wuIFdvcmtzIG9uIGFueSBzaWduYWwgdHlwZS4nXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFBob3RvbmljIEFsZ29yaXRobXNcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2FsZ29yaXRobScsXHJcbiAgICAgIG5hbWU6ICdPcHRpY2FsIEtlcnIgRWZmZWN0JyxcclxuICAgICAgZGVzY3JpcHRpb246ICdJbnRlbnNpdHktZGVwZW5kZW50IHJlZnJhY3RpdmUgaW5kZXgnLFxyXG4gICAgICBjb25maWc6IHsgbjI6IDIuNmUtMjAgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAnZmllbGQnLCB0eXBlOiAnY29tcGxleCcgfV0sXHJcbiAgICAgIG91dHB1dHM6IFt7IG5hbWU6ICdmaWVsZCcsIHR5cGU6ICdjb21wbGV4JyB9XSxcclxuICAgICAgY2F0ZWdvcnk6ICdQaG90b25pYycsXHJcbiAgICAgIGVxdWF0aW9uczogW1xyXG4gICAgICAgICduKEkpID0gbuKCgCArIG7igoJJJyxcclxuICAgICAgICAnz4YgPSBu4oKCSSDDlyBMIMOXIGvigoAnLFxyXG4gICAgICAgICdFX291dCA9IEVfaW4gw5cgZXhwKGnPhiknXHJcbiAgICAgIF0sXHJcbiAgICAgIGhvd0l0V29ya3M6ICdUaGUgS2VyciBlZmZlY3QgY2F1c2VzIHRoZSByZWZyYWN0aXZlIGluZGV4IHRvIGNoYW5nZSB3aXRoIGxpZ2h0IGludGVuc2l0eS4gVGhpcyBjcmVhdGVzIGEgbm9ubGluZWFyIHBoYXNlIHNoaWZ0IHByb3BvcnRpb25hbCB0byB0aGUgb3B0aWNhbCBwb3dlci4gVXNlZCBpbiBvcHRpY2FsIHN3aXRjaGluZywgc2VsZi1mb2N1c2luZywgYW5kIHNvbGl0b24gZm9ybWF0aW9uLiBUaGUgbuKCgiBjb2VmZmljaWVudCBkZXRlcm1pbmVzIHRoZSBzdHJlbmd0aCBvZiB0aGUgbm9ubGluZWFyaXR5LidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdhbGdvcml0aG0nLFxyXG4gICAgICBuYW1lOiAnRm91ci1XYXZlIE1peGluZycsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnTm9uLWxpbmVhciBvcHRpY2FsIGludGVyYWN0aW9uJyxcclxuICAgICAgY29uZmlnOiB7IGNoaTM6IDFlLTIyIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ3B1bXAnLCB0eXBlOiAnY29tcGxleCcgfSwgeyBuYW1lOiAnc2lnbmFsJywgdHlwZTogJ2NvbXBsZXgnIH1dLFxyXG4gICAgICBvdXRwdXRzOiBbeyBuYW1lOiAnaWRsZXInLCB0eXBlOiAnY29tcGxleCcgfV0sXHJcbiAgICAgIGNhdGVnb3J5OiAnUGhvdG9uaWMnLFxyXG4gICAgfSxcclxuICBdLFxyXG5cclxuICBwYml0X2R5bmFtaWNzOiBbXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdhbGdvcml0aG0nLFxyXG4gICAgICBuYW1lOiAnUC1CaXQgQ29tcHJlc3NvcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnUHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uIGNvbXByZXNzaW9uIGZvciBwLWJpdHMnLFxyXG4gICAgICBjb25maWc6IHsgdGhyZXNob2xkOiAwLjUsIHJhdGlvOiA0LjAsIGF0dGFjazogNS4wLCByZWxlYXNlOiA1MC4wLCBiaWFzOiAwLjAgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAncF9pbicsIHR5cGU6ICdkaXNjcmV0ZScgfSwgeyBuYW1lOiAnbW9kdWxhdGlvbicsIHR5cGU6ICdzaWduYWwnIH1dLFxyXG4gICAgICBvdXRwdXRzOiBbeyBuYW1lOiAncF9vdXQnLCB0eXBlOiAnZGlzY3JldGUnIH0sIHsgbmFtZTogJ2NvbXByZXNzaW9uJywgdHlwZTogJ3NpZ25hbCcgfV0sXHJcbiAgICAgIGNhdGVnb3J5OiAnUC1CaXQnLFxyXG4gICAgICBlcXVhdGlvbnM6IFtcclxuICAgICAgICAnaWYgUCgxKSA+IHRocmVzaG9sZDonLFxyXG4gICAgICAgICcgIGNvbXByZXNzaW9uID0gKFAoMSkgLSB0aHJlc2hvbGQpIMOXICgxIC0gMS9yYXRpbyknLFxyXG4gICAgICAgICdQX291dCgxKSA9IFAoMSkgLSBjb21wcmVzc2lvbiArIGJpYXMnXHJcbiAgICAgIF0sXHJcbiAgICAgIGhvd0l0V29ya3M6ICdDb21wcmVzc2VzIHRoZSBwcm9iYWJpbGl0eSBkaXN0cmlidXRpb24gb2YgcC1iaXRzLCByZWR1Y2luZyB0aGUgZHluYW1pYyByYW5nZSBvZiBmbGlwIHByb2JhYmlsaXRpZXMuIFdoZW4gcC1iaXRzIGFyZSB0b28gXCJob3RcIiAoaGlnaCBmbGlwIHJhdGUpLCBjb21wcmVzc2lvbiBjb29scyB0aGVtIGRvd24uIFVzZWZ1bCBmb3Igc3RhYmlsaXppbmcgVEhSTUwgbmV0d29ya3MgYW5kIHByZXZlbnRpbmcgcnVuYXdheSB0aGVybWFsIGZsdWN0dWF0aW9ucy4gVGhlIGNvbXByZXNzaW9uIG91dHB1dCB0cmFja3MgaG93IG11Y2ggdGhlIGRpc3RyaWJ1dGlvbiBpcyBiZWluZyBzcXVlZXplZC4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnYWxnb3JpdGhtJyxcclxuICAgICAgbmFtZTogJ1AtQml0IExpbWl0ZXInLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ0hhcmQgbGltaXQgb24gcC1iaXQgZmxpcCBwcm9iYWJpbGl0eScsXHJcbiAgICAgIGNvbmZpZzogeyB0aHJlc2hvbGQ6IDAuOCwgYXR0YWNrOiAxLjAsIHJlbGVhc2U6IDIwLjAsIGNlaWxpbmc6IDAuOTUgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAncF9pbicsIHR5cGU6ICdkaXNjcmV0ZScgfV0sXHJcbiAgICAgIG91dHB1dHM6IFt7IG5hbWU6ICdwX291dCcsIHR5cGU6ICdkaXNjcmV0ZScgfSwgeyBuYW1lOiAnbGltaXRpbmcnLCB0eXBlOiAnc2lnbmFsJyB9XSxcclxuICAgICAgY2F0ZWdvcnk6ICdQLUJpdCcsXHJcbiAgICAgIGVxdWF0aW9uczogW1xyXG4gICAgICAgICdQX291dCgxKSA9IG1pbihQX2luKDEpLCBjZWlsaW5nKScsXHJcbiAgICAgICAgJ1Bfb3V0KDApID0gbWF4KFBfaW4oMCksIDEgLSBjZWlsaW5nKScsXHJcbiAgICAgICAgJ2xpbWl0aW5nID0gYW1vdW50IG9mIHByb2JhYmlsaXR5IGNsaXBwZWQnXHJcbiAgICAgIF0sXHJcbiAgICAgIGhvd0l0V29ya3M6ICdQcmV2ZW50cyBwLWJpdCBwcm9iYWJpbGl0aWVzIGZyb20gcmVhY2hpbmcgZXh0cmVtZSB2YWx1ZXMgKHRvbyBjbG9zZSB0byAwIG9yIDEpLCB3aGljaCBjYW4gY2F1c2UgbnVtZXJpY2FsIGluc3RhYmlsaXR5IGluIFRIUk1MIHN5c3RlbXMuIEFjdHMgYXMgYSBzYWZldHkgbWVjaGFuaXNtIHRvIG1haW50YWluIGhlYWx0aHkgdGhlcm1hbCBub2lzZSBsZXZlbHMuIFRoZSBjZWlsaW5nIHBhcmFtZXRlciBlbnN1cmVzIHAtYml0cyBhbHdheXMgcmV0YWluIHNvbWUgdW5jZXJ0YWludHksIHByZXNlcnZpbmcgdGhlaXIgcHJvYmFiaWxpc3RpYyBuYXR1cmUuJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2FsZ29yaXRobScsXHJcbiAgICAgIG5hbWU6ICdQLUJpdCBFeHBhbmRlcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnRXhwYW5kIHByb2JhYmlsaXR5IGRpc3RyaWJ1dGlvbiBmb3IgZW5oYW5jZWQgZmx1Y3R1YXRpb25zJyxcclxuICAgICAgY29uZmlnOiB7IHRocmVzaG9sZDogMC4zLCByYXRpbzogMi4wLCBhdHRhY2s6IDUuMCwgcmVsZWFzZTogNTAuMCB9LFxyXG4gICAgICBpbnB1dHM6IFt7IG5hbWU6ICdwX2luJywgdHlwZTogJ2Rpc2NyZXRlJyB9XSxcclxuICAgICAgb3V0cHV0czogW3sgbmFtZTogJ3Bfb3V0JywgdHlwZTogJ2Rpc2NyZXRlJyB9LCB7IG5hbWU6ICdleHBhbnNpb24nLCB0eXBlOiAnc2lnbmFsJyB9XSxcclxuICAgICAgY2F0ZWdvcnk6ICdQLUJpdCcsXHJcbiAgICAgIGVxdWF0aW9uczogW1xyXG4gICAgICAgICdpZiBQKDEpIDwgdGhyZXNob2xkOicsXHJcbiAgICAgICAgJyAgZXhwYW5zaW9uID0gKHRocmVzaG9sZCAtIFAoMSkpIMOXIChyYXRpbyAtIDEpJyxcclxuICAgICAgICAnUF9vdXQoMSkgPSBQKDEpICsgZXhwYW5zaW9uJ1xyXG4gICAgICBdLFxyXG4gICAgICBob3dJdFdvcmtzOiAnQW1wbGlmaWVzIHRoZXJtYWwgZmx1Y3R1YXRpb25zIGJ5IGV4cGFuZGluZyB0aGUgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uIG9mIGxvdy1hY3Rpdml0eSBwLWJpdHMuIFVzZWZ1bCBmb3IgXCJoZWF0aW5nIHVwXCIgcmVnaW9ucyBvZiB0aGUgVEhSTUwgbmV0d29yayB0aGF0IGhhdmUgYmVjb21lIHRvbyBjb2xkIG9yIHN0dWNrLiBIZWxwcyBlc2NhcGUgbG9jYWwgbWluaW1hIGluIGVuZXJneSBsYW5kc2NhcGVzIGJ5IGluY3JlYXNpbmcgZXhwbG9yYXRpb24uIENhbiBlbmhhbmNlIHRoZSByZXByZXNlbnRhdGlvbmFsIGNhcGFjaXR5IG9mIHAtYml0IGFycmF5cy4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnYWxnb3JpdGhtJyxcclxuICAgICAgbmFtZTogJ1AtQml0IEdhdGUnLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ1RocmVzaG9sZC1iYXNlZCBwLWJpdCBhY3RpdmF0aW9uIGdhdGUnLFxyXG4gICAgICBjb25maWc6IHsgdGhyZXNob2xkOiAwLjQsIGF0dGFjazogMi4wLCBob2xkOiAxMC4wLCByZWxlYXNlOiAzMC4wLCByYW5nZTogMC4xIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ3BfaW4nLCB0eXBlOiAnZGlzY3JldGUnIH0sIHsgbmFtZTogJ3NpZGVjaGFpbicsIHR5cGU6ICdkaXNjcmV0ZScgfV0sXHJcbiAgICAgIG91dHB1dHM6IFt7IG5hbWU6ICdwX291dCcsIHR5cGU6ICdkaXNjcmV0ZScgfSwgeyBuYW1lOiAnZ2F0ZV9zdGF0ZScsIHR5cGU6ICdzaWduYWwnIH1dLFxyXG4gICAgICBjYXRlZ29yeTogJ1AtQml0JyxcclxuICAgICAgZXF1YXRpb25zOiBbXHJcbiAgICAgICAgJ2lmIFAoMSkgPiB0aHJlc2hvbGQ6IGdhdGVfb3BlbiA9IHRydWUnLFxyXG4gICAgICAgICdpZiBQKDEpIDwgdGhyZXNob2xkIC0gcmFuZ2U6IGdhdGVfb3BlbiA9IGZhbHNlJyxcclxuICAgICAgICAnUF9vdXQgPSBQX2luIMOXIGdhdGVfZW52ZWxvcGUnXHJcbiAgICAgIF0sXHJcbiAgICAgIGhvd0l0V29ya3M6ICdTZWxlY3RpdmVseSBhY3RpdmF0ZXMgb3IgZGVhY3RpdmF0ZXMgcC1iaXRzIGJhc2VkIG9uIHRoZWlyIGZsaXAgcHJvYmFiaWxpdHkuIEJlbG93IHRocmVzaG9sZCwgcC1iaXRzIGFyZSBmb3JjZWQgaW50byBhIGxvdy1lbnRyb3B5IHN0YXRlIChjbG9zZSB0byAwIG9yIDEpLiBBYm92ZSB0aHJlc2hvbGQsIHRoZXkgb3BlcmF0ZSBub3JtYWxseS4gU2lkZWNoYWluIGlucHV0IGFsbG93cyBvbmUgc2V0IG9mIHAtYml0cyB0byBjb250cm9sIGFub3RoZXIsIGVuYWJsaW5nIGNvbmRpdGlvbmFsIGNvbXB1dGF0aW9uIGFuZCBhdHRlbnRpb24gbWVjaGFuaXNtcyBpbiBUSFJNTCBuZXR3b3Jrcy4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnYWxnb3JpdGhtJyxcclxuICAgICAgbmFtZTogJ1AtQml0IFRocmVzaG9sZCcsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnQmluYXJ5IHRocmVzaG9sZGluZyBmb3IgcC1iaXQgc3RhdGVzJyxcclxuICAgICAgY29uZmlnOiB7IHRocmVzaG9sZDogMC41LCBoeXN0ZXJlc2lzOiAwLjEsIHNtb290aGluZzogMC4wIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ3BfaW4nLCB0eXBlOiAnZGlzY3JldGUnIH1dLFxyXG4gICAgICBvdXRwdXRzOiBbeyBuYW1lOiAnYmluYXJ5JywgdHlwZTogJ2Rpc2NyZXRlJyB9LCB7IG5hbWU6ICdhbmFsb2cnLCB0eXBlOiAnc2lnbmFsJyB9XSxcclxuICAgICAgY2F0ZWdvcnk6ICdQLUJpdCcsXHJcbiAgICAgIGVxdWF0aW9uczogW1xyXG4gICAgICAgICdpZiBQKDEpID4gdGhyZXNob2xkICsgaHlzdGVyZXNpczogb3V0cHV0ID0gMScsXHJcbiAgICAgICAgJ2lmIFAoMSkgPCB0aHJlc2hvbGQgLSBoeXN0ZXJlc2lzOiBvdXRwdXQgPSAwJyxcclxuICAgICAgICAnZWxzZTogbWFpbnRhaW4gcHJldmlvdXMgc3RhdGUnXHJcbiAgICAgIF0sXHJcbiAgICAgIGhvd0l0V29ya3M6ICdDb252ZXJ0cyBwcm9iYWJpbGlzdGljIHAtYml0cyBpbnRvIGRldGVybWluaXN0aWMgYmluYXJ5IHZhbHVlcyB1c2luZyBhIHRocmVzaG9sZCB3aXRoIGh5c3RlcmVzaXMgKFNjaG1pdHQgdHJpZ2dlciBiZWhhdmlvcikuIFRoZSBoeXN0ZXJlc2lzIHByZXZlbnRzIG9zY2lsbGF0aW9uIGFyb3VuZCB0aGUgdGhyZXNob2xkLiBVc2VmdWwgZm9yIHJlYWRpbmcgb3V0IGZpbmFsIHN0YXRlcyBmcm9tIFRIUk1MIGNvbXB1dGF0aW9uIG9yIGNyZWF0aW5nIGRpc2NyZXRlIGNvbnRyb2wgc2lnbmFscy4gVGhlIGFuYWxvZyBvdXRwdXQgcHJvdmlkZXMgYSBzbW9vdGhlZCB2ZXJzaW9uIGZvciBtb25pdG9yaW5nLidcclxuICAgIH0sXHJcbiAgXSxcclxuXHJcbiAgdGhybWw6IFtcclxuICAgIHtcclxuICAgICAgdHlwZTogJ3Rocm1sJyxcclxuICAgICAgbmFtZTogJ1NwaW4gR2xhc3MgRUJNJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdJc2luZy1saWtlIGVuZXJneS1iYXNlZCBtb2RlbCcsXHJcbiAgICAgIGNvbmZpZzogeyBub2RlczogNjQsIHRlbXBlcmF0dXJlOiAxLjAsIGdpYmJzX3N0ZXBzOiA1IH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ2JpYXMnLCB0eXBlOiAnc2lnbmFsJyB9XSxcclxuICAgICAgb3V0cHV0czogW3sgbmFtZTogJ3NwaW5zJywgdHlwZTogJ2Rpc2NyZXRlJyB9LCB7IG5hbWU6ICdlbmVyZ3knLCB0eXBlOiAnc2NhbGFyJyB9XSxcclxuICAgICAgY2F0ZWdvcnk6ICdUSFJNTCcsXHJcbiAgICAgIGVxdWF0aW9uczogW1xyXG4gICAgICAgICdFKHMpID0gLeKIkeG1ouKxvCBK4bWi4rG8c+G1onPisbwgLSDiiJHhtaIgaOG1onPhtaInLFxyXG4gICAgICAgICdQKHMpID0gZXhwKC1FKHMpL1QpIC8gWicsXHJcbiAgICAgICAgJ1Aoc+G1oiA9IDEpID0gz4MoMuKIkeKxvCBK4bWi4rG8c+KxvCArIGjhtaIpIC8gVCknXHJcbiAgICAgIF0sXHJcbiAgICAgIGhvd0l0V29ya3M6ICdBbiBJc2luZy10eXBlIGVuZXJneS1iYXNlZCBtb2RlbCB3aGVyZSBiaW5hcnkgc3BpbnMgKMKxMSkgaW50ZXJhY3QgdGhyb3VnaCBsZWFybmVkIGNvdXBsaW5nIHdlaWdodHMgSi4gVXNlcyBibG9jayBHaWJicyBzYW1wbGluZyB0byBnZW5lcmF0ZSBzYW1wbGVzIGZyb20gdGhlIEJvbHR6bWFubiBkaXN0cmlidXRpb24uIFRlbXBlcmF0dXJlIFQgY29udHJvbHMgdGhlIHN0b2NoYXN0aWNpdHkgLSBsb3cgVCBwcm9kdWNlcyBkZXRlcm1pbmlzdGljIHN0YXRlcywgaGlnaCBUIHByb2R1Y2VzIHJhbmRvbSBleHBsb3JhdGlvbi4gQ29ubmVjdCB0aGUgYmlhcyBpbnB1dCB0byBtb2R1bGF0ZSBwLWJpdCBmbGlwIHByb2JhYmlsaXRpZXMsIGFuZCB1c2Ugc3BpbnMvZW5lcmd5IG91dHB1dHMgdG8gZHJpdmUgdmlzdWFsaXplcnMgb3Igb3RoZXIgbm9kZXMuJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ3Rocm1sJyxcclxuICAgICAgbmFtZTogJ0NvbnRpbnVvdXMgRUJNJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdDb250aW51b3VzLXZhbHVlZCBwcm9iYWJpbGlzdGljIG1vZGVsJyxcclxuICAgICAgY29uZmlnOiB7IG5vZGVzOiA2NCwgdGVtcGVyYXR1cmU6IDEuMCwgZ2liYnNfc3RlcHM6IDUgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAnaW5wdXQnLCB0eXBlOiAnc2lnbmFsJyB9XSxcclxuICAgICAgb3V0cHV0czogW3sgbmFtZTogJ291dHB1dCcsIHR5cGU6ICdzaWduYWwnIH0sIHsgbmFtZTogJ2VuZXJneScsIHR5cGU6ICdzY2FsYXInIH1dLFxyXG4gICAgICBjYXRlZ29yeTogJ1RIUk1MJyxcclxuICAgICAgZXF1YXRpb25zOiBbXHJcbiAgICAgICAgJ0UoeCkgPSDCvXjhtYBBeCArIGLhtYB4JyxcclxuICAgICAgICAnUCh4KSA9IGV4cCgtRSh4KS9UKSAvIFonLFxyXG4gICAgICAgICd44bWiIH4gTijOvOG1oiwgVCknXHJcbiAgICAgIF0sXHJcbiAgICAgIGhvd0l0V29ya3M6ICdBIGNvbnRpbnVvdXMtdmFsdWVkIGVuZXJneS1iYXNlZCBtb2RlbCB3aGVyZSB2YXJpYWJsZXMgY2FuIHRha2UgYW55IHJlYWwgdmFsdWUuIFRoZSBxdWFkcmF0aWMgZW5lcmd5IGZ1bmN0aW9uIGNyZWF0ZXMgR2F1c3NpYW4tbGlrZSBkaXN0cmlidXRpb25zLiBVc2VzIExhbmdldmluIGR5bmFtaWNzIG9yIGNvbnRpbnVvdXMgR2liYnMgc2FtcGxpbmcgdG8gZ2VuZXJhdGUgc2FtcGxlcy4gVXNlZnVsIGZvciBtb2RlbGluZyBjb250aW51b3VzIHNpZ25hbHMgYW5kIHJlYWwtdmFsdWVkIGRhdGEuIENvbm5lY3QgaW5wdXQgZnJvbSBzaWduYWwgc291cmNlcywgYW5kIHVzZSBvdXRwdXQgdG8gbW9kdWxhdGUgb3RoZXIgcGFyYW1ldGVycyBvciBmZWVkIHZpc3VhbGl6ZXJzLidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICd0aHJtbCcsXHJcbiAgICAgIG5hbWU6ICdIZXRlcm9nZW5lb3VzIE1vZGVsJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdNaXhlZCBkaXNjcmV0ZSBhbmQgY29udGludW91cyBub2RlcycsXHJcbiAgICAgIGNvbmZpZzogeyBzcGluX25vZGVzOiAzMiwgY29udGludW91c19ub2RlczogMzIsIHRlbXBlcmF0dXJlOiAxLjAgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAnaW5wdXQnLCB0eXBlOiAnc2lnbmFsJyB9XSxcclxuICAgICAgb3V0cHV0czogW3sgbmFtZTogJ3NwaW5zJywgdHlwZTogJ2Rpc2NyZXRlJyB9LCB7IG5hbWU6ICdjb250aW51b3VzJywgdHlwZTogJ3NpZ25hbCcgfV0sXHJcbiAgICAgIGNhdGVnb3J5OiAnVEhSTUwnLFxyXG4gICAgICBlcXVhdGlvbnM6IFtcclxuICAgICAgICAnRShzLHgpID0gReKCmyhzKSArIEXigpMoeCkgKyBF4oKb4oKTKHMseCknLFxyXG4gICAgICAgICdQKHMseCkgPSBleHAoLUUocyx4KS9UKSAvIFonLFxyXG4gICAgICAgICdF4oKb4oKTID0g4oiR4bWi4rG8IErhtaLisbxz4bWieOKxvCdcclxuICAgICAgXSxcclxuICAgICAgaG93SXRXb3JrczogJ0NvbWJpbmVzIGJpbmFyeSBzcGlucyBhbmQgY29udGludW91cyB2YXJpYWJsZXMgaW4gYSBzaW5nbGUgZW5lcmd5LWJhc2VkIG1vZGVsLiBBbGxvd3MgbW9kZWxpbmcgb2YgaHlicmlkIHN5c3RlbXMgd2hlcmUgc29tZSB2YXJpYWJsZXMgYXJlIGRpc2NyZXRlIChzcGlucykgYW5kIG90aGVycyBhcmUgY29udGludW91cyAocmVhbCB2YWx1ZXMpLiBUaGUgY3Jvc3MtY291cGxpbmcgdGVybXMgReKCm+KCkyBhbGxvdyBzcGlucyB0byBpbmZsdWVuY2UgY29udGludW91cyB2YXJpYWJsZXMgYW5kIHZpY2UgdmVyc2EuIFVzZSBpbnB1dCBmb3IgYW5hbG9nIG1vZHVsYXRpb24gYW5kIHJlYWQgc3BpbnMvY29udGludW91cyBvdXRwdXRzIGZvciBkaWZmZXJlbnQgc2lnbmFsIHR5cGVzLidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICd0aHJtbCcsXHJcbiAgICAgIG5hbWU6ICdDYXRlZ29yaWNhbCBFQk0nLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ011bHRpLXN0YXRlIGNhdGVnb3JpY2FsIHZhcmlhYmxlcyAoYmV5b25kIGJpbmFyeSknLFxyXG4gICAgICBjb25maWc6IHsgXHJcbiAgICAgICAgbm9kZXM6IDY0LCBcclxuICAgICAgICBudW1fc3RhdGVzOiA1LFxyXG4gICAgICAgIHRlbXBlcmF0dXJlOiAxLjAsXHJcbiAgICAgICAgZ2liYnNfc3RlcHM6IDVcclxuICAgICAgfSxcclxuICAgICAgaW5wdXRzOiBbXHJcbiAgICAgICAgeyBuYW1lOiAnYmlhcycsIHR5cGU6ICdzaWduYWxfYXJyYXknIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnb2JzZXJ2YXRpb25zJywgdHlwZTogJ2Rpc2NyZXRlJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdzdGF0ZXMnLCB0eXBlOiAnZGlzY3JldGUnIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnY2xhc3NfcHJvYnMnLCB0eXBlOiAnbWF0cml4JyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ2VuZXJneScsIHR5cGU6ICdzY2FsYXInIH1cclxuICAgICAgXSxcclxuICAgICAgY2F0ZWdvcnk6ICdUSFJNTCcsXHJcbiAgICAgIGhvd0l0V29ya3M6ICdMaWtlIFNwaW4gR2xhc3MgYnV0IGVhY2ggdmFyaWFibGUgY2FuIHRha2UgbXVsdGlwbGUgZGlzY3JldGUgdmFsdWVzIChlLmcuLCAwLDEsMiwzLDQgaW5zdGVhZCBvZiBqdXN0IMKxMSkuIFVzZXMgQ2F0ZWdvcmljYWxHaWJic0NvbmRpdGlvbmFsIGZvciBzYW1wbGluZy4gUGVyZmVjdCBmb3IgY2xhc3NpZmljYXRpb24gdGFza3MsIHN5bWJvbGljIHJlYXNvbmluZywgb3IgbW9kZWxpbmcgZGlzY3JldGUgbXVsdGktc3RhdGUgc3lzdGVtcyBsaWtlIG51Y2xlb3RpZGUgc2VxdWVuY2VzIG9yIG11c2ljYWwgbm90ZXMuJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ3Rocm1sJyxcclxuICAgICAgbmFtZTogJ0Jsb2NrIFNhbXBsaW5nIENvbmZpZycsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ29uZmlndXJlIGJsb2NraW5nIHN0cmF0ZWdpZXMgZm9yIFRIUk1MIHNhbXBsaW5nJyxcclxuICAgICAgY29uZmlnOiB7IFxyXG4gICAgICAgIHN0cmF0ZWd5OiAnY2hlY2tlcmJvYXJkJyxcclxuICAgICAgICBibG9ja19zaXplOiA4LFxyXG4gICAgICAgIG5fY29sb3JzOiAyXHJcbiAgICAgIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ21vZGVsX3N0YXRlJywgdHlwZTogJ2Rpc2NyZXRlJyB9XSxcclxuICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ2Jsb2NrZWRfc3RhdGUnLCB0eXBlOiAnZGlzY3JldGUnIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnZWZmZWN0aXZlX3NhbXBsZV9yYXRlJywgdHlwZTogJ3NjYWxhcicgfVxyXG4gICAgICBdLFxyXG4gICAgICBjYXRlZ29yeTogJ1RIUk1MJyxcclxuICAgICAgaG93SXRXb3JrczogJ0NvbmZpZ3VyZXMgYmxvY2sgcGFydGl0aW9uaW5nIHN0cmF0ZWdpZXMgZm9yIHBhcmFsbGVsIEdpYmJzIHNhbXBsaW5nLiBDaGVja2VyYm9hcmQgY3JlYXRlcyAyLWNvbG9yIGFsdGVybmF0aW5nIGJsb2Nrcy4gUmFuZG9tIHBhcnRpdGlvbnMgbm9kZXMgcmFuZG9tbHkuIFN0cmlwZXMgY3JlYXRlcyBsaW5lYXIgcGFydGl0aW9ucy4gU3VwZXJjZWxsIHVzZXMgZ3JpZC1iYXNlZCBibG9ja3MuIEdyYXBoLWNvbG9yaW5nIG9wdGltYWxseSBjb2xvcnMgaW50ZXJhY3Rpb24gZ3JhcGguIERpZmZlcmVudCBzdHJhdGVnaWVzIHRyYWRlIG9mZiBwYXJhbGxlbGlzbSB2cy4gbWl4aW5nIHNwZWVkLidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICd0aHJtbCcsXHJcbiAgICAgIG5hbWU6ICdDb25kaXRpb25hbCBTYW1wbGVyJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdTYW1wbGUgd2l0aCBjbGFtcGVkL29ic2VydmVkIHZhcmlhYmxlcycsXHJcbiAgICAgIGNvbmZpZzogeyBcclxuICAgICAgICBjbGFtcF9tYXNrOiBbXSxcclxuICAgICAgICBjbGFtcF92YWx1ZXM6IFtdXHJcbiAgICAgIH0sXHJcbiAgICAgIGlucHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ2Jhc2Vfc3RhdGUnLCB0eXBlOiAnZGlzY3JldGUnIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnb2JzZXJ2YXRpb25zJywgdHlwZTogJ2Rpc2NyZXRlJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdjb25kaXRpb25lZF9zdGF0ZScsIHR5cGU6ICdkaXNjcmV0ZScgfSxcclxuICAgICAgICB7IG5hbWU6ICdsb2dfcHJvYicsIHR5cGU6ICdzY2FsYXInIH1cclxuICAgICAgXSxcclxuICAgICAgY2F0ZWdvcnk6ICdUSFJNTCcsXHJcbiAgICAgIGhvd0l0V29ya3M6ICdTYW1wbGVzIGZyb20gY29uZGl0aW9uYWwgZGlzdHJpYnV0aW9ucyBieSBjbGFtcGluZyBvYnNlcnZlZCB2YXJpYWJsZXMuIEVzc2VudGlhbCBmb3IgaW5wYWludGluZyAoZmlsbCBtaXNzaW5nIGRhdGEpLCBjb25zdHJhaW5lZCBnZW5lcmF0aW9uIChmb3JjZSBjZXJ0YWluIG91dHB1dHMpLCBvciBCYXllc2lhbiBpbmZlcmVuY2UgKGNvbmRpdGlvbiBvbiBldmlkZW5jZSkuIENsYW1wX21hc2sgc3BlY2lmaWVzIHdoaWNoIHZhcmlhYmxlcyB0byBmaXgsIGNsYW1wX3ZhbHVlcyBzZXRzIHRoZWlyIHZhbHVlcy4gTG9nX3Byb2IgdHJhY2tzIGNvbmRpdGlvbmFsIGxpa2VsaWhvb2QuJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ3Rocm1sJyxcclxuICAgICAgbmFtZTogJ011bHRpLUNoYWluIFNhbXBsZXInLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ1J1biBtdWx0aXBsZSBpbmRlcGVuZGVudCBzYW1wbGluZyBjaGFpbnMnLFxyXG4gICAgICBjb25maWc6IHsgXHJcbiAgICAgICAgbl9jaGFpbnM6IDgsXHJcbiAgICAgICAgY2hhaW5fbGVuZ3RoOiAxMDAsXHJcbiAgICAgICAgcGFyYWxsZWw6IHRydWVcclxuICAgICAgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAnbW9kZWxfc3RhdGUnLCB0eXBlOiAnZGlzY3JldGUnIH1dLFxyXG4gICAgICBvdXRwdXRzOiBbXHJcbiAgICAgICAgeyBuYW1lOiAnY2hhaW5fc2FtcGxlcycsIHR5cGU6ICdkaXNjcmV0ZScgfSxcclxuICAgICAgICB7IG5hbWU6ICdjaGFpbl9lbmVyZ2llcycsIHR5cGU6ICdzaWduYWxfYXJyYXknIH0sXHJcbiAgICAgICAgeyBuYW1lOiAncl9oYXQnLCB0eXBlOiAnc2NhbGFyJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIGNhdGVnb3J5OiAnVEhSTUwnLFxyXG4gICAgICBob3dJdFdvcmtzOiAnUnVucyBtdWx0aXBsZSBNQ01DIGNoYWlucyBpbiBwYXJhbGxlbCBmb3IgYmV0dGVyIGV4cGxvcmF0aW9uIGFuZCBjb252ZXJnZW5jZSBkaWFnbm9zdGljcy4gUl9oYXQgb3V0cHV0IG1lYXN1cmVzIGNoYWluIGNvbnZlcmdlbmNlICg8IDEuMSA9IGdvb2QpLiBFeHBsb2l0cyBHUFUgcGFyYWxsZWxpc20gZm9yIG1hc3NpdmUgc3BlZWR1cC4gRXNzZW50aWFsIGZvciByZWxpYWJsZSBpbmZlcmVuY2UgYW5kIGRldGVjdGluZyBtdWx0aW1vZGFsIGRpc3RyaWJ1dGlvbnMuIEVhY2ggY2hhaW4gc3RhcnRzIGZyb20gZGlmZmVyZW50IGluaXRpYWxpemF0aW9uLidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICd0aHJtbCcsXHJcbiAgICAgIG5hbWU6ICdBbm5lYWxpbmcgU2NoZWR1bGVyJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdEeW5hbWljIHRlbXBlcmF0dXJlIHNjaGVkdWxpbmcgZm9yIHNhbXBsaW5nJyxcclxuICAgICAgY29uZmlnOiB7IFxyXG4gICAgICAgIHNjaGVkdWxlX3R5cGU6ICdsaW5lYXInLFxyXG4gICAgICAgIFRfc3RhcnQ6IDEwLjAsXHJcbiAgICAgICAgVF9lbmQ6IDAuMSxcclxuICAgICAgICBzdGVwczogMTAwMFxyXG4gICAgICB9LFxyXG4gICAgICBpbnB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdtb2RlbF9zdGF0ZScsIHR5cGU6ICdkaXNjcmV0ZScgfSxcclxuICAgICAgICB7IG5hbWU6ICdwcm9ncmVzcycsIHR5cGU6ICdzY2FsYXInIH1cclxuICAgICAgXSxcclxuICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ2FubmVhbGVkX3N0YXRlJywgdHlwZTogJ2Rpc2NyZXRlJyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ2N1cnJlbnRfdGVtcCcsIHR5cGU6ICdzY2FsYXInIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnYWNjZXB0YW5jZV9yYXRlJywgdHlwZTogJ3NjYWxhcicgfVxyXG4gICAgICBdLFxyXG4gICAgICBjYXRlZ29yeTogJ1RIUk1MJyxcclxuICAgICAgaG93SXRXb3JrczogJ0ltcGxlbWVudHMgc2ltdWxhdGVkIGFubmVhbGluZyBvciBwYXJhbGxlbCB0ZW1wZXJpbmcuIFN0YXJ0IGhvdCAoaGlnaCBUKSBmb3IgZXhwbG9yYXRpb24sIGNvb2wgZG93biAobG93IFQpIGZvciBleHBsb2l0YXRpb24uIExpbmVhci9leHBvbmVudGlhbCBzY2hlZHVsZXMgZ3JhZHVhbGx5IHJlZHVjZSB0ZW1wZXJhdHVyZS4gQ3ljbGljIHNjaGVkdWxlcyBjYW4gZXNjYXBlIGxvY2FsIG1pbmltYS4gUGFyYWxsZWwgdGVtcGVyaW5nIHN3YXBzIHN0YXRlcyBiZXR3ZWVuIHRlbXBlcmF0dXJlcyBmb3IgYmV0dGVyIG1peGluZyBhbmQgbW9kZSBkaXNjb3ZlcnkuJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ3Rocm1sJyxcclxuICAgICAgbmFtZTogJ01vbWVudCBBY2N1bXVsYXRvcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnVHJhY2sgbWVhbiwgdmFyaWFuY2UsIGNvcnJlbGF0aW9ucyBvdmVyIHNhbXBsaW5nJyxcclxuICAgICAgY29uZmlnOiB7IHdpbmRvd19zaXplOiAxMDAwIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ3NhbXBsZXMnLCB0eXBlOiAnZGlzY3JldGUnIH1dLFxyXG4gICAgICBvdXRwdXRzOiBbXHJcbiAgICAgICAgeyBuYW1lOiAnbWVhbicsIHR5cGU6ICdzaWduYWxfYXJyYXknIH0sXHJcbiAgICAgICAgeyBuYW1lOiAndmFyaWFuY2UnLCB0eXBlOiAnc2lnbmFsX2FycmF5JyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ2NvcnJlbGF0aW9ucycsIHR5cGU6ICdtYXRyaXgnIH1cclxuICAgICAgXSxcclxuICAgICAgY2F0ZWdvcnk6ICdUSFJNTCcsXHJcbiAgICAgIGhvd0l0V29ya3M6ICdBY2N1bXVsYXRlcyBmaXJzdCBhbmQgc2Vjb25kIG1vbWVudHMgKG1lYW4sIHZhcmlhbmNlKSBhbmQgY3Jvc3MtY29ycmVsYXRpb25zIGZyb20gVEhSTUwgc2FtcGxlcy4gRXNzZW50aWFsIGZvciBtb21lbnQgbWF0Y2hpbmcgdHJhaW5pbmcsIGNvbnZlcmdlbmNlIG1vbml0b3JpbmcsIGFuZCB1bmRlcnN0YW5kaW5nIGxlYXJuZWQgZGlzdHJpYnV0aW9ucy4gQ29ycmVsYXRpb25zIHJldmVhbCBpbnRlcmFjdGlvbiBzdHJ1Y3R1cmUuIFdpbmRvd19zaXplIGNvbnRyb2xzIHRlbXBvcmFsIGF2ZXJhZ2luZyAtIGxhcmdlciA9IG1vcmUgc3RhYmxlLCBzbWFsbGVyID0gbW9yZSByZXNwb25zaXZlLidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICd0aHJtbCcsXHJcbiAgICAgIG5hbWU6ICdXZWlnaHRlZCBGYWN0b3InLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ0RlZmluZSB3ZWlnaHRlZCBpbnRlcmFjdGlvbiBmYWN0b3JzJyxcclxuICAgICAgY29uZmlnOiB7IFxyXG4gICAgICAgIGZhY3Rvcl90eXBlOiAncGFpcndpc2UnLFxyXG4gICAgICAgIHdlaWdodDogMS4wXHJcbiAgICAgIH0sXHJcbiAgICAgIGlucHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ3ZhcmlhYmxlcycsIHR5cGU6ICdkaXNjcmV0ZScgfSxcclxuICAgICAgICB7IG5hbWU6ICd3ZWlnaHRfbW9kJywgdHlwZTogJ3NpZ25hbCcgfVxyXG4gICAgICBdLFxyXG4gICAgICBvdXRwdXRzOiBbXHJcbiAgICAgICAgeyBuYW1lOiAnZW5lcmd5X2NvbnRyaWJ1dGlvbicsIHR5cGU6ICdzY2FsYXInIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnZmFjdG9yX2dyYXBoJywgdHlwZTogJ2N1c3RvbScgfVxyXG4gICAgICBdLFxyXG4gICAgICBjYXRlZ29yeTogJ1RIUk1MJyxcclxuICAgICAgaG93SXRXb3JrczogJ0NyZWF0ZXMgd2VpZ2h0ZWQgZmFjdG9yIGdyYXBoIGVkZ2VzIGJldHdlZW4gdmFyaWFibGVzLiBQYWlyd2lzZSBmYWN0b3JzIGNvdXBsZSBwYWlycyBvZiBzcGlucy4gSGlnaGVyLW9yZGVyIGZhY3RvcnMgY3JlYXRlIG11bHRpLWJvZHkgaW50ZXJhY3Rpb25zLiBXZWlnaHRfbW9kIGlucHV0IGFsbG93cyBkeW5hbWljIG1vZHVsYXRpb24gb2YgaW50ZXJhY3Rpb24gc3RyZW5ndGguIEVuZXJneV9jb250cmlidXRpb24gc2hvd3MgZmFjdG9yIGNvbnRyaWJ1dGlvbiB0byB0b3RhbCBlbmVyZ3kuIEVzc2VudGlhbCBmb3IgYnVpbGRpbmcgc3RydWN0dXJlZCBQR01zLidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICd0aHJtbCcsXHJcbiAgICAgIG5hbWU6ICdIaWdoZXItT3JkZXIgSW50ZXJhY3Rpb25zJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdNdWx0aS1ib2R5IHNwaW4gaW50ZXJhY3Rpb25zIGJleW9uZCBwYWlyd2lzZScsXHJcbiAgICAgIGNvbmZpZzogeyBcclxuICAgICAgICBvcmRlcjogMyxcclxuICAgICAgICBjb3VwbGluZ19zdHJlbmd0aDogMC41XHJcbiAgICAgIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ3NwaW5fZ3JvdXBzJywgdHlwZTogJ2Rpc2NyZXRlJyB9XSxcclxuICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ2ludGVyYWN0aW9uX2VuZXJneScsIHR5cGU6ICdzY2FsYXInIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnbW9kaWZpZWRfc3BpbnMnLCB0eXBlOiAnZGlzY3JldGUnIH1cclxuICAgICAgXSxcclxuICAgICAgY2F0ZWdvcnk6ICdUSFJNTCcsXHJcbiAgICAgIGhvd0l0V29ya3M6ICdJbXBsZW1lbnRzIG11bHRpLWJvZHkgaW50ZXJhY3Rpb25zICgzLXNwaW4sIDQtc3BpbiwgZXRjLikgYmV5b25kIHN0YW5kYXJkIHBhaXJ3aXNlIElzaW5nLiBSZXF1aXJlZCBmb3IgbW9kZWxpbmcgY29tcGxleCBzeXN0ZW1zIGxpa2UgZnJ1c3RyYXRlZCBtYWduZXRzLCBlcnJvciBjb3JyZWN0aW9uIGNvZGVzLCBvciBjb25zdHJhaW50IHNhdGlzZmFjdGlvbiBwcm9ibGVtcy4gT3JkZXIgcGFyYW1ldGVyIHNldHMgaW50ZXJhY3Rpb24gc2l6ZS4gTW9yZSBleHByZXNzaXZlIHRoYW4gcGFpcndpc2UgYnV0IGNvbXB1dGF0aW9uYWxseSBoZWF2aWVyLidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICd0aHJtbCcsXHJcbiAgICAgIG5hbWU6ICdJc2luZyBUcmFpbmVyJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdUcmFpbiBJc2luZyBtb2RlbCB3aXRoIG1vbWVudCBtYXRjaGluZycsXHJcbiAgICAgIGNvbmZpZzogeyBcclxuICAgICAgICBsZWFybmluZ19yYXRlOiAwLjAxLFxyXG4gICAgICAgIG5fY2hhaW5zOiA0LFxyXG4gICAgICAgIGNkX3N0ZXBzOiAxMFxyXG4gICAgICB9LFxyXG4gICAgICBpbnB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdkYXRhX3NhbXBsZXMnLCB0eXBlOiAnZGlzY3JldGUnIH0sXHJcbiAgICAgICAgeyBuYW1lOiAndHJpZ2dlcicsIHR5cGU6ICdkaXNjcmV0ZScgfVxyXG4gICAgICBdLFxyXG4gICAgICBvdXRwdXRzOiBbXHJcbiAgICAgICAgeyBuYW1lOiAndHJhaW5lZF93ZWlnaHRzJywgdHlwZTogJ21hdHJpeCcgfSxcclxuICAgICAgICB7IG5hbWU6ICdrbF9kaXZlcmdlbmNlJywgdHlwZTogJ3NjYWxhcicgfSxcclxuICAgICAgICB7IG5hbWU6ICdncmFkX25vcm0nLCB0eXBlOiAnc2NhbGFyJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIGNhdGVnb3J5OiAnVEhSTUwnLFxyXG4gICAgICBob3dJdFdvcmtzOiAnVHJhaW5zIElzaW5nIG1vZGVsIHdlaWdodHMgdXNpbmcgY29udHJhc3RpdmUgZGl2ZXJnZW5jZSB0byBtYXRjaCBkYXRhIG1vbWVudHMuIE5fY2hhaW5zIGNvbnRyb2xzIHBhcmFsbGVsIGNoYWluIGNvdW50IGZvciBncmFkaWVudCBlc3RpbWF0aW9uLiBDRF9zdGVwcyBzZXRzIG51bWJlciBvZiBHaWJicyBzdGVwcyBwZXIgdXBkYXRlLiBLTF9kaXZlcmdlbmNlIHRyYWNrcyB0cmFpbmluZyBwcm9ncmVzcy4gR3JhZF9ub3JtIG1vbml0b3JzIGdyYWRpZW50IG1hZ25pdHVkZSBmb3IgbGVhcm5pbmcgcmF0ZSB0dW5pbmcuJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ3Rocm1sJyxcclxuICAgICAgbmFtZTogJ1BlcnNpc3RlbnQgQ0QgVHJhaW5lcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnUENEIHRyYWluaW5nIHdpdGggcGVyc2lzdGVudCBjaGFpbnMnLFxyXG4gICAgICBjb25maWc6IHsgXHJcbiAgICAgICAgbGVhcm5pbmdfcmF0ZTogMC4wMSxcclxuICAgICAgICBuX3BlcnNpc3RlbnRfY2hhaW5zOiAxMCxcclxuICAgICAgICBrX3N0ZXBzOiAxXHJcbiAgICAgIH0sXHJcbiAgICAgIGlucHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ2RhdGFfYmF0Y2gnLCB0eXBlOiAnZGlzY3JldGUnIH0sXHJcbiAgICAgICAgeyBuYW1lOiAndHJhaW5fdHJpZ2dlcicsIHR5cGU6ICdkaXNjcmV0ZScgfVxyXG4gICAgICBdLFxyXG4gICAgICBvdXRwdXRzOiBbXHJcbiAgICAgICAgeyBuYW1lOiAndXBkYXRlZF93ZWlnaHRzJywgdHlwZTogJ21hdHJpeCcgfSxcclxuICAgICAgICB7IG5hbWU6ICdmYW50YXN5X3BhcnRpY2xlcycsIHR5cGU6ICdkaXNjcmV0ZScgfSxcclxuICAgICAgICB7IG5hbWU6ICdyZWNvbnN0cnVjdGlvbl9lcnJvcicsIHR5cGU6ICdzY2FsYXInIH1cclxuICAgICAgXSxcclxuICAgICAgY2F0ZWdvcnk6ICdUSFJNTCcsXHJcbiAgICAgIGhvd0l0V29ya3M6ICdMaWtlIENELWsgYnV0IG1haW50YWlucyBwZXJzaXN0ZW50IGZhbnRhc3kgcGFydGljbGVzIHRoYXQgY29udGludW91c2x5IGV4cGxvcmUgbW9kZWwgZGlzdHJpYnV0aW9uLiBNb3JlIHN0YWJsZSBncmFkaWVudHMgdGhhbiBDRC4gRmFudGFzeSBwYXJ0aWNsZXMgc2hvdyB3aGF0IHRoZSBtb2RlbCBnZW5lcmF0ZXMgd2l0aG91dCBkYXRhIGluZmx1ZW5jZS4gQmV0dGVyIGZvciBkZWVwIGVuZXJneS1iYXNlZCBtb2RlbHMuIEVhY2ggcGVyc2lzdGVudCBjaGFpbiBtYWludGFpbnMgaXRzIG93biB0cmFqZWN0b3J5IGFjcm9zcyB1cGRhdGVzLidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICd0aHJtbCcsXHJcbiAgICAgIG5hbWU6ICdTYW1wbGluZyBQcm9maWxlcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnTWVhc3VyZSBzYW1wbGluZyBlZmZpY2llbmN5IGFuZCBwZXJmb3JtYW5jZScsXHJcbiAgICAgIGNvbmZpZzogeyBcclxuICAgICAgICB3aW5kb3dfc2l6ZTogMTAwMCxcclxuICAgICAgICB0cmFja19hdXRvY29ycjogdHJ1ZSxcclxuICAgICAgICB0cmFja19lc3M6IHRydWVcclxuICAgICAgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAnc2FtcGxlcycsIHR5cGU6ICdkaXNjcmV0ZScgfV0sXHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdzYW1wbGVzX3Blcl9zZWMnLCB0eXBlOiAnc2NhbGFyJyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ2Vzc19wZXJfc2VjJywgdHlwZTogJ3NjYWxhcicgfSxcclxuICAgICAgICB7IG5hbWU6ICdhdXRvY29ycl90aW1lJywgdHlwZTogJ3NjYWxhcicgfSxcclxuICAgICAgICB7IG5hbWU6ICdhY2NlcHRhbmNlX3JhdGUnLCB0eXBlOiAnc2NhbGFyJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIGNhdGVnb3J5OiAnVEhSTUwnLFxyXG4gICAgICBob3dJdFdvcmtzOiAnVHJhY2tzIE1DTUMgcGVyZm9ybWFuY2UgbWV0cmljcy4gRVNTIChFZmZlY3RpdmUgU2FtcGxlIFNpemUpIG1lYXN1cmVzIGVmZmVjdGl2ZSBpbmRlcGVuZGVudCBzYW1wbGVzIGFjY291bnRpbmcgZm9yIGF1dG9jb3JyZWxhdGlvbi4gU2FtcGxlc19wZXJfc2VjIHNob3dzIHJhdyB0aHJvdWdocHV0LiBBdXRvY29ycl90aW1lIGluZGljYXRlcyBtaXhpbmcgc3BlZWQgLSBsb3dlciBpcyBiZXR0ZXIuIEVzc2VudGlhbCBmb3IgdHVuaW5nIHNhbXBsZXIgcGFyYW1ldGVycywgY29tcGFyaW5nIGJhY2tlbmRzLCBhbmQgcHJvZHVjdGlvbiBtb25pdG9yaW5nLidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICd0aHJtbCcsXHJcbiAgICAgIG5hbWU6ICdHcmFwaCBDb2xvcmluZyBPcHRpbWl6ZXInLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ0ZpbmQgb3B0aW1hbCBibG9jayBwYXJ0aXRpb25zIGZvciBzYW1wbGluZycsXHJcbiAgICAgIGNvbmZpZzogeyBcclxuICAgICAgICBtZXRob2Q6ICdncmFwaF9jb2xvcmluZycsXHJcbiAgICAgICAgbWluX2NvbG9yczogMixcclxuICAgICAgICBtYXhfY29sb3JzOiA4LFxyXG4gICAgICAgIHJlY29tcHV0ZV9pbnRlcnZhbDogMTAwXHJcbiAgICAgIH0sXHJcbiAgICAgIGlucHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ2ludGVyYWN0aW9uX2dyYXBoJywgdHlwZTogJ21hdHJpeCcgfSxcclxuICAgICAgICB7IG5hbWU6ICd0cmlnZ2VyJywgdHlwZTogJ2Rpc2NyZXRlJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdibG9ja19hc3NpZ25tZW50JywgdHlwZTogJ2Rpc2NyZXRlJyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ25fY29sb3JzJywgdHlwZTogJ3NjYWxhcicgfSxcclxuICAgICAgICB7IG5hbWU6ICdwYXJhbGxlbGlzbV9mYWN0b3InLCB0eXBlOiAnc2NhbGFyJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIGNhdGVnb3J5OiAnVEhSTUwnLFxyXG4gICAgICBob3dJdFdvcmtzOiAnQXV0b21hdGljYWxseSBmaW5kcyBvcHRpbWFsIGJsb2NrIHBhcnRpdGlvbnMgZm9yIHBhcmFsbGVsIEdpYmJzIHNhbXBsaW5nLiBHcmFwaCBjb2xvcmluZyBlbnN1cmVzIG5vIGNvbm5lY3RlZCB2YXJpYWJsZXMgc2hhcmUgYSBibG9jayAoaW5kZXBlbmRlbmNlKS4gTWV0aXMgdXNlcyBncmFwaCBwYXJ0aXRpb25pbmcuIFNwZWN0cmFsIHVzZXMgZWlnZW5kZWNvbXBvc2l0aW9uLiBGZXdlciBjb2xvcnMgPSBtb3JlIHBhcmFsbGVsaXNtLiBEeW5hbWljYWxseSBhZGFwdHMgdG8gY2hhbmdpbmcgaW50ZXJhY3Rpb24gc3RydWN0dXJlcyB2aWEgdHJpZ2dlciBpbnB1dC4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAndGhybWwnLFxyXG4gICAgICBuYW1lOiAnU3RhdGUgVmFsaWRhdG9yJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdWZXJpZnkgYW5kIHJlcGFpciBUSFJNTCBibG9jayBzdGF0ZXMnLFxyXG4gICAgICBjb25maWc6IHsgXHJcbiAgICAgICAgcmVwYWlyX2ludmFsaWQ6IHRydWUsXHJcbiAgICAgICAgY2hlY2tfaW50ZXJ2YWw6IDEwXHJcbiAgICAgIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ2Jsb2NrX3N0YXRlJywgdHlwZTogJ2Rpc2NyZXRlJyB9XSxcclxuICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ3ZhbGlkX3N0YXRlJywgdHlwZTogJ2Rpc2NyZXRlJyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ2lzX3ZhbGlkJywgdHlwZTogJ2Rpc2NyZXRlJyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ25fdmlvbGF0aW9ucycsIHR5cGU6ICdzY2FsYXInIH1cclxuICAgICAgXSxcclxuICAgICAgY2F0ZWdvcnk6ICdUSFJNTCcsXHJcbiAgICAgIGhvd0l0V29ya3M6ICdDaGVja3MgYmxvY2sgc3RhdGUgdmFsaWRpdHk6IGNvcnJlY3QgZGltZW5zaW9ucywgdmFsdWUgcmFuZ2VzLCBibG9jayBzdHJ1Y3R1cmUsIE5hTi9JbmYgZGV0ZWN0aW9uLiBSZXBhaXJzIGludmFsaWQgc3RhdGVzIGlmIHJlcGFpcl9pbnZhbGlkIGlzIGVuYWJsZWQuIFByZXZlbnRzIGRvd25zdHJlYW0gZXJyb3JzIGZyb20gY29ycnVwdGVkIHN0YXRlcy4gRXNzZW50aWFsIGZvciBkZWJ1Z2dpbmcgY29tcGxleCBUSFJNTCBwaXBlbGluZXMuIENoZWNrX2ludGVydmFsIGNvbnRyb2xzIHZhbGlkYXRpb24gZnJlcXVlbmN5IGZvciBwZXJmb3JtYW5jZS4nXHJcbiAgICB9LFxyXG4gIF0sXHJcblxyXG4gIHZpc3VhbGl6ZXJzOiBbXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICd2aXN1YWxpemVyJyxcclxuICAgICAgbmFtZTogJ09zY2lsbG9zY29wZScsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnVGltZS1kb21haW4gd2F2ZWZvcm0gZGlzcGxheScsXHJcbiAgICAgIGNvbmZpZzogeyBidWZmZXJfc2l6ZTogMTAyNCwgY2hhbm5lbHM6IDMsIHdpZHRoOiA1MDAsIGhlaWdodDogMzUwLCBhY3RpdmU6IHRydWUgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAneCcsIHR5cGU6ICdzaWduYWwnIH0sIHsgbmFtZTogJ3knLCB0eXBlOiAnc2lnbmFsJyB9LCB7IG5hbWU6ICd6JywgdHlwZTogJ3NpZ25hbCcgfV0sXHJcbiAgICAgIG91dHB1dHM6IFtdLFxyXG4gICAgICBjYXRlZ29yeTogJ1Zpc3VhbGl6ZXInLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ3Zpc3VhbGl6ZXInLFxyXG4gICAgICBuYW1lOiAnU3BlY3Ryb2dyYW0nLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ0ZyZXF1ZW5jeS10aW1lIGFuYWx5c2lzJyxcclxuICAgICAgY29uZmlnOiB7IGZmdF9zaXplOiAyMDQ4LCBvdmVybGFwOiAwLjc1LCB3aWR0aDogNTAwLCBoZWlnaHQ6IDM1MCwgYWN0aXZlOiB0cnVlIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ3NpZ25hbCcsIHR5cGU6ICdzaWduYWwnIH1dLFxyXG4gICAgICBvdXRwdXRzOiBbXSxcclxuICAgICAgY2F0ZWdvcnk6ICdWaXN1YWxpemVyJyxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICd2aXN1YWxpemVyJyxcclxuICAgICAgbmFtZTogJ1BoYXNlIFNwYWNlIDNEJyxcclxuICAgICAgZGVzY3JpcHRpb246ICczRCBhdHRyYWN0b3IgdmlzdWFsaXphdGlvbicsXHJcbiAgICAgIGNvbmZpZzogeyB3aWR0aDogNTAwLCBoZWlnaHQ6IDUwMCwgYWN0aXZlOiB0cnVlIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ3gnLCB0eXBlOiAnc2lnbmFsJyB9LCB7IG5hbWU6ICd5JywgdHlwZTogJ3NpZ25hbCcgfSwgeyBuYW1lOiAneicsIHR5cGU6ICdzaWduYWwnIH1dLFxyXG4gICAgICBvdXRwdXRzOiBbXSxcclxuICAgICAgY2F0ZWdvcnk6ICdWaXN1YWxpemVyJyxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICd2aXN1YWxpemVyJyxcclxuICAgICAgbmFtZTogJ0VuZXJneSBHcmFwaCcsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnVEhSTUwgZW5lcmd5IG92ZXIgdGltZScsXHJcbiAgICAgIGNvbmZpZzogeyB3aWR0aDogNTAwLCBoZWlnaHQ6IDMwMCwgYWN0aXZlOiB0cnVlIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ2VuZXJneScsIHR5cGU6ICdzY2FsYXInIH1dLFxyXG4gICAgICBvdXRwdXRzOiBbXSxcclxuICAgICAgY2F0ZWdvcnk6ICdWaXN1YWxpemVyJyxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICd2aXN1YWxpemVyJyxcclxuICAgICAgbmFtZTogJ1NwaW4gU3RhdGUgTWF0cml4JyxcclxuICAgICAgZGVzY3JpcHRpb246ICdUSFJNTCBzcGluIHZpc3VhbGl6YXRpb24nLFxyXG4gICAgICBjb25maWc6IHsgZ3JpZF9zaXplOiA4LCB3aWR0aDogNDAwLCBoZWlnaHQ6IDQwMCwgYWN0aXZlOiB0cnVlIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ3NwaW5zJywgdHlwZTogJ2Rpc2NyZXRlJyB9XSxcclxuICAgICAgb3V0cHV0czogW10sXHJcbiAgICAgIGNhdGVnb3J5OiAnVmlzdWFsaXplcicsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAndmlzdWFsaXplcicsXHJcbiAgICAgIG5hbWU6ICdDb3JyZWxhdGlvbiBNYXRyaXgnLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ05vZGUgY29ycmVsYXRpb24gaGVhdG1hcCcsXHJcbiAgICAgIGNvbmZpZzogeyBncmlkX3NpemU6IDgsIHdpZHRoOiA0MDAsIGhlaWdodDogNDAwLCBhY3RpdmU6IHRydWUgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAnY29ycmVsYXRpb25zJywgdHlwZTogJ21hdHJpeCcgfV0sXHJcbiAgICAgIG91dHB1dHM6IFtdLFxyXG4gICAgICBjYXRlZ29yeTogJ1Zpc3VhbGl6ZXInLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ3Zpc3VhbGl6ZXInLFxyXG4gICAgICBuYW1lOiAnV2F2ZWZvcm0gTW9uaXRvcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnU2luZ2xlLWNoYW5uZWwgd2F2ZWZvcm0nLFxyXG4gICAgICBjb25maWc6IHsgYnVmZmVyX3NpemU6IDUxMiwgd2lkdGg6IDQ1MCwgaGVpZ2h0OiAyNTAsIGFjdGl2ZTogdHJ1ZSB9LFxyXG4gICAgICBpbnB1dHM6IFt7IG5hbWU6ICdzaWduYWwnLCB0eXBlOiAnc2lnbmFsJyB9XSxcclxuICAgICAgb3V0cHV0czogW10sXHJcbiAgICAgIGNhdGVnb3J5OiAnVmlzdWFsaXplcicsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAndmlzdWFsaXplcicsXHJcbiAgICAgIG5hbWU6ICdYWSBQbG90JyxcclxuICAgICAgZGVzY3JpcHRpb246ICdMaXNzYWpvdXMgZmlndXJlIGRpc3BsYXknLFxyXG4gICAgICBjb25maWc6IHsgd2lkdGg6IDQ1MCwgaGVpZ2h0OiA0NTAsIGFjdGl2ZTogdHJ1ZSB9LFxyXG4gICAgICBpbnB1dHM6IFt7IG5hbWU6ICd4JywgdHlwZTogJ3NpZ25hbCcgfSwgeyBuYW1lOiAneScsIHR5cGU6ICdzaWduYWwnIH1dLFxyXG4gICAgICBvdXRwdXRzOiBbXSxcclxuICAgICAgY2F0ZWdvcnk6ICdWaXN1YWxpemVyJyxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICd2aXN1YWxpemVyJyxcclxuICAgICAgbmFtZTogJ1AtQml0IE1hcHBlcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnUC1iaXQgc3RhdGUgZ3JpZCB2aXN1YWxpemF0aW9uJyxcclxuICAgICAgY29uZmlnOiB7IGdyaWRfc2l6ZTogOCwgY29sb3Jfc2NoZW1lOiAncmVkLWdyZWVuJywgdXBkYXRlX3JhdGU6IDEwMCwgd2lkdGg6IDQwMCwgaGVpZ2h0OiA0MDAsIGFjdGl2ZTogdHJ1ZSB9LFxyXG4gICAgICBpbnB1dHM6IFt7IG5hbWU6ICdzdGF0ZXMnLCB0eXBlOiAnZGlzY3JldGUnIH1dLFxyXG4gICAgICBvdXRwdXRzOiBbXSxcclxuICAgICAgY2F0ZWdvcnk6ICdWaXN1YWxpemVyJyxcclxuICAgIH0sXHJcbiAgXSxcclxuXHJcbiAgbWxfbm9kZXM6IFtcclxuICAgIHtcclxuICAgICAgdHlwZTogJ21sJyxcclxuICAgICAgbmFtZTogJ01MUCBQcmVkaWN0b3InLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ011bHRpLWxheWVyIHBlcmNlcHRyb24gZm9yIHByZWRpY3Rpb24nLFxyXG4gICAgICBjb25maWc6IHsgXHJcbiAgICAgICAgaW5wdXRfZGltOiAxMCwgXHJcbiAgICAgICAgaGlkZGVuX2RpbXM6IFs2NCwgMzJdLCBcclxuICAgICAgICBvdXRwdXRfZGltOiAzLFxyXG4gICAgICAgIG1vZGVsX3BhdGg6IG51bGwsXHJcbiAgICAgICAgbGVhcm5pbmdfcmF0ZTogMC4wMDFcclxuICAgICAgfSxcclxuICAgICAgaW5wdXRzOiBbXHJcbiAgICAgICAgeyBuYW1lOiAnZmVhdHVyZXMnLCB0eXBlOiAnc2lnbmFsX2FycmF5JyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ3RyYWluX3RyaWdnZXInLCB0eXBlOiAnZGlzY3JldGUnIH1cclxuICAgICAgXSxcclxuICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ3ByZWRpY3Rpb24nLCB0eXBlOiAnc2lnbmFsX2FycmF5JyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ2xvc3MnLCB0eXBlOiAnc2NhbGFyJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIGNhdGVnb3J5OiAnTUwnLFxyXG4gICAgICBob3dJdFdvcmtzOiAnTXVsdGktbGF5ZXIgcGVyY2VwdHJvbiBuZXVyYWwgbmV0d29yayBmb3IgZ2VuZXJhbC1wdXJwb3NlIHByZWRpY3Rpb24uIEZlZWQgY2hhb3RpYyB0aW1lIHNlcmllcyBvciBhbnkgc2lnbmFsIGFycmF5IGludG8gZmVhdHVyZXMgaW5wdXQuIFByZWRpY3Rpb25zIGZsb3cgZnJvbSBvc2NpbGxhdG9yIHN0YXRlcyB0aHJvdWdoIGhpZGRlbiBsYXllcnMgdG8gb3V0cHV0LiBVc2UgdHJhaW5fdHJpZ2dlciB0byBlbmFibGUvZGlzYWJsZSBvbmxpbmUgbGVhcm5pbmcuIExvc3Mgb3V0cHV0IHRyYWNrcyBwcmVkaWN0aW9uIGVycm9yIGZvciBtb25pdG9yaW5nLidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdtbCcsXHJcbiAgICAgIG5hbWU6ICdDTk4gQ2xhc3NpZmllcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ29udm9sdXRpb25hbCBuZXVyYWwgbmV0d29yayBmb3IgcGF0dGVybiByZWNvZ25pdGlvbicsXHJcbiAgICAgIGNvbmZpZzogeyBcclxuICAgICAgICBjaGFubmVsczogWzE2LCAzMl0sIFxyXG4gICAgICAgIGtlcm5lbF9zaXplOiAzLFxyXG4gICAgICAgIG91dHB1dF9jbGFzc2VzOiA1LFxyXG4gICAgICAgIG1vZGVsX3BhdGg6IG51bGxcclxuICAgICAgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAndGltZV9zZXJpZXMnLCB0eXBlOiAnc2lnbmFsX2FycmF5JyB9XSxcclxuICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ2NsYXNzX3Byb2JzJywgdHlwZTogJ3NpZ25hbF9hcnJheScgfSxcclxuICAgICAgICB7IG5hbWU6ICdwcmVkaWN0ZWRfY2xhc3MnLCB0eXBlOiAnZGlzY3JldGUnIH1cclxuICAgICAgXSxcclxuICAgICAgY2F0ZWdvcnk6ICdNTCcsXHJcbiAgICAgIGhvd0l0V29ya3M6ICdDb252b2x1dGlvbmFsIG5ldXJhbCBuZXR3b3JrIGRlc2lnbmVkIGZvciB0aW1lLXNlcmllcyBwYXR0ZXJuIHJlY29nbml0aW9uLiBBdXRvbWF0aWNhbGx5IGxlYXJucyBoaWVyYXJjaGljYWwgZmVhdHVyZXMgZnJvbSBjaGFvdGljIG9zY2lsbGF0b3IgdHJhamVjdG9yaWVzLiBVc2VmdWwgZm9yIGNsYXNzaWZ5aW5nIGF0dHJhY3RvciByZWdpbWVzLCBkZXRlY3RpbmcgYmlmdXJjYXRpb25zLCBvciByZWNvZ25pemluZyBlbWVyZ2VudCBwYXR0ZXJucyBpbiBUSFJNTCBuZXR3b3Jrcy4gT3V0cHV0cyBjbGFzcyBwcm9iYWJpbGl0aWVzIGFuZCBtb3N0IGxpa2VseSBjbGFzcy4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnbWwnLFxyXG4gICAgICBuYW1lOiAnVHJhbnNmb3JtZXIgRW5jb2RlcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnQkVSVC1zdHlsZSB0cmFuc2Zvcm1lciBmb3Igc2VxdWVuY2UgcHJvY2Vzc2luZycsXHJcbiAgICAgIGNvbmZpZzogeyBcclxuICAgICAgICBtb2RlbF9uYW1lOiAnYmVydC1iYXNlJywgXHJcbiAgICAgICAgaGlkZGVuX3NpemU6IDc2OCxcclxuICAgICAgICBudW1faGVhZHM6IDEyLFxyXG4gICAgICAgIG51bV9sYXllcnM6IDZcclxuICAgICAgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAnc2VxdWVuY2UnLCB0eXBlOiAnc2lnbmFsX2FycmF5JyB9XSxcclxuICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ2VtYmVkZGluZ3MnLCB0eXBlOiAnc2lnbmFsX2FycmF5JyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ2F0dGVudGlvbl93ZWlnaHRzJywgdHlwZTogJ21hdHJpeCcgfVxyXG4gICAgICBdLFxyXG4gICAgICBjYXRlZ29yeTogJ01MJyxcclxuICAgICAgaG93SXRXb3JrczogJ1RyYW5zZm9ybWVyIGVuY29kZXIgd2l0aCBtdWx0aS1oZWFkIHNlbGYtYXR0ZW50aW9uIGZvciBwcm9jZXNzaW5nIHNlcXVlbnRpYWwgZGF0YSBmcm9tIG9zY2lsbGF0b3JzIG9yIFRIUk1MIHNhbXBsZXMuIENhcHR1cmVzIGxvbmctcmFuZ2UgZGVwZW5kZW5jaWVzIGluIGNoYW90aWMgZHluYW1pY3MuIENhbiBsZWFybiB0ZW1wb3JhbCBzdHJ1Y3R1cmUgaW4gbXVzaWMsIGRldGVjdCBwYXR0ZXJucyBpbiBuZXVyYWwgYWN0aXZpdHksIG9yIHByb2Nlc3MgYW55IHRpbWUtc2VyaWVzIGRhdGEuIEF0dGVudGlvbiB3ZWlnaHRzIHJldmVhbCB3aGljaCB0aW1lIHN0ZXBzIGluZmx1ZW5jZSBwcmVkaWN0aW9ucy4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnbWwnLFxyXG4gICAgICBuYW1lOiAnRGlmZnVzaW9uIEdlbmVyYXRvcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnRERQTS9ERElNIGRpZmZ1c2lvbiBtb2RlbCBmb3IgZ2VuZXJhdGlvbicsXHJcbiAgICAgIGNvbmZpZzogeyBcclxuICAgICAgICB0aW1lc3RlcHM6IDEwMDAsIFxyXG4gICAgICAgIGRhdGFfc2hhcGU6IFsxLCAyNTZdLFxyXG4gICAgICAgIGJldGFfc2NoZWR1bGU6ICdjb3NpbmUnLFxyXG4gICAgICAgIG51bV9pbmZlcmVuY2Vfc3RlcHM6IDUwXHJcbiAgICAgIH0sXHJcbiAgICAgIGlucHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ25vaXNlJywgdHlwZTogJ3NpZ25hbF9hcnJheScgfSwgXHJcbiAgICAgICAgeyBuYW1lOiAnZ3VpZGFuY2UnLCB0eXBlOiAnc2lnbmFsJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIG91dHB1dHM6IFt7IG5hbWU6ICdnZW5lcmF0ZWQnLCB0eXBlOiAnc2lnbmFsX2FycmF5JyB9XSxcclxuICAgICAgY2F0ZWdvcnk6ICdNTCcsXHJcbiAgICAgIGhvd0l0V29ya3M6ICdEaWZmdXNpb24gcHJvYmFiaWxpc3RpYyBtb2RlbCBmb3IgZ2VuZXJhdGluZyBub3ZlbCBwYXR0ZXJucy4gU3RhcnRzIGZyb20gcmFuZG9tIG5vaXNlIGFuZCBncmFkdWFsbHkgZGVub2lzZXMgdG8gY3JlYXRlIHN0cnVjdHVyZWQgb3V0cHV0cy4gR3VpZGFuY2UgaW5wdXQgYWxsb3dzIGNoYW9zIG9yIFRIUk1MIGVuZXJneSB0byBzdGVlciBnZW5lcmF0aW9uIHRvd2FyZCBzcGVjaWZpYyByZWdpb25zIG9mIHRoZSBsZWFybmVkIGRpc3RyaWJ1dGlvbi4gVXNlZnVsIGZvciBjcmVhdGl2ZSBzeW50aGVzaXMsIHBhdHRlcm4gZGlzY292ZXJ5LCBvciBkYXRhIGF1Z21lbnRhdGlvbi4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnbWwnLFxyXG4gICAgICBuYW1lOiAnR0FOIEdlbmVyYXRvcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnR2VuZXJhdGl2ZSBhZHZlcnNhcmlhbCBuZXR3b3JrJyxcclxuICAgICAgY29uZmlnOiB7IFxyXG4gICAgICAgIGxhdGVudF9kaW06IDEwMCwgXHJcbiAgICAgICAgb3V0cHV0X2xlbmd0aDogMjU2LFxyXG4gICAgICAgIGFyY2hpdGVjdHVyZTogJ2RjZ2FuJ1xyXG4gICAgICB9LFxyXG4gICAgICBpbnB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdsYXRlbnQnLCB0eXBlOiAnc2lnbmFsX2FycmF5JyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ2NoYW9zX25vaXNlJywgdHlwZTogJ3NpZ25hbCcgfVxyXG4gICAgICBdLFxyXG4gICAgICBvdXRwdXRzOiBbeyBuYW1lOiAnZ2VuZXJhdGVkJywgdHlwZTogJ3NpZ25hbF9hcnJheScgfV0sXHJcbiAgICAgIGNhdGVnb3J5OiAnTUwnLFxyXG4gICAgICBob3dJdFdvcmtzOiAnR2VuZXJhdGl2ZSBhZHZlcnNhcmlhbCBuZXR3b3JrIHRyYWluZWQgdG8gcHJvZHVjZSByZWFsaXN0aWMgcGF0dGVybnMuIExhdGVudCBpbnB1dCBjb250cm9scyBnZW5lcmF0aW9uIHN0eWxlLiBDaGFvc19ub2lzZSBpbnB1dCBjYW4gdXNlIGNoYW90aWMgb3NjaWxsYXRvcnMgYXMgYSB1bmlxdWUgbm9pc2Ugc291cmNlLCBjcmVhdGluZyBkaXZlcnNlIG91dHB1dHMgdGhhdCB0cmFkaXRpb25hbCBHQU5zIGNhbm5vdCBwcm9kdWNlLiBFeGNlbGxlbnQgZm9yIHNwcml0ZSBnZW5lcmF0aW9uLCB3b3JsZCBjcmVhdGlvbiwgb3Igbm92ZWwgcGF0dGVybiBzeW50aGVzaXMuJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ21sJyxcclxuICAgICAgbmFtZTogJ1JMIENvbnRyb2xsZXInLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ1BQTy9TQUMgcmVpbmZvcmNlbWVudCBsZWFybmluZyBhZ2VudCcsXHJcbiAgICAgIGNvbmZpZzogeyBcclxuICAgICAgICBzdGF0ZV9kaW06IDMsIFxyXG4gICAgICAgIGFjdGlvbl9kaW06IDEsIFxyXG4gICAgICAgIGFsZ29yaXRobTogJ3BwbycsXHJcbiAgICAgICAgbGVhcm5pbmdfcmF0ZTogMC4wMDAzLFxyXG4gICAgICAgIGdhbW1hOiAwLjk5XHJcbiAgICAgIH0sXHJcbiAgICAgIGlucHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ3N0YXRlJywgdHlwZTogJ3NpZ25hbF9hcnJheScgfSwgXHJcbiAgICAgICAgeyBuYW1lOiAncmV3YXJkJywgdHlwZTogJ3NjYWxhcicgfVxyXG4gICAgICBdLFxyXG4gICAgICBvdXRwdXRzOiBbXHJcbiAgICAgICAgeyBuYW1lOiAnYWN0aW9uJywgdHlwZTogJ3NpZ25hbCcgfSxcclxuICAgICAgICB7IG5hbWU6ICd2YWx1ZScsIHR5cGU6ICdzY2FsYXInIH1cclxuICAgICAgXSxcclxuICAgICAgY2F0ZWdvcnk6ICdNTCcsXHJcbiAgICAgIGhvd0l0V29ya3M6ICdSZWluZm9yY2VtZW50IGxlYXJuaW5nIGFnZW50IHRoYXQgbGVhcm5zIHRvIGNvbnRyb2wgc3lzdGVtcyB0aHJvdWdoIHRyaWFsIGFuZCBlcnJvci4gRmVlZCBvc2NpbGxhdG9yIHN0YXRlcyBhcyBvYnNlcnZhdGlvbnMsIGRlZmluZSByZXdhcmRzIChlLmcuLCBlbmVyZ3kgbWluaW1pemF0aW9uLCBzdGFiaWxpdHkpLCBhbmQgdGhlIGFnZW50IGxlYXJucyBvcHRpbWFsIGNvbnRyb2wgcG9saWNpZXMuIE91dHB1dCBhY3Rpb25zIG1vZHVsYXRlIG9zY2lsbGF0b3IgcGFyYW1ldGVycy4gVmFsdWUgZXN0aW1hdGVzIHRyYWNrIGV4cGVjdGVkIGZ1dHVyZSByZXdhcmRzLidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdtbCcsXHJcbiAgICAgIG5hbWU6ICdBdXRvZW5jb2RlcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnRGltZW5zaW9uYWxpdHkgcmVkdWN0aW9uIGFuZCBjb21wcmVzc2lvbicsXHJcbiAgICAgIGNvbmZpZzogeyBcclxuICAgICAgICBpbnB1dF9kaW06IDEwMCwgXHJcbiAgICAgICAgbGF0ZW50X2RpbTogMTAsXHJcbiAgICAgICAgYXJjaGl0ZWN0dXJlOiAndmFuaWxsYSdcclxuICAgICAgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAnaW5wdXQnLCB0eXBlOiAnc2lnbmFsX2FycmF5JyB9XSxcclxuICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ2xhdGVudCcsIHR5cGU6ICdzaWduYWxfYXJyYXknIH0sXHJcbiAgICAgICAgeyBuYW1lOiAncmVjb25zdHJ1Y3RlZCcsIHR5cGU6ICdzaWduYWxfYXJyYXknIH1cclxuICAgICAgXSxcclxuICAgICAgY2F0ZWdvcnk6ICdNTCcsXHJcbiAgICAgIGhvd0l0V29ya3M6ICdBdXRvZW5jb2RlciBjb21wcmVzc2VzIGhpZ2gtZGltZW5zaW9uYWwgZGF0YSBpbnRvIGxvdy1kaW1lbnNpb25hbCBsYXRlbnQgcmVwcmVzZW50YXRpb25zLiBVc2VmdWwgZm9yIHZpc3VhbGl6aW5nIGF0dHJhY3RvciBzdHJ1Y3R1cmVzLCBmaW5kaW5nIGNvbXBhY3QgcmVwcmVzZW50YXRpb25zIG9mIFRIUk1MIHN0YXRlcywgb3IgcHJlcHJvY2Vzc2luZyBmb3Igb3RoZXIgTUwgbW9kZWxzLiBMYXRlbnQgb3V0cHV0IHJldmVhbHMgaW50cmluc2ljIGRpbWVuc2lvbmFsaXR5IG9mIGNoYW90aWMgZHluYW1pY3MuJ1xyXG4gICAgfVxyXG4gIF0sXHJcblxyXG4gIGFuYWx5c2lzX25vZGVzOiBbXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdhbmFseXNpcycsXHJcbiAgICAgIG5hbWU6ICdGRlQgQW5hbHl6ZXInLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ0Zhc3QgRm91cmllciBUcmFuc2Zvcm0gc3BlY3RyYWwgYW5hbHlzaXMnLFxyXG4gICAgICBjb25maWc6IHsgXHJcbiAgICAgICAgc2l6ZTogMjA0OCwgXHJcbiAgICAgICAgd2luZG93OiAnaGFubicsXHJcbiAgICAgICAgb3ZlcmxhcDogMC41XHJcbiAgICAgIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ3NpZ25hbCcsIHR5cGU6ICdzaWduYWwnIH1dLFxyXG4gICAgICBvdXRwdXRzOiBbXHJcbiAgICAgICAgeyBuYW1lOiAnbWFnbml0dWRlJywgdHlwZTogJ3NpZ25hbF9hcnJheScgfSxcclxuICAgICAgICB7IG5hbWU6ICdwaGFzZScsIHR5cGU6ICdzaWduYWxfYXJyYXknIH0sXHJcbiAgICAgICAgeyBuYW1lOiAncGVha19mcmVxJywgdHlwZTogJ3NjYWxhcicgfSxcclxuICAgICAgICB7IG5hbWU6ICdzcGVjdHJhbF9jZW50cm9pZCcsIHR5cGU6ICdzY2FsYXInIH1cclxuICAgICAgXSxcclxuICAgICAgY2F0ZWdvcnk6ICdBbmFseXNpcycsXHJcbiAgICAgIGhvd0l0V29ya3M6ICdUcmFuc2Zvcm1zIHRpbWUtZG9tYWluIHNpZ25hbHMgdG8gZnJlcXVlbmN5IGRvbWFpbiB1c2luZyBGYXN0IEZvdXJpZXIgVHJhbnNmb3JtLiBSZXZlYWxzIGhhcm1vbmljIHN0cnVjdHVyZSwgZG9taW5hbnQgZnJlcXVlbmNpZXMsIGFuZCBzcGVjdHJhbCBjb250ZW50IG9mIG9zY2lsbGF0b3Igb3V0cHV0cyBvciBhdWRpbyBzaWduYWxzLiBQZWFrIGZyZXF1ZW5jeSB0cmFja3MgdGhlIHN0cm9uZ2VzdCBzcGVjdHJhbCBjb21wb25lbnQuIFNwZWN0cmFsIGNlbnRyb2lkIGluZGljYXRlcyBicmlnaHRuZXNzIG9yIGNlbnRlciBvZiBtYXNzIG9mIHRoZSBzcGVjdHJ1bS4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnYW5hbHlzaXMnLFxyXG4gICAgICBuYW1lOiAnUGF0dGVybiBSZWNvZ25pemVyJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdEZXRlY3QgcmVwZWF0aW5nIHBhdHRlcm5zIGluIHRpbWUgc2VyaWVzJyxcclxuICAgICAgY29uZmlnOiB7IFxyXG4gICAgICAgIHdpbmRvd19zaXplOiAxMDAsIFxyXG4gICAgICAgIHRocmVzaG9sZDogMC44LFxyXG4gICAgICAgIG51bV9wYXR0ZXJuczogMTBcclxuICAgICAgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAnc2lnbmFsJywgdHlwZTogJ3NpZ25hbCcgfV0sXHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdwYXR0ZXJucycsIHR5cGU6ICdkaXNjcmV0ZScgfSwgXHJcbiAgICAgICAgeyBuYW1lOiAnY29uZmlkZW5jZScsIHR5cGU6ICdzY2FsYXInIH0sXHJcbiAgICAgICAgeyBuYW1lOiAncGVyaW9kJywgdHlwZTogJ3NjYWxhcicgfVxyXG4gICAgICBdLFxyXG4gICAgICBjYXRlZ29yeTogJ0FuYWx5c2lzJyxcclxuICAgICAgaG93SXRXb3JrczogJ1VzZXMgYXV0b2NvcnJlbGF0aW9uIGFuZCB0ZW1wbGF0ZSBtYXRjaGluZyB0byBpZGVudGlmeSByZXBlYXRpbmcgcGF0dGVybnMgaW4gY2hhb3RpYyBvciBwZXJpb2RpYyBzaWduYWxzLiBPdXRwdXRzIGRldGVjdGVkIHBhdHRlcm4gSURzLCBjb25maWRlbmNlIHNjb3JlcywgYW5kIGVzdGltYXRlZCBwZXJpb2RzLiBVc2VmdWwgZm9yIGZpbmRpbmcgcXVhc2ktcGVyaW9kaWMgb3JiaXRzLCBkZXRlY3RpbmcgYmlmdXJjYXRpb25zLCBvciBpZGVudGlmeWluZyBtdXNpY2FsIG1vdGlmcyBpbiBnZW5lcmF0ZWQgYXVkaW8uJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2FuYWx5c2lzJyxcclxuICAgICAgbmFtZTogJ0x5YXB1bm92IENhbGN1bGF0b3InLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ0NvbXB1dGUgbGFyZ2VzdCBMeWFwdW5vdiBleHBvbmVudCcsXHJcbiAgICAgIGNvbmZpZzogeyBcclxuICAgICAgICB3aW5kb3c6IDEwMDAsIFxyXG4gICAgICAgIG5laWdoYm9yczogMTAsXHJcbiAgICAgICAgZW1iZWRkaW5nX2RpbTogM1xyXG4gICAgICB9LFxyXG4gICAgICBpbnB1dHM6IFt7IG5hbWU6ICd0cmFqZWN0b3J5JywgdHlwZTogJ3NpZ25hbF9hcnJheScgfV0sXHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdseWFwdW5vdicsIHR5cGU6ICdzY2FsYXInIH0sIFxyXG4gICAgICAgIHsgbmFtZTogJ2lzX2NoYW90aWMnLCB0eXBlOiAnZGlzY3JldGUnIH1cclxuICAgICAgXSxcclxuICAgICAgY2F0ZWdvcnk6ICdBbmFseXNpcycsXHJcbiAgICAgIGhvd0l0V29ya3M6ICdDYWxjdWxhdGVzIHRoZSBsYXJnZXN0IEx5YXB1bm92IGV4cG9uZW50IHRvIHF1YW50aWZ5IGNoYW9zLiBQb3NpdGl2ZSBleHBvbmVudHMgaW5kaWNhdGUgY2hhb3RpYyBkeW5hbWljcyAoc2Vuc2l0aXZlIGRlcGVuZGVuY2Ugb24gaW5pdGlhbCBjb25kaXRpb25zKSwgemVybyBpbmRpY2F0ZXMgbWFyZ2luYWwgc3RhYmlsaXR5LCBuZWdhdGl2ZSBpbmRpY2F0ZXMgY29udmVyZ2VuY2UuIElzX2NoYW90aWMgb3V0cHV0IHByb3ZpZGVzIGJpbmFyeSBjbGFzc2lmaWNhdGlvbi4gRXNzZW50aWFsIGZvciBhbmFseXppbmcgZHluYW1pY2FsIHJlZ2ltZSB0cmFuc2l0aW9ucy4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnYW5hbHlzaXMnLFxyXG4gICAgICBuYW1lOiAnQXR0cmFjdG9yIEFuYWx5emVyJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdDaGFyYWN0ZXJpemUgc3RyYW5nZSBhdHRyYWN0b3JzJyxcclxuICAgICAgY29uZmlnOiB7IFxyXG4gICAgICAgIGVtYmVkZGluZ19kaW06IDMsXHJcbiAgICAgICAgdGltZV9kZWxheTogMTBcclxuICAgICAgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAndGltZV9zZXJpZXMnLCB0eXBlOiAnc2lnbmFsX2FycmF5JyB9XSxcclxuICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ2NvcnJlbGF0aW9uX2RpbScsIHR5cGU6ICdzY2FsYXInIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnZW50cm9weScsIHR5cGU6ICdzY2FsYXInIH1cclxuICAgICAgXSxcclxuICAgICAgY2F0ZWdvcnk6ICdBbmFseXNpcycsXHJcbiAgICAgIGhvd0l0V29ya3M6ICdSZWNvbnN0cnVjdHMgcGhhc2Ugc3BhY2UgdXNpbmcgdGltZS1kZWxheSBlbWJlZGRpbmcgYW5kIGVzdGltYXRlcyBhdHRyYWN0b3IgcHJvcGVydGllcy4gQ29ycmVsYXRpb24gZGltZW5zaW9uIHJldmVhbHMgZnJhY3RhbCBzdHJ1Y3R1cmUuIEVudHJvcHkgcXVhbnRpZmllcyB1bnByZWRpY3RhYmlsaXR5LiBIZWxwcyBjbGFzc2lmeSBvc2NpbGxhdG9yIHJlZ2ltZXMgYW5kIGRldGVjdCB0cmFuc2l0aW9ucyBiZXR3ZWVuIHBlcmlvZGljLCBxdWFzaS1wZXJpb2RpYywgYW5kIGNoYW90aWMgYmVoYXZpb3IuJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2FuYWx5c2lzJyxcclxuICAgICAgbmFtZTogJ0VuZXJneSBTdXJmYWNlIFNjYW5uZXInLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ01hcCBhbmQgYW5hbHl6ZSBUSFJNTCBlbmVyZ3kgbGFuZHNjYXBlJyxcclxuICAgICAgY29uZmlnOiB7IFxyXG4gICAgICAgIHNjYW5fcmVzb2x1dGlvbjogMzIsXHJcbiAgICAgICAgbnVtX3NhbXBsZXM6IDEwMDAsXHJcbiAgICAgICAgY29tcHV0ZV9iYXJyaWVyczogdHJ1ZVxyXG4gICAgICB9LFxyXG4gICAgICBpbnB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdtb2RlbF9zdGF0ZScsIHR5cGU6ICdkaXNjcmV0ZScgfSxcclxuICAgICAgICB7IG5hbWU6ICd3ZWlnaHRzJywgdHlwZTogJ21hdHJpeCcgfVxyXG4gICAgICBdLFxyXG4gICAgICBvdXRwdXRzOiBbXHJcbiAgICAgICAgeyBuYW1lOiAnZW5lcmd5X2hpc3RvZ3JhbScsIHR5cGU6ICdzaWduYWxfYXJyYXknIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnbWluX2VuZXJneScsIHR5cGU6ICdzY2FsYXInIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnbWF4X2VuZXJneScsIHR5cGU6ICdzY2FsYXInIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnZW5lcmd5X2JhcnJpZXJzJywgdHlwZTogJ3NpZ25hbF9hcnJheScgfVxyXG4gICAgICBdLFxyXG4gICAgICBjYXRlZ29yeTogJ0FuYWx5c2lzJyxcclxuICAgICAgaG93SXRXb3JrczogJ1NhbXBsZXMgdGhlIGVuZXJneSBsYW5kc2NhcGUgdG8gZmluZCBtaW5pbWEsIGJhcnJpZXJzLCBhbmQgbWV0YXN0YWJsZSBzdGF0ZXMuIFVzZWZ1bCBmb3IgdW5kZXJzdGFuZGluZyBtb2RlbCBjYXBhY2l0eSwgZGV0ZWN0aW5nIG1vZGUgY29sbGFwc2UsIG9yIGZpbmRpbmcgZ3JvdW5kIHN0YXRlcy4gRW5lcmd5IGJhcnJpZXJzIGluZGljYXRlIGRpZmZpY3VsdHkgb2YgbWl4aW5nIGJldHdlZW4gbW9kZXMuIFNjYW5fcmVzb2x1dGlvbiBjb250cm9scyBncmFudWxhcml0eSBvZiBsYW5kc2NhcGUgbWFwcGluZy4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnYW5hbHlzaXMnLFxyXG4gICAgICBuYW1lOiAnQ29udmVyZ2VuY2UgRGV0ZWN0b3InLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ0VzdGltYXRlIE1DTUMgbWl4aW5nIGFuZCBjb252ZXJnZW5jZSB0aW1lJyxcclxuICAgICAgY29uZmlnOiB7IFxyXG4gICAgICAgIGNoZWNrX2ludGVydmFsOiAxMDAsXHJcbiAgICAgICAgbWF4X2xhZzogNTAsXHJcbiAgICAgICAgdGhyZXNob2xkOiAwLjAxXHJcbiAgICAgIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ3NhbXBsZV9zdHJlYW0nLCB0eXBlOiAnZGlzY3JldGUnIH1dLFxyXG4gICAgICBvdXRwdXRzOiBbXHJcbiAgICAgICAgeyBuYW1lOiAnbWl4aW5nX3RpbWUnLCB0eXBlOiAnc2NhbGFyJyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ2NvbnZlcmdlZCcsIHR5cGU6ICdkaXNjcmV0ZScgfSxcclxuICAgICAgICB7IG5hbWU6ICdhdXRvY29ycl9mdW5jJywgdHlwZTogJ3NpZ25hbF9hcnJheScgfVxyXG4gICAgICBdLFxyXG4gICAgICBjYXRlZ29yeTogJ0FuYWx5c2lzJyxcclxuICAgICAgaG93SXRXb3JrczogJ0VzdGltYXRlcyBob3cgbG9uZyBpdCB0YWtlcyBmb3IgdGhlIGNoYWluIHRvIGZvcmdldCBpbml0aWFsIGNvbmRpdGlvbnMuIFRyYWNrcyBhdXRvY29ycmVsYXRpb24gZnVuY3Rpb24gZGVjYXkuIFNpZ25hbHMgY29udmVyZ2VuY2Ugd2hlbiBhdXRvY29ycmVsYXRpb24gZHJvcHMgYmVsb3cgdGhyZXNob2xkLiBDcml0aWNhbCBmb3Iga25vd2luZyB3aGVuIHRvIHRydXN0IHlvdXIgc2FtcGxlcy4gTWF4X2xhZyBzZXRzIGhvdyBmYXIgYmFjayB0byBsb29rIGZvciBjb3JyZWxhdGlvbnMuJ1xyXG4gICAgfVxyXG4gIF0sXHJcblxyXG4gIGNvbnRyb2xfbm9kZXM6IFtcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2NvbnRyb2wnLFxyXG4gICAgICBuYW1lOiAnUGFyYW1ldGVyIE9wdGltaXplcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnR3JhZGllbnQtYmFzZWQgcGFyYW1ldGVyIG9wdGltaXphdGlvbicsXHJcbiAgICAgIGNvbmZpZzogeyBcclxuICAgICAgICBsZWFybmluZ19yYXRlOiAwLjAxLCBcclxuICAgICAgICB0YXJnZXRfbWV0cmljOiAnZW5lcmd5JyxcclxuICAgICAgICBvcHRpbWl6ZXI6ICdhZGFtJyxcclxuICAgICAgICBtb21lbnR1bTogMC45XHJcbiAgICAgIH0sXHJcbiAgICAgIGlucHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ2N1cnJlbnRfdmFsdWUnLCB0eXBlOiAnc2NhbGFyJyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ3RhcmdldF92YWx1ZScsIHR5cGU6ICdzY2FsYXInIH1cclxuICAgICAgXSxcclxuICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgIHsgbmFtZTogJ2NvbnRyb2xfc2lnbmFsJywgdHlwZTogJ3NpZ25hbCcgfSxcclxuICAgICAgICB7IG5hbWU6ICdlcnJvcicsIHR5cGU6ICdzY2FsYXInIH1cclxuICAgICAgXSxcclxuICAgICAgY2F0ZWdvcnk6ICdDb250cm9sJyxcclxuICAgICAgaG93SXRXb3JrczogJ0dyYWRpZW50IGRlc2NlbnQgY29udHJvbGxlciB0aGF0IGFkanVzdHMgcGFyYW1ldGVycyB0byBtaW5pbWl6ZSBlcnJvciBiZXR3ZWVuIGN1cnJlbnQgYW5kIHRhcmdldCB2YWx1ZXMuIENhbiBvcHRpbWl6ZSBUSFJNTCBlbmVyZ3ksIHN0YWJpbGl6ZSBvc2NpbGxhdG9ycywgb3IgdHVuZSBhbnkgY29udGludW91cyBwYXJhbWV0ZXIuIFN1cHBvcnRzIG11bHRpcGxlIG9wdGltaXplcnMgKFNHRCwgQWRhbSwgUk1TcHJvcCkuIEVycm9yIG91dHB1dCB0cmFja3MgY29udmVyZ2VuY2UgcHJvZ3Jlc3MuJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2NvbnRyb2wnLFxyXG4gICAgICBuYW1lOiAnQ2hhb3MgQ29udHJvbGxlcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ29udHJvbCBhbmQgc3RhYmlsaXplIGNoYW90aWMgZHluYW1pY3MnLFxyXG4gICAgICBjb25maWc6IHsgXHJcbiAgICAgICAgbWV0aG9kOiAncHlyYWdhcycsIFxyXG4gICAgICAgIHN0cmVuZ3RoOiAwLjEsXHJcbiAgICAgICAgZGVsYXk6IDEwMFxyXG4gICAgICB9LFxyXG4gICAgICBpbnB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdzdGF0ZScsIHR5cGU6ICdzaWduYWxfYXJyYXknIH0sIFxyXG4gICAgICAgIHsgbmFtZTogJ3RhcmdldCcsIHR5cGU6ICdzaWduYWxfYXJyYXknIH1cclxuICAgICAgXSxcclxuICAgICAgb3V0cHV0czogW3sgbmFtZTogJ2NvbnRyb2wnLCB0eXBlOiAnc2lnbmFsX2FycmF5JyB9XSxcclxuICAgICAgY2F0ZWdvcnk6ICdDb250cm9sJyxcclxuICAgICAgaG93SXRXb3JrczogJ0ltcGxlbWVudHMgUHlyYWdhcyBvciBPR1kgY2hhb3MgY29udHJvbCBtZXRob2RzLiBTdGFiaWxpemVzIHVuc3RhYmxlIHBlcmlvZGljIG9yYml0cyBlbWJlZGRlZCBpbiBjaGFvdGljIGF0dHJhY3RvcnMgdXNpbmcgc21hbGwgcGVydHVyYmF0aW9ucy4gRGVsYXkgcGFyYW1ldGVyIHNldHMgdGhlIGZlZWRiYWNrIHRpbWUgc2NhbGUuIFVzZWZ1bCBmb3IgdGFtaW5nIGNoYW9zIHdoZW4gbmVlZGVkIG9yIG5hdmlnYXRpbmcgYmV0d2VlbiBkaWZmZXJlbnQgZHluYW1pY2FsIHJlZ2ltZXMuJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2NvbnRyb2wnLFxyXG4gICAgICBuYW1lOiAnUElEIENvbnRyb2xsZXInLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ1Byb3BvcnRpb25hbC1JbnRlZ3JhbC1EZXJpdmF0aXZlIGZlZWRiYWNrIGNvbnRyb2wnLFxyXG4gICAgICBjb25maWc6IHsgXHJcbiAgICAgICAgS3A6IDEuMCwgXHJcbiAgICAgICAgS2k6IDAuMSwgXHJcbiAgICAgICAgS2Q6IDAuMDEsXHJcbiAgICAgICAgc2V0cG9pbnQ6IDAuMFxyXG4gICAgICB9LFxyXG4gICAgICBpbnB1dHM6IFt7IG5hbWU6ICdtZWFzdXJlbWVudCcsIHR5cGU6ICdzaWduYWwnIH1dLFxyXG4gICAgICBvdXRwdXRzOiBbXHJcbiAgICAgICAgeyBuYW1lOiAnY29udHJvbCcsIHR5cGU6ICdzaWduYWwnIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnZXJyb3InLCB0eXBlOiAnc2NhbGFyJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIGNhdGVnb3J5OiAnQ29udHJvbCcsXHJcbiAgICAgIGhvd0l0V29ya3M6ICdDbGFzc2ljIFBJRCBjb250cm9sbGVyIGZvciBtYWludGFpbmluZyBhIGRlc2lyZWQgc2V0cG9pbnQuIFByb3BvcnRpb25hbCB0ZXJtIHJlc3BvbmRzIHRvIGN1cnJlbnQgZXJyb3IsIGludGVncmFsIHRlcm0gZWxpbWluYXRlcyBzdGVhZHktc3RhdGUgZXJyb3IsIGRlcml2YXRpdmUgdGVybSByZWR1Y2VzIG92ZXJzaG9vdC4gVHVuZSBLcCwgS2ksIEtkIGZvciBzdGFiaWxpdHkuIEFwcGxpY2FibGUgdG8gb3NjaWxsYXRvciBjb250cm9sLCBUSFJNTCB0ZW1wZXJhdHVyZSByZWd1bGF0aW9uLCBvciBhbnkgZmVlZGJhY2sgc3lzdGVtLidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdjb250cm9sJyxcclxuICAgICAgbmFtZTogJ0FkYXB0aXZlIEdpYmJzIFN0ZXBzJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdEeW5hbWljYWxseSBhZGp1c3QgbnVtYmVyIG9mIHNhbXBsaW5nIHN0ZXBzJyxcclxuICAgICAgY29uZmlnOiB7IFxyXG4gICAgICAgIG1pbl9zdGVwczogMSxcclxuICAgICAgICBtYXhfc3RlcHM6IDUwLFxyXG4gICAgICAgIHRhcmdldF9hY2NlcHRhbmNlOiAwLjUsXHJcbiAgICAgICAgYWRhcHRhdGlvbl9yYXRlOiAwLjFcclxuICAgICAgfSxcclxuICAgICAgaW5wdXRzOiBbXHJcbiAgICAgICAgeyBuYW1lOiAnY3VycmVudF9hY2NlcHRhbmNlJywgdHlwZTogJ3NjYWxhcicgfSxcclxuICAgICAgICB7IG5hbWU6ICdlcnJvcl9zaWduYWwnLCB0eXBlOiAnc2NhbGFyJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICduX3N0ZXBzJywgdHlwZTogJ3NjYWxhcicgfSxcclxuICAgICAgICB7IG5hbWU6ICdzdGVwX3NpemUnLCB0eXBlOiAnc2NhbGFyJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIGNhdGVnb3J5OiAnQ29udHJvbCcsXHJcbiAgICAgIGhvd0l0V29ya3M6ICdBdXRvbWF0aWNhbGx5IHR1bmVzIHNhbXBsaW5nIHN0ZXBzIGJhc2VkIG9uIGFjY2VwdGFuY2UgcmF0ZSBhbmQgZXJyb3IgbWV0cmljcy4gTW9yZSBzdGVwcyB3aGVuIGFjY2VwdGFuY2UgaXMgbG93IChwb29yIG1peGluZykuIEZld2VyIHN0ZXBzIHdoZW4gYWNjZXB0YW5jZSBpcyBnb29kIChlZmZpY2llbnQgc2FtcGxpbmcpLiBTYXZlcyBjb21wdXRhdGlvbiB3aGlsZSBtYWludGFpbmluZyBxdWFsaXR5LiBBZGFwdGF0aW9uX3JhdGUgY29udHJvbHMgaG93IHF1aWNrbHkgdGhlIGNvbnRyb2xsZXIgcmVzcG9uZHMgdG8gY2hhbmdlcy4nXHJcbiAgICB9XHJcbiAgXSxcclxuXHJcbiAgZ2VuZXJhdG9yX25vZGVzOiBbXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdnZW5lcmF0b3InLFxyXG4gICAgICBuYW1lOiAnTm9pc2UgR2VuZXJhdG9yJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdHZW5lcmF0ZSB2YXJpb3VzIHR5cGVzIG9mIG5vaXNlJyxcclxuICAgICAgY29uZmlnOiB7IFxyXG4gICAgICAgIHR5cGU6ICd3aGl0ZScsIFxyXG4gICAgICAgIGFtcGxpdHVkZTogMS4wLFxyXG4gICAgICAgIHNlZWQ6IDQyXHJcbiAgICAgIH0sXHJcbiAgICAgIGlucHV0czogW3sgbmFtZTogJ2FtcGxpdHVkZV9tb2QnLCB0eXBlOiAnc2lnbmFsJyB9XSxcclxuICAgICAgb3V0cHV0czogW3sgbmFtZTogJ25vaXNlJywgdHlwZTogJ3NpZ25hbCcgfV0sXHJcbiAgICAgIGNhdGVnb3J5OiAnR2VuZXJhdG9yJyxcclxuICAgICAgaG93SXRXb3JrczogJ0dlbmVyYXRlcyBub2lzZSBzaWduYWxzOiB3aGl0ZSAoZmxhdCBzcGVjdHJ1bSksIHBpbmsgKDEvZiksIGJyb3duICgxL2bCsiksIG9yIHBlcmxpbiAoc21vb3RoKS4gQW1wbGl0dWRlIG1vZHVsYXRpb24gaW5wdXQgYWxsb3dzIGR5bmFtaWMgY29udHJvbC4gVXNlZnVsIGZvciB0ZXN0aW5nIHN5c3RlbXMsIGFkZGluZyBzdG9jaGFzdGljaXR5LCBvciBhcyBpbnB1dCB0byBnZW5lcmF0aXZlIG1vZGVscy4gU2VlZCBlbnN1cmVzIHJlcHJvZHVjaWJpbGl0eS4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnZ2VuZXJhdG9yJyxcclxuICAgICAgbmFtZTogJ1BhdHRlcm4gR2VuZXJhdG9yJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdHZW5lcmF0ZSB0ZXN0IHNpZ25hbHMgYW5kIHBhdHRlcm5zJyxcclxuICAgICAgY29uZmlnOiB7IFxyXG4gICAgICAgIHBhdHRlcm46ICdzaW5lJywgXHJcbiAgICAgICAgZnJlcXVlbmN5OiA0NDAsXHJcbiAgICAgICAgYW1wbGl0dWRlOiAxLjAsXHJcbiAgICAgICAgcGhhc2U6IDAuMFxyXG4gICAgICB9LFxyXG4gICAgICBpbnB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdmcmVxX21vZCcsIHR5cGU6ICdzaWduYWwnIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnYW1wX21vZCcsIHR5cGU6ICdzaWduYWwnIH1cclxuICAgICAgXSxcclxuICAgICAgb3V0cHV0czogW3sgbmFtZTogJ3BhdHRlcm4nLCB0eXBlOiAnc2lnbmFsJyB9XSxcclxuICAgICAgY2F0ZWdvcnk6ICdHZW5lcmF0b3InLFxyXG4gICAgICBob3dJdFdvcmtzOiAnR2VuZXJhdGVzIHN0YW5kYXJkIHRlc3Qgc2lnbmFsczogc2luZSwgc3F1YXJlLCB0cmlhbmdsZSwgc2F3dG9vdGgsIG9yIGN1c3RvbSBwYXR0ZXJucy4gRnJlcXVlbmN5IGFuZCBhbXBsaXR1ZGUgY2FuIGJlIG1vZHVsYXRlZCBpbiByZWFsLXRpbWUuIEVzc2VudGlhbCBmb3IgdGVzdGluZywgY2FsaWJyYXRpb24sIG9yIGFzIGRyaXZpbmcgZm9yY2VzIGZvciBvc2NpbGxhdG9ycy4gUGhhc2UgcGFyYW1ldGVyIHNldHMgaW5pdGlhbCBvZmZzZXQuJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2dlbmVyYXRvcicsXHJcbiAgICAgIG5hbWU6ICdTZXF1ZW5jZSBHZW5lcmF0b3InLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ0dlbmVyYXRlIHN0cnVjdHVyZWQgc2VxdWVuY2VzJyxcclxuICAgICAgY29uZmlnOiB7IFxyXG4gICAgICAgIGxlbmd0aDogMTAwLFxyXG4gICAgICAgIHBhdHRlcm5fdHlwZTogJ2FyaXRobWV0aWMnLFxyXG4gICAgICAgIHN0YXJ0OiAwLFxyXG4gICAgICAgIHN0ZXA6IDFcclxuICAgICAgfSxcclxuICAgICAgaW5wdXRzOiBbeyBuYW1lOiAndHJpZ2dlcicsIHR5cGU6ICdkaXNjcmV0ZScgfV0sXHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7IG5hbWU6ICdzZXF1ZW5jZScsIHR5cGU6ICdzaWduYWxfYXJyYXknIH0sXHJcbiAgICAgICAgeyBuYW1lOiAncG9zaXRpb24nLCB0eXBlOiAnc2NhbGFyJyB9XHJcbiAgICAgIF0sXHJcbiAgICAgIGNhdGVnb3J5OiAnR2VuZXJhdG9yJyxcclxuICAgICAgaG93SXRXb3JrczogJ0NyZWF0ZXMgc3RydWN0dXJlZCBudW1iZXIgc2VxdWVuY2VzOiBhcml0aG1ldGljIHByb2dyZXNzaW9ucywgZ2VvbWV0cmljIHNlcmllcywgZmlib25hY2NpLCBvciBjdXN0b20gcGF0dGVybnMuIFRyaWdnZXIgaW5wdXQgcmVzdGFydHMgc2VxdWVuY2UuIFVzZWZ1bCBmb3IgZ2VuZXJhdGluZyB0ZXN0IGRhdGEsIGNyZWF0aW5nIHJoeXRobWljIHBhdHRlcm5zLCBvciBwcm92aWRpbmcgY29udHJvbGxlZCBpbnB1dHMgdG8gTUwgbW9kZWxzIG9yIG9zY2lsbGF0b3JzLidcclxuICAgIH1cclxuICBdLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEFMR09SSVRITV9JRFMgPSB7XHJcbiAgLy8gQXVkaW8vU2lnbmFsIFByb2Nlc3NpbmcgKDAtNilcclxuICBQQVNTVEhST1VHSDogMCxcclxuICBUQU5IX1NBVFVSQVRFOiAxLFxyXG4gIFNPRlRfQ0xJUDogMixcclxuICBGT0xEOiAzLFxyXG4gIFJJTkdfTU9EOiA0LFxyXG4gIERFTEFZOiA1LFxyXG4gIEFMTFBBU1M6IDYsXHJcblxyXG4gIC8vIEV4dGVuZGVkIEF1ZGlvICg3LTEzKVxyXG4gIFJFU09OQVRPUjogNyxcclxuICBISUxCRVJUOiA4LFxyXG4gIFJFQ1RJRklFUjogOSxcclxuICBRVUFOVElaRVI6IDEwLFxyXG4gIFNMRVdfTElNSVRFUjogMTEsXHJcbiAgQ1JPU1NfTU9EOiAxMixcclxuICBCSVBPTEFSX0ZPTEQ6IDEzLFxyXG5cclxuICAvLyBQaG90b25pYyAoMTQtMjApXHJcbiAgT1BUSUNBTF9LRVJSOiAxNCxcclxuICBFTEVDVFJPX09QVElDOiAxNSxcclxuICBPUFRJQ0FMX1NXSVRDSDogMTYsXHJcbiAgRk9VUl9XQVZFX01JWElORzogMTcsXHJcbiAgUkFNQU5fQU1QTElGSUVSOiAxOCxcclxuICBTQVRVUkFUSU9OOiAxOSxcclxuICBPUFRJQ0FMX0dBSU46IDIwLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEFMR09SSVRITV9OQU1FUzogUmVjb3JkPG51bWJlciwgc3RyaW5nPiA9IHtcclxuICBbQUxHT1JJVEhNX0lEUy5QQVNTVEhST1VHSF06ICdQYXNzdGhyb3VnaCcsXHJcbiAgW0FMR09SSVRITV9JRFMuVEFOSF9TQVRVUkFURV06ICdUYW5oIFNhdHVyYXRlJyxcclxuICBbQUxHT1JJVEhNX0lEUy5TT0ZUX0NMSVBdOiAnU29mdCBDbGlwJyxcclxuICBbQUxHT1JJVEhNX0lEUy5GT0xEXTogJ0ZvbGQnLFxyXG4gIFtBTEdPUklUSE1fSURTLlJJTkdfTU9EXTogJ1JpbmcgTW9kdWxhdG9yJyxcclxuICBbQUxHT1JJVEhNX0lEUy5ERUxBWV06ICdEZWxheScsXHJcbiAgW0FMR09SSVRITV9JRFMuQUxMUEFTU106ICdBbGxwYXNzIEZpbHRlcicsXHJcbiAgW0FMR09SSVRITV9JRFMuUkVTT05BVE9SXTogJ1Jlc29uYXRvcicsXHJcbiAgW0FMR09SSVRITV9JRFMuSElMQkVSVF06ICdIaWxiZXJ0IFRyYW5zZm9ybScsXHJcbiAgW0FMR09SSVRITV9JRFMuUkVDVElGSUVSXTogJ1JlY3RpZmllcicsXHJcbiAgW0FMR09SSVRITV9JRFMuUVVBTlRJWkVSXTogJ1F1YW50aXplcicsXHJcbiAgW0FMR09SSVRITV9JRFMuU0xFV19MSU1JVEVSXTogJ1NsZXcgTGltaXRlcicsXHJcbiAgW0FMR09SSVRITV9JRFMuQ1JPU1NfTU9EXTogJ0Nyb3NzIE1vZHVsYXRvcicsXHJcbiAgW0FMR09SSVRITV9JRFMuQklQT0xBUl9GT0xEXTogJ0JpcG9sYXIgRm9sZCcsXHJcbiAgW0FMR09SSVRITV9JRFMuT1BUSUNBTF9LRVJSXTogJ09wdGljYWwgS2VyciBFZmZlY3QnLFxyXG4gIFtBTEdPUklUSE1fSURTLkVMRUNUUk9fT1BUSUNdOiAnRWxlY3Ryby1PcHRpYyBNb2R1bGF0b3InLFxyXG4gIFtBTEdPUklUSE1fSURTLk9QVElDQUxfU1dJVENIXTogJ09wdGljYWwgU3dpdGNoJyxcclxuICBbQUxHT1JJVEhNX0lEUy5GT1VSX1dBVkVfTUlYSU5HXTogJ0ZvdXItV2F2ZSBNaXhpbmcnLFxyXG4gIFtBTEdPUklUSE1fSURTLlJBTUFOX0FNUExJRklFUl06ICdSYW1hbiBBbXBsaWZpZXInLFxyXG4gIFtBTEdPUklUSE1fSURTLlNBVFVSQVRJT05dOiAnU2F0dXJhdGlvbicsXHJcbiAgW0FMR09SSVRITV9JRFMuT1BUSUNBTF9HQUlOXTogJ09wdGljYWwgR2FpbicsXHJcbn07XHJcblxyXG4iXSwibmFtZXMiOlsiTk9ERV9QUkVTRVRTIiwic3lzdGVtIiwidHlwZSIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImNvbmZpZyIsImlucHV0RW5hYmxlZCIsIm91dHB1dEVuYWJsZWQiLCJpbnB1dEdhaW4iLCJvdXRwdXRWb2x1bWUiLCJzYW1wbGVSYXRlIiwiYnVmZmVyU2l6ZSIsImlucHV0RGV2aWNlIiwib3V0cHV0RGV2aWNlIiwiaW5wdXRzIiwib3V0cHV0cyIsImNhdGVnb3J5IiwiaG93SXRXb3JrcyIsImJhY2tlbmQiLCJudW1fY2hhaW5zIiwiYmxvY2tpbmdfc3RyYXRlZ3kiLCJhdXRvX2FkYXB0X3N0cmF0ZWd5IiwiY2xhbXBfbW9kZSIsImV4cG9ydF9iZW5jaG1hcmtzIiwib3NjaWxsYXRvcnMiLCJhbHBoYSIsImJldGEiLCJtMCIsIm0xIiwiZXF1YXRpb25zIiwic2lnbWEiLCJyaG8iLCJtdSIsImFsZ29yaXRobXMiLCJnYWluIiwibWl4IiwiZnJlcXVlbmN5IiwiUSIsIm9yZGVyIiwidGhyZXNob2xkIiwicmF0aW8iLCJhdHRhY2siLCJyZWxlYXNlIiwia25lZSIsIm1ha2V1cEdhaW4iLCJjZWlsaW5nIiwiaG9sZCIsInJhbmdlIiwibjIiLCJjaGkzIiwicGJpdF9keW5hbWljcyIsImJpYXMiLCJoeXN0ZXJlc2lzIiwic21vb3RoaW5nIiwidGhybWwiLCJub2RlcyIsInRlbXBlcmF0dXJlIiwiZ2liYnNfc3RlcHMiLCJzcGluX25vZGVzIiwiY29udGludW91c19ub2RlcyIsIm51bV9zdGF0ZXMiLCJzdHJhdGVneSIsImJsb2NrX3NpemUiLCJuX2NvbG9ycyIsImNsYW1wX21hc2siLCJjbGFtcF92YWx1ZXMiLCJuX2NoYWlucyIsImNoYWluX2xlbmd0aCIsInBhcmFsbGVsIiwic2NoZWR1bGVfdHlwZSIsIlRfc3RhcnQiLCJUX2VuZCIsInN0ZXBzIiwid2luZG93X3NpemUiLCJmYWN0b3JfdHlwZSIsIndlaWdodCIsImNvdXBsaW5nX3N0cmVuZ3RoIiwibGVhcm5pbmdfcmF0ZSIsImNkX3N0ZXBzIiwibl9wZXJzaXN0ZW50X2NoYWlucyIsImtfc3RlcHMiLCJ0cmFja19hdXRvY29yciIsInRyYWNrX2VzcyIsIm1ldGhvZCIsIm1pbl9jb2xvcnMiLCJtYXhfY29sb3JzIiwicmVjb21wdXRlX2ludGVydmFsIiwicmVwYWlyX2ludmFsaWQiLCJjaGVja19pbnRlcnZhbCIsInZpc3VhbGl6ZXJzIiwiYnVmZmVyX3NpemUiLCJjaGFubmVscyIsIndpZHRoIiwiaGVpZ2h0IiwiYWN0aXZlIiwiZmZ0X3NpemUiLCJvdmVybGFwIiwiZ3JpZF9zaXplIiwiY29sb3Jfc2NoZW1lIiwidXBkYXRlX3JhdGUiLCJtbF9ub2RlcyIsImlucHV0X2RpbSIsImhpZGRlbl9kaW1zIiwib3V0cHV0X2RpbSIsIm1vZGVsX3BhdGgiLCJrZXJuZWxfc2l6ZSIsIm91dHB1dF9jbGFzc2VzIiwibW9kZWxfbmFtZSIsImhpZGRlbl9zaXplIiwibnVtX2hlYWRzIiwibnVtX2xheWVycyIsInRpbWVzdGVwcyIsImRhdGFfc2hhcGUiLCJiZXRhX3NjaGVkdWxlIiwibnVtX2luZmVyZW5jZV9zdGVwcyIsImxhdGVudF9kaW0iLCJvdXRwdXRfbGVuZ3RoIiwiYXJjaGl0ZWN0dXJlIiwic3RhdGVfZGltIiwiYWN0aW9uX2RpbSIsImFsZ29yaXRobSIsImdhbW1hIiwiYW5hbHlzaXNfbm9kZXMiLCJzaXplIiwid2luZG93IiwibnVtX3BhdHRlcm5zIiwibmVpZ2hib3JzIiwiZW1iZWRkaW5nX2RpbSIsInRpbWVfZGVsYXkiLCJzY2FuX3Jlc29sdXRpb24iLCJudW1fc2FtcGxlcyIsImNvbXB1dGVfYmFycmllcnMiLCJtYXhfbGFnIiwiY29udHJvbF9ub2RlcyIsInRhcmdldF9tZXRyaWMiLCJvcHRpbWl6ZXIiLCJtb21lbnR1bSIsInN0cmVuZ3RoIiwiZGVsYXkiLCJLcCIsIktpIiwiS2QiLCJzZXRwb2ludCIsIm1pbl9zdGVwcyIsIm1heF9zdGVwcyIsInRhcmdldF9hY2NlcHRhbmNlIiwiYWRhcHRhdGlvbl9yYXRlIiwiZ2VuZXJhdG9yX25vZGVzIiwiYW1wbGl0dWRlIiwic2VlZCIsInBhdHRlcm4iLCJwaGFzZSIsImxlbmd0aCIsInBhdHRlcm5fdHlwZSIsInN0YXJ0Iiwic3RlcCIsIkFMR09SSVRITV9JRFMiLCJQQVNTVEhST1VHSCIsIlRBTkhfU0FUVVJBVEUiLCJTT0ZUX0NMSVAiLCJGT0xEIiwiUklOR19NT0QiLCJERUxBWSIsIkFMTFBBU1MiLCJSRVNPTkFUT1IiLCJISUxCRVJUIiwiUkVDVElGSUVSIiwiUVVBTlRJWkVSIiwiU0xFV19MSU1JVEVSIiwiQ1JPU1NfTU9EIiwiQklQT0xBUl9GT0xEIiwiT1BUSUNBTF9LRVJSIiwiRUxFQ1RST19PUFRJQyIsIk9QVElDQUxfU1dJVENIIiwiRk9VUl9XQVZFX01JWElORyIsIlJBTUFOX0FNUExJRklFUiIsIlNBVFVSQVRJT04iLCJPUFRJQ0FMX0dBSU4iLCJBTEdPUklUSE1fTkFNRVMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/NodeGraph/NodePresets.ts\n"));

/***/ })

});