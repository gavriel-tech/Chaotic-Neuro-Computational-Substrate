"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/stores/backendData.ts":
/*!***********************************!*\
  !*** ./lib/stores/backendData.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useBackendDataStore: function() { return /* binding */ useBackendDataStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nvar _process_env_NEXT_PUBLIC_API_URL;\nconst API_BASE = (_process_env_NEXT_PUBLIC_API_URL = process.env.NEXT_PUBLIC_API_URL) !== null && _process_env_NEXT_PUBLIC_API_URL !== void 0 ? _process_env_NEXT_PUBLIC_API_URL : \"http://localhost:8000\";\nconst parsePollMs = (value, fallback)=>{\n    const parsed = Number(value);\n    return Number.isFinite(parsed) && parsed > 0 ? parsed : fallback;\n};\nconst POLL_INTERVAL_MS = parsePollMs(process.env.NEXT_PUBLIC_STATUS_POLL_MS, 2000);\nconst REQUEST_TIMEOUT_MS = parsePollMs(process.env.NEXT_PUBLIC_STATUS_REQUEST_TIMEOUT_MS, 4000);\nlet pollTimer = null;\nlet subscriberCount = 0;\nconst useBackendDataStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)((set, get)=>({\n        simulationStatus: null,\n        thrmlEnergy: null,\n        thrmlEnergyTimestamp: null,\n        benchmarks: null,\n        processors: [],\n        lastUpdated: null,\n        statusError: null,\n        thrmlError: null,\n        benchmarkError: null,\n        processorError: null,\n        rateLimited: false,\n        isPolling: false,\n        startPolling: ()=>{\n            subscriberCount += 1;\n            if (pollTimer) return;\n            pollTimer = setInterval(()=>{\n                get().pollOnce().catch(()=>{\n                /* errors handled in state */ });\n            }, POLL_INTERVAL_MS);\n            void get().pollOnce();\n        },\n        stopPolling: ()=>{\n            if (subscriberCount > 0) {\n                subscriberCount -= 1;\n            }\n            if (subscriberCount === 0 && pollTimer) {\n                clearInterval(pollTimer);\n                pollTimer = null;\n            }\n        },\n        pollOnce: async ()=>{\n            if (get().isPolling) {\n                return;\n            }\n            set({\n                isPolling: true\n            });\n            const fetchJson = async (path)=>{\n                const options = {};\n                if (typeof AbortSignal !== \"undefined\" && \"timeout\" in AbortSignal) {\n                    options.signal = AbortSignal.timeout(REQUEST_TIMEOUT_MS);\n                }\n                const response = await fetch(\"\".concat(API_BASE).concat(path), options);\n                if (response.status === 429) {\n                    throw new Error(\"rate_limited\");\n                }\n                if (!response.ok) {\n                    throw new Error(\"\".concat(response.status));\n                }\n                return response.json();\n            };\n            let rateLimited = false;\n            try {\n                try {\n                    const status = await fetchJson(\"/simulation/status\");\n                    set({\n                        simulationStatus: status,\n                        statusError: null,\n                        rateLimited: false\n                    });\n                } catch (error) {\n                    const message = error instanceof Error ? error.message : String(error);\n                    if (message === \"rate_limited\") {\n                        rateLimited = true;\n                        set({\n                            rateLimited: true,\n                            statusError: \"Rate limit exceeded\"\n                        });\n                    } else {\n                        const friendly = message === \"404\" ? \"HTTP 404\" : message;\n                        set({\n                            statusError: friendly\n                        });\n                    }\n                }\n                try {\n                    const energy = await fetchJson(\"/thrml/energy\");\n                    set({\n                        thrmlEnergy: typeof (energy === null || energy === void 0 ? void 0 : energy.energy) === \"number\" ? energy.energy : null,\n                        thrmlEnergyTimestamp: typeof (energy === null || energy === void 0 ? void 0 : energy.timestamp) === \"number\" ? energy.timestamp : null,\n                        thrmlError: null\n                    });\n                } catch (error) {\n                    const message = error instanceof Error ? error.message : String(error);\n                    if (message === \"rate_limited\") {\n                        rateLimited = true;\n                        set({\n                            thrmlError: \"Rate limit exceeded\",\n                            rateLimited: true\n                        });\n                    } else {\n                        const friendly = message === \"404\" ? \"HTTP 404\" : message;\n                        set({\n                            thrmlError: friendly\n                        });\n                    }\n                }\n                try {\n                    const bench = await fetchJson(\"/sampler/benchmarks\");\n                    set({\n                        benchmarks: bench,\n                        benchmarkError: null\n                    });\n                } catch (error) {\n                    const message = error instanceof Error ? error.message : String(error);\n                    if (message === \"rate_limited\") {\n                        rateLimited = true;\n                        set({\n                            benchmarkError: \"Rate limit exceeded\",\n                            rateLimited: true\n                        });\n                    } else {\n                        const friendly = message === \"404\" ? \"HTTP 404\" : message;\n                        set({\n                            benchmarkError: friendly\n                        });\n                    }\n                }\n                try {\n                    const proc = await fetchJson(\"/processor/list\");\n                    const processors = Array.isArray(proc === null || proc === void 0 ? void 0 : proc.processors) ? proc.processors : [];\n                    set({\n                        processors,\n                        processorError: null\n                    });\n                } catch (error) {\n                    const message = error instanceof Error ? error.message : String(error);\n                    if (message === \"rate_limited\") {\n                        rateLimited = true;\n                        set({\n                            processorError: \"Rate limit exceeded\",\n                            rateLimited: true\n                        });\n                    } else {\n                        const friendly = message === \"404\" ? \"HTTP 404\" : message;\n                        set({\n                            processorError: friendly\n                        });\n                    }\n                }\n                if (!rateLimited) {\n                    set({\n                        rateLimited: false\n                    });\n                }\n            } finally{\n                set({\n                    isPolling: false,\n                    lastUpdated: Date.now()\n                });\n            }\n        }\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zdG9yZXMvYmFja2VuZERhdGEudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWlDO0lBRWhCQztBQUFqQixNQUFNQyxXQUFXRCxDQUFBQSxtQ0FBQUEsT0FBT0EsQ0FBQ0UsR0FBRyxDQUFDQyxtQkFBbUIsY0FBL0JILDhDQUFBQSxtQ0FBbUM7QUFFcEQsTUFBTUksY0FBYyxDQUFDQyxPQUEyQkM7SUFDOUMsTUFBTUMsU0FBU0MsT0FBT0g7SUFDdEIsT0FBT0csT0FBT0MsUUFBUSxDQUFDRixXQUFXQSxTQUFTLElBQUlBLFNBQVNEO0FBQzFEO0FBRUEsTUFBTUksbUJBQW1CTixZQUFZSixPQUFPQSxDQUFDRSxHQUFHLENBQUNTLDBCQUEwQixFQUFFO0FBQzdFLE1BQU1DLHFCQUFxQlIsWUFBWUosT0FBT0EsQ0FBQ0UsR0FBRyxDQUFDVyxxQ0FBcUMsRUFBRTtBQStDMUYsSUFBSUMsWUFBbUQ7QUFDdkQsSUFBSUMsa0JBQWtCO0FBRWYsTUFBTUMsc0JBQXNCakIsK0NBQU1BLENBQW1CLENBQUNrQixLQUFLQyxNQUFTO1FBQ3pFQyxrQkFBa0I7UUFDbEJDLGFBQWE7UUFDYkMsc0JBQXNCO1FBQ3RCQyxZQUFZO1FBQ1pDLFlBQVksRUFBRTtRQUNkQyxhQUFhO1FBQ2JDLGFBQWE7UUFDYkMsWUFBWTtRQUNaQyxnQkFBZ0I7UUFDaEJDLGdCQUFnQjtRQUNoQkMsYUFBYTtRQUNiQyxXQUFXO1FBQ1hDLGNBQWM7WUFDWmhCLG1CQUFtQjtZQUNuQixJQUFJRCxXQUFXO1lBQ2ZBLFlBQVlrQixZQUFZO2dCQUN0QmQsTUFBTWUsUUFBUSxHQUFHQyxLQUFLLENBQUM7Z0JBQ3JCLDJCQUEyQixHQUM3QjtZQUNGLEdBQUd4QjtZQUNILEtBQUtRLE1BQU1lLFFBQVE7UUFDckI7UUFDQUUsYUFBYTtZQUNYLElBQUlwQixrQkFBa0IsR0FBRztnQkFDdkJBLG1CQUFtQjtZQUNyQjtZQUNBLElBQUlBLG9CQUFvQixLQUFLRCxXQUFXO2dCQUN0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LElBQUlpQyxLQUFLakMsVUFBVSxHQUFHLEVBQUU7b0JBQzFGTixJQUFJO3dCQUFFTTt3QkFBWUssZ0JBQWdCO29CQUFLO2dCQUN6QyxFQUFFLE9BQU9xQixPQUFPO29CQUNkLE1BQU1DLFVBQVVELGlCQUFpQkgsUUFBUUcsTUFBTUMsT0FBTyxHQUFHQyxPQUFPRjtvQkFDaEUsSUFBSUMsWUFBWSxnQkFBZ0I7d0JBQzlCckIsY0FBYzt3QkFDZFosSUFBSTs0QkFBRVcsZ0JBQWdCOzRCQUF1QkMsYUFBYTt3QkFBSztvQkFDakUsT0FBTzt3QkFDTCxNQUFNdUIsV0FBV0YsWUFBWSxRQUFRLGFBQWFBO3dCQUNsRGpDLElBQUk7NEJBQUVXLGdCQUFnQndCO3dCQUFTO29CQUNqQztnQkFDRjtnQkFFQSxJQUFJLENBQUN2QixhQUFhO29CQUNoQlosSUFBSTt3QkFBRVksYUFBYTtvQkFBTTtnQkFDM0I7WUFDRixTQUFVO2dCQUNSWixJQUFJO29CQUFFYSxXQUFXO29CQUFPTixhQUFhbUMsS0FBS0MsR0FBRztnQkFBRztZQUNsRDtRQUNGO0lBQ0YsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvc3RvcmVzL2JhY2tlbmREYXRhLnRzPzcxMTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSBcInp1c3RhbmRcIjtcclxuXHJcbmNvbnN0IEFQSV9CQVNFID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCA/PyBcImh0dHA6Ly9sb2NhbGhvc3Q6ODAwMFwiO1xyXG5cclxuY29uc3QgcGFyc2VQb2xsTXMgPSAodmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZmFsbGJhY2s6IG51bWJlcikgPT4ge1xyXG4gIGNvbnN0IHBhcnNlZCA9IE51bWJlcih2YWx1ZSk7XHJcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShwYXJzZWQpICYmIHBhcnNlZCA+IDAgPyBwYXJzZWQgOiBmYWxsYmFjaztcclxufTtcclxuXHJcbmNvbnN0IFBPTExfSU5URVJWQUxfTVMgPSBwYXJzZVBvbGxNcyhwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVEFUVVNfUE9MTF9NUywgMjAwMCk7XHJcbmNvbnN0IFJFUVVFU1RfVElNRU9VVF9NUyA9IHBhcnNlUG9sbE1zKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NUQVRVU19SRVFVRVNUX1RJTUVPVVRfTVMsIDQwMDApO1xyXG5cclxuaW50ZXJmYWNlIFNpbXVsYXRpb25TdGF0dXNSZXNwb25zZSB7XHJcbiAgYWN0aXZlX25vZGVzPzogbnVtYmVyO1xyXG4gIHRvdGFsX2NhcGFjaXR5PzogbnVtYmVyO1xyXG4gIHNpbXVsYXRpb25fdGltZT86IG51bWJlcjtcclxuICBkdD86IG51bWJlcjtcclxuICBncmlkX3NpemU/OiBudW1iZXJbXTtcclxuICBba2V5OiBzdHJpbmddOiB1bmtub3duO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQmVuY2htYXJrTWV0cmljcyB7XHJcbiAgc2FtcGxlc19wZXJfc2VjPzogbnVtYmVyO1xyXG4gIGVzc19wZXJfc2VjPzogbnVtYmVyO1xyXG4gIGxhZzFfYXV0b2NvcnI/OiBudW1iZXI7XHJcbiAgdGF1X2ludD86IG51bWJlcjtcclxuICB0b3RhbF9zYW1wbGVzPzogbnVtYmVyO1xyXG4gIG1lYW5fbWFnbmV0aXphdGlvbj86IG51bWJlcjtcclxuICBba2V5OiBzdHJpbmddOiB1bmtub3duO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgUHJvY2Vzc29ySW5mbyB7XHJcbiAgbm9kZV9pZDogc3RyaW5nO1xyXG4gIHR5cGU6IHN0cmluZztcclxuICBhY3RpdmU6IGJvb2xlYW47XHJcbiAgY29uZmlnPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XHJcbiAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcclxufVxyXG5cclxuaW50ZXJmYWNlIEJhY2tlbmREYXRhU3RhdGUge1xyXG4gIHNpbXVsYXRpb25TdGF0dXM6IFNpbXVsYXRpb25TdGF0dXNSZXNwb25zZSB8IG51bGw7XHJcbiAgdGhybWxFbmVyZ3k6IG51bWJlciB8IG51bGw7XHJcbiAgdGhybWxFbmVyZ3lUaW1lc3RhbXA6IG51bWJlciB8IG51bGw7XHJcbiAgYmVuY2htYXJrczogQmVuY2htYXJrTWV0cmljcyB8IG51bGw7XHJcbiAgcHJvY2Vzc29yczogUHJvY2Vzc29ySW5mb1tdO1xyXG4gIGxhc3RVcGRhdGVkOiBudW1iZXIgfCBudWxsO1xyXG4gIHN0YXR1c0Vycm9yOiBzdHJpbmcgfCBudWxsO1xyXG4gIHRocm1sRXJyb3I6IHN0cmluZyB8IG51bGw7XHJcbiAgYmVuY2htYXJrRXJyb3I6IHN0cmluZyB8IG51bGw7XHJcbiAgcHJvY2Vzc29yRXJyb3I6IHN0cmluZyB8IG51bGw7XHJcbiAgcmF0ZUxpbWl0ZWQ6IGJvb2xlYW47XHJcbiAgaXNQb2xsaW5nOiBib29sZWFuO1xyXG4gIHN0YXJ0UG9sbGluZzogKCkgPT4gdm9pZDtcclxuICBzdG9wUG9sbGluZzogKCkgPT4gdm9pZDtcclxuICBwb2xsT25jZTogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxufVxyXG5cclxubGV0IHBvbGxUaW1lcjogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+IHwgbnVsbCA9IG51bGw7XHJcbmxldCBzdWJzY3JpYmVyQ291bnQgPSAwO1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUJhY2tlbmREYXRhU3RvcmUgPSBjcmVhdGU8QmFja2VuZERhdGFTdGF0ZT4oKHNldCwgZ2V0KSA9PiAoe1xyXG4gIHNpbXVsYXRpb25TdGF0dXM6IG51bGwsXHJcbiAgdGhybWxFbmVyZ3k6IG51bGwsXHJcbiAgdGhybWxFbmVyZ3lUaW1lc3RhbXA6IG51bGwsXHJcbiAgYmVuY2htYXJrczogbnVsbCxcclxuICBwcm9jZXNzb3JzOiBbXSxcclxuICBsYXN0VXBkYXRlZDogbnVsbCxcclxuICBzdGF0dXNFcnJvcjogbnVsbCxcclxuICB0aHJtbEVycm9yOiBudWxsLFxyXG4gIGJlbmNobWFya0Vycm9yOiBudWxsLFxyXG4gIHByb2Nlc3NvckVycm9yOiBudWxsLFxyXG4gIHJhdGVMaW1pdGVkOiBmYWxzZSxcclxuICBpc1BvbGxpbmc6IGZhbHNlLFxyXG4gIHN0YXJ0UG9sbGluZzogKCkgPT4ge1xyXG4gICAgc3Vic2NyaWJlckNvdW50ICs9IDE7XHJcbiAgICBpZiAocG9sbFRpbWVyKSByZXR1cm47XHJcbiAgICBwb2xsVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIGdldCgpLnBvbGxPbmNlKCkuY2F0Y2goKCkgPT4ge1xyXG4gICAgICAgIC8qIGVycm9ycyBoYW5kbGVkIGluIHN0YXRlICovXHJcbiAgICAgIH0pO1xyXG4gICAgfSwgUE9MTF9JTlRFUlZBTF9NUyk7XHJcbiAgICB2b2lkIGdldCgpLnBvbGxPbmNlKCk7XHJcbiAgfSxcclxuICBzdG9wUG9sbGluZzogKCkgPT4ge1xyXG4gICAgaWYgKHN1YnNjcmliZXJDb3VudCA+IDApIHtcclxuICAgICAgc3Vic2NyaWJlckNvdW50IC09IDE7XHJcbiAgICB9XHJcbiAgICBpZiAoc3Vic2NyaWJlckNvdW50ID09PSAwICYmIHBvbGxUaW1lcikge1xyXG4gICAgICBjbGVhckludGVydmFsKHBvbGxUaW1lcik7XHJcbiAgICAgIHBvbGxUaW1lciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfSxcclxuICBwb2xsT25jZTogYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKGdldCgpLmlzUG9sbGluZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBzZXQoeyBpc1BvbGxpbmc6IHRydWUgfSk7XHJcblxyXG4gICAgY29uc3QgZmV0Y2hKc29uID0gYXN5bmMgKHBhdGg6IHN0cmluZykgPT4ge1xyXG4gICAgICBjb25zdCBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHt9O1xyXG4gICAgICBpZiAodHlwZW9mIEFib3J0U2lnbmFsICE9PSBcInVuZGVmaW5lZFwiICYmIFwidGltZW91dFwiIGluIEFib3J0U2lnbmFsKSB7XHJcbiAgICAgICAgb3B0aW9ucy5zaWduYWwgPSBBYm9ydFNpZ25hbC50aW1lb3V0KFJFUVVFU1RfVElNRU9VVF9NUyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRX0ke3BhdGh9YCwgb3B0aW9ucyk7XHJcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJhdGVfbGltaXRlZFwiKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgcmF0ZUxpbWl0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGZldGNoSnNvbihcIi9zaW11bGF0aW9uL3N0YXR1c1wiKTtcclxuICAgICAgICBzZXQoe1xyXG4gICAgICAgICAgc2ltdWxhdGlvblN0YXR1czogc3RhdHVzLFxyXG4gICAgICAgICAgc3RhdHVzRXJyb3I6IG51bGwsXHJcbiAgICAgICAgICByYXRlTGltaXRlZDogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuICAgICAgICBpZiAobWVzc2FnZSA9PT0gXCJyYXRlX2xpbWl0ZWRcIikge1xyXG4gICAgICAgICAgcmF0ZUxpbWl0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgc2V0KHsgcmF0ZUxpbWl0ZWQ6IHRydWUsIHN0YXR1c0Vycm9yOiBcIlJhdGUgbGltaXQgZXhjZWVkZWRcIiB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc3QgZnJpZW5kbHkgPSBtZXNzYWdlID09PSBcIjQwNFwiID8gXCJIVFRQIDQwNFwiIDogbWVzc2FnZTtcclxuICAgICAgICAgIHNldCh7IHN0YXR1c0Vycm9yOiBmcmllbmRseSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZW5lcmd5ID0gYXdhaXQgZmV0Y2hKc29uKGAvdGhybWwvZW5lcmd5YCk7XHJcbiAgICAgICAgc2V0KHtcclxuICAgICAgICAgIHRocm1sRW5lcmd5OiB0eXBlb2YgZW5lcmd5Py5lbmVyZ3kgPT09IFwibnVtYmVyXCIgPyBlbmVyZ3kuZW5lcmd5IDogbnVsbCxcclxuICAgICAgICAgIHRocm1sRW5lcmd5VGltZXN0YW1wOiB0eXBlb2YgZW5lcmd5Py50aW1lc3RhbXAgPT09IFwibnVtYmVyXCIgPyBlbmVyZ3kudGltZXN0YW1wIDogbnVsbCxcclxuICAgICAgICAgIHRocm1sRXJyb3I6IG51bGwsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuICAgICAgICBpZiAobWVzc2FnZSA9PT0gXCJyYXRlX2xpbWl0ZWRcIikge1xyXG4gICAgICAgICAgcmF0ZUxpbWl0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgc2V0KHsgdGhybWxFcnJvcjogXCJSYXRlIGxpbWl0IGV4Y2VlZGVkXCIsIHJhdGVMaW1pdGVkOiB0cnVlIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zdCBmcmllbmRseSA9IG1lc3NhZ2UgPT09IFwiNDA0XCIgPyBcIkhUVFAgNDA0XCIgOiBtZXNzYWdlO1xyXG4gICAgICAgICAgc2V0KHsgdGhybWxFcnJvcjogZnJpZW5kbHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGJlbmNoID0gYXdhaXQgZmV0Y2hKc29uKGAvc2FtcGxlci9iZW5jaG1hcmtzYCk7XHJcbiAgICAgICAgc2V0KHsgYmVuY2htYXJrczogYmVuY2gsIGJlbmNobWFya0Vycm9yOiBudWxsIH0pO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IFwicmF0ZV9saW1pdGVkXCIpIHtcclxuICAgICAgICAgIHJhdGVMaW1pdGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHNldCh7IGJlbmNobWFya0Vycm9yOiBcIlJhdGUgbGltaXQgZXhjZWVkZWRcIiwgcmF0ZUxpbWl0ZWQ6IHRydWUgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnN0IGZyaWVuZGx5ID0gbWVzc2FnZSA9PT0gXCI0MDRcIiA/IFwiSFRUUCA0MDRcIiA6IG1lc3NhZ2U7XHJcbiAgICAgICAgICBzZXQoeyBiZW5jaG1hcmtFcnJvcjogZnJpZW5kbHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHByb2MgPSBhd2FpdCBmZXRjaEpzb24oYC9wcm9jZXNzb3IvbGlzdGApO1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NvcnM6IFByb2Nlc3NvckluZm9bXSA9IEFycmF5LmlzQXJyYXkocHJvYz8ucHJvY2Vzc29ycykgPyBwcm9jLnByb2Nlc3NvcnMgOiBbXTtcclxuICAgICAgICBzZXQoeyBwcm9jZXNzb3JzLCBwcm9jZXNzb3JFcnJvcjogbnVsbCB9KTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xyXG4gICAgICAgIGlmIChtZXNzYWdlID09PSBcInJhdGVfbGltaXRlZFwiKSB7XHJcbiAgICAgICAgICByYXRlTGltaXRlZCA9IHRydWU7XHJcbiAgICAgICAgICBzZXQoeyBwcm9jZXNzb3JFcnJvcjogXCJSYXRlIGxpbWl0IGV4Y2VlZGVkXCIsIHJhdGVMaW1pdGVkOiB0cnVlIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zdCBmcmllbmRseSA9IG1lc3NhZ2UgPT09IFwiNDA0XCIgPyBcIkhUVFAgNDA0XCIgOiBtZXNzYWdlO1xyXG4gICAgICAgICAgc2V0KHsgcHJvY2Vzc29yRXJyb3I6IGZyaWVuZGx5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFyYXRlTGltaXRlZCkge1xyXG4gICAgICAgIHNldCh7IHJhdGVMaW1pdGVkOiBmYWxzZSB9KTtcclxuICAgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0KHsgaXNQb2xsaW5nOiBmYWxzZSwgbGFzdFVwZGF0ZWQ6IERhdGUubm93KCkgfSk7XHJcbiAgICB9XHJcbiAgfSxcclxufSkpO1xyXG4iXSwibmFtZXMiOlsiY3JlYXRlIiwicHJvY2VzcyIsIkFQSV9CQVNFIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsInBhcnNlUG9sbE1zIiwidmFsdWUiLCJmYWxsYmFjayIsInBhcnNlZCIsIk51bWJlciIsImlzRmluaXRlIiwiUE9MTF9JTlRFUlZBTF9NUyIsIk5FWFRfUFVCTElDX1NUQVRVU19QT0xMX01TIiwiUkVRVUVTVF9USU1FT1VUX01TIiwiTkVYVF9QVUJMSUNfU1RBVFVTX1JFUVVFU1RfVElNRU9VVF9NUyIsInBvbGxUaW1lciIsInN1YnNjcmliZXJDb3VudCIsInVzZUJhY2tlbmREYXRhU3RvcmUiLCJzZXQiLCJnZXQiLCJzaW11bGF0aW9uU3RhdHVzIiwidGhybWxFbmVyZ3kiLCJ0aHJtbEVuZXJneVRpbWVzdGFtcCIsImJlbmNobWFya3MiLCJwcm9jZXNzb3JzIiwibGFzdFVwZGF0ZWQiLCJzdGF0dXNFcnJvciIsInRocm1sRXJyb3IiLCJiZW5jaG1hcmtFcnJvciIsInByb2Nlc3NvckVycm9yIiwicmF0ZUxpbWl0ZWQiLCJpc1BvbGxpbmciLCJzdGFydFBvbGxpbmciLCJzZXRJbnRlcnZhbCIsInBvbGxPbmNlIiwiY2F0Y2giLCJzdG9wUG9sbGluZyIsImNsZWFySW50ZXJ2YWwiLCJmZXRjaEpzb24iLCJwYXRoIiwib3B0aW9ucyIsIkFib3J0U2lnbmFsIiwic2lnbmFsIiwidGltZW91dCIsInJlc3BvbnNlIiwiZmV0Y2giLCJzdGF0dXMiLCJFcnJvciIsIm9rIiwianNvbiIsImVycm9yIiwibWVzc2FnZSIsIlN0cmluZyIsImZyaWVuZGx5IiwiZW5lcmd5IiwidGltZXN0YW1wIiwiYmVuY2giLCJwcm9jIiwiQXJyYXkiLCJpc0FycmF5IiwiRGF0ZSIsIm5vdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/stores/backendData.ts\n"));

/***/ })

});