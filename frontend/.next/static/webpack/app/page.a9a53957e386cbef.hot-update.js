"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/stores/backendData.ts":
/*!***********************************!*\
  !*** ./lib/stores/backendData.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useBackendDataStore: function() { return /* binding */ useBackendDataStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nvar _process_env_NEXT_PUBLIC_API_URL;\nconst API_BASE = (_process_env_NEXT_PUBLIC_API_URL = process.env.NEXT_PUBLIC_API_URL) !== null && _process_env_NEXT_PUBLIC_API_URL !== void 0 ? _process_env_NEXT_PUBLIC_API_URL : \"http://localhost:8000\";\nconst parsePollMs = (value, fallback)=>{\n    const parsed = Number(value);\n    return Number.isFinite(parsed) && parsed > 0 ? parsed : fallback;\n};\nconst POLL_INTERVAL_MS = parsePollMs(process.env.NEXT_PUBLIC_STATUS_POLL_MS, 2000);\nconst REQUEST_TIMEOUT_MS = parsePollMs(process.env.NEXT_PUBLIC_STATUS_REQUEST_TIMEOUT_MS, 4000);\nlet pollTimer = null;\nlet subscriberCount = 0;\nconst useBackendDataStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)((set, get)=>({\n        simulationStatus: null,\n        thrmlEnergy: null,\n        thrmlEnergyTimestamp: null,\n        benchmarks: null,\n        processors: [],\n        lastUpdated: null,\n        statusError: null,\n        thrmlError: null,\n        benchmarkError: null,\n        processorError: null,\n        rateLimited: false,\n        isPolling: false,\n        startPolling: ()=>{\n            subscriberCount += 1;\n            if (pollTimer) return;\n            pollTimer = setInterval(()=>{\n                get().pollOnce().catch(()=>{\n                /* errors handled in state */ });\n            }, POLL_INTERVAL_MS);\n            void get().pollOnce();\n        },\n        stopPolling: ()=>{\n            if (subscriberCount > 0) {\n                subscriberCount -= 1;\n            }\n            if (subscriberCount === 0 && pollTimer) {\n                clearInterval(pollTimer);\n                pollTimer = null;\n            }\n        },\n        pollOnce: async ()=>{\n            if (get().isPolling) {\n                return;\n            }\n            set({\n                isPolling: true\n            });\n            const fetchJson = async (path)=>{\n                const options = {};\n                if (typeof AbortSignal !== \"undefined\" && \"timeout\" in AbortSignal) {\n                    options.signal = AbortSignal.timeout(REQUEST_TIMEOUT_MS);\n                }\n                const response = await fetch(\"\".concat(API_BASE).concat(path), options);\n                if (response.status === 429) {\n                    throw new Error(\"rate_limited\");\n                }\n                if (!response.ok) {\n                    throw new Error(\"\".concat(response.status));\n                }\n                return response.json();\n            };\n            let rateLimited = false;\n            try {\n                try {\n                    const status = await fetchJson(\"/simulation/status\");\n                    set({\n                        simulationStatus: status,\n                        statusError: null,\n                        rateLimited: false\n                    });\n                } catch (error) {\n                    const message = error instanceof Error ? error.message : String(error);\n                    if (message === \"rate_limited\") {\n                        rateLimited = true;\n                        set({\n                            rateLimited: true,\n                            statusError: \"Rate limit exceeded\"\n                        });\n                    } else {\n                        set({\n                            statusError: message\n                        });\n                    }\n                }\n                try {\n                    const energy = await fetchJson(\"/thrml/energy\");\n                    set({\n                        thrmlEnergy: typeof (energy === null || energy === void 0 ? void 0 : energy.energy) === \"number\" ? energy.energy : null,\n                        thrmlEnergyTimestamp: typeof (energy === null || energy === void 0 ? void 0 : energy.timestamp) === \"number\" ? energy.timestamp : null,\n                        thrmlError: null\n                    });\n                } catch (error) {\n                    const message = error instanceof Error ? error.message : String(error);\n                    if (message === \"rate_limited\") {\n                        rateLimited = true;\n                        set({\n                            thrmlError: \"Rate limit exceeded\",\n                            rateLimited: true\n                        });\n                    } else {\n                        set({\n                            thrmlError: message\n                        });\n                    }\n                }\n                try {\n                    const bench = await fetchJson(\"/sampler/benchmarks\");\n                    set({\n                        benchmarks: bench,\n                        benchmarkError: null\n                    });\n                } catch (error) {\n                    const message = error instanceof Error ? error.message : String(error);\n                    if (message === \"rate_limited\") {\n                        rateLimited = true;\n                        set({\n                            benchmarkError: \"Rate limit exceeded\",\n                            rateLimited: true\n                        });\n                    } else {\n                        set({\n                            benchmarkError: message\n                        });\n                    }\n                }\n                try {\n                    const proc = await fetchJson(\"/processor/list\");\n                    const processors = Array.isArray(proc === null || proc === void 0 ? void 0 : proc.processors) ? proc.processors : [];\n                    set({\n                        processors,\n                        processorError: null\n                    });\n                } catch (error) {\n                    const message = error instanceof Error ? error.message : String(error);\n                    if (message === \"rate_limited\") {\n                        rateLimited = true;\n                        set({\n                            processorError: \"Rate limit exceeded\",\n                            rateLimited: true\n                        });\n                    } else {\n                        set({\n                            processorError: message\n                        });\n                    }\n                }\n                if (!rateLimited) {\n                    set({\n                        rateLimited: false\n                    });\n                }\n            } finally{\n                set({\n                    isPolling: false,\n                    lastUpdated: Date.now()\n                });\n            }\n        }\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zdG9yZXMvYmFja2VuZERhdGEudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWlDO0lBRWhCQztBQUFqQixNQUFNQyxXQUFXRCxDQUFBQSxtQ0FBQUEsT0FBT0EsQ0FBQ0UsR0FBRyxDQUFDQyxtQkFBbUIsY0FBL0JILDhDQUFBQSxtQ0FBbUM7QUFFcEQsTUFBTUksY0FBYyxDQUFDQyxPQUEyQkM7SUFDOUMsTUFBTUMsU0FBU0MsT0FBT0g7SUFDdEIsT0FBT0csT0FBT0MsUUFBUSxDQUFDRixXQUFXQSxTQUFTLElBQUlBLFNBQVNEO0FBQzFEO0FBRUEsTUFBTUksbUJBQW1CTixZQUFZSixPQUFPQSxDQUFDRSxHQUFHLENBQUNTLDBCQUEwQixFQUFFO0FBQzdFLE1BQU1DLHFCQUFxQlIsWUFBWUosT0FBT0EsQ0FBQ0UsR0FBRyxDQUFDVyxxQ0FBcUMsRUFBRTtBQStDMUYsSUFBSUMsWUFBbUQ7QUFDdkQsSUFBSUMsa0JBQWtCO0FBRWYsTUFBTUMsc0JBQXNCakIsK0NBQU1BLENBQW1CLENBQUNrQixLQUFLQyxNQUFTO1FBQ3pFQyxrQkFBa0I7UUFDbEJDLGFBQWE7UUFDYkMsc0JBQXNCO1FBQ3RCQyxZQUFZO1FBQ1pDLFlBQVksRUFBRTtRQUNkQyxhQUFhO1FBQ2JDLGFBQWE7UUFDYkMsWUFBWTtRQUNaQyxnQkFBZ0I7UUFDaEJDLGdCQUFnQjtRQUNoQkMsYUFBYTtRQUNiQyxXQUFXO1FBQ1hDLGNBQWM7WUFDWmhCLG1CQUFtQjtZQUNuQixJQUFJRCxXQUFXO1lBQ2ZBLFlBQVlrQixZQUFZO2dCQUN0QmQsTUFBTWUsUUFBUSxHQUFHQyxLQUFLLENBQUM7Z0JBQ3JCLDJCQUEyQixHQUM3QjtZQUNGLEdBQUd4QjtZQUNILEtBQUtRLE1BQU1lLFFBQVE7UUFDckI7UUFDQUUsYUFBYTtZQUNYLElBQUlwQixrQkFBa0IsR0FBRztnQkFDdkJBLG1CQUFtQjtZQUNyQjtZQUNBLElBQUlBLG9CQUFvQixLQUFLRCxXQUFXO2dCQUN0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aUJBQWlCSCxRQUFRRyxNQUFNQyxPQUFPLEdBQUdDLE9BQU9GO29CQUNoRSxJQUFJQyxZQUFZLGdCQUFnQjt3QkFDOUJyQixjQUFjO3dCQUNkWixJQUFJOzRCQUFFVyxnQkFBZ0I7NEJBQXVCQyxhQUFhO3dCQUFLO29CQUNqRSxPQUFPO3dCQUNMWixJQUFJOzRCQUFFVyxnQkFBZ0JzQjt3QkFBUTtvQkFDaEM7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDckIsYUFBYTtvQkFDaEJaLElBQUk7d0JBQUVZLGFBQWE7b0JBQU07Z0JBQzNCO1lBQ0YsU0FBVTtnQkFDUlosSUFBSTtvQkFBRWEsV0FBVztvQkFBT04sYUFBYWtDLEtBQUtDLEdBQUc7Z0JBQUc7WUFDbEQ7UUFDRjtJQUNGLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3N0b3Jlcy9iYWNrZW5kRGF0YS50cz83MTEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gXCJ6dXN0YW5kXCI7XHJcblxyXG5jb25zdCBBUElfQkFTRSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgPz8gXCJodHRwOi8vbG9jYWxob3N0OjgwMDBcIjtcclxuXHJcbmNvbnN0IHBhcnNlUG9sbE1zID0gKHZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGZhbGxiYWNrOiBudW1iZXIpID0+IHtcclxuICBjb25zdCBwYXJzZWQgPSBOdW1iZXIodmFsdWUpO1xyXG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUocGFyc2VkKSAmJiBwYXJzZWQgPiAwID8gcGFyc2VkIDogZmFsbGJhY2s7XHJcbn07XHJcblxyXG5jb25zdCBQT0xMX0lOVEVSVkFMX01TID0gcGFyc2VQb2xsTXMocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1RBVFVTX1BPTExfTVMsIDIwMDApO1xyXG5jb25zdCBSRVFVRVNUX1RJTUVPVVRfTVMgPSBwYXJzZVBvbGxNcyhwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVEFUVVNfUkVRVUVTVF9USU1FT1VUX01TLCA0MDAwKTtcclxuXHJcbmludGVyZmFjZSBTaW11bGF0aW9uU3RhdHVzUmVzcG9uc2Uge1xyXG4gIGFjdGl2ZV9ub2Rlcz86IG51bWJlcjtcclxuICB0b3RhbF9jYXBhY2l0eT86IG51bWJlcjtcclxuICBzaW11bGF0aW9uX3RpbWU/OiBudW1iZXI7XHJcbiAgZHQ/OiBudW1iZXI7XHJcbiAgZ3JpZF9zaXplPzogbnVtYmVyW107XHJcbiAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcclxufVxyXG5cclxuaW50ZXJmYWNlIEJlbmNobWFya01ldHJpY3Mge1xyXG4gIHNhbXBsZXNfcGVyX3NlYz86IG51bWJlcjtcclxuICBlc3NfcGVyX3NlYz86IG51bWJlcjtcclxuICBsYWcxX2F1dG9jb3JyPzogbnVtYmVyO1xyXG4gIHRhdV9pbnQ/OiBudW1iZXI7XHJcbiAgdG90YWxfc2FtcGxlcz86IG51bWJlcjtcclxuICBtZWFuX21hZ25ldGl6YXRpb24/OiBudW1iZXI7XHJcbiAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcclxufVxyXG5cclxuaW50ZXJmYWNlIFByb2Nlc3NvckluZm8ge1xyXG4gIG5vZGVfaWQ6IHN0cmluZztcclxuICB0eXBlOiBzdHJpbmc7XHJcbiAgYWN0aXZlOiBib29sZWFuO1xyXG4gIGNvbmZpZz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG4gIFtrZXk6IHN0cmluZ106IHVua25vd247XHJcbn1cclxuXHJcbmludGVyZmFjZSBCYWNrZW5kRGF0YVN0YXRlIHtcclxuICBzaW11bGF0aW9uU3RhdHVzOiBTaW11bGF0aW9uU3RhdHVzUmVzcG9uc2UgfCBudWxsO1xyXG4gIHRocm1sRW5lcmd5OiBudW1iZXIgfCBudWxsO1xyXG4gIHRocm1sRW5lcmd5VGltZXN0YW1wOiBudW1iZXIgfCBudWxsO1xyXG4gIGJlbmNobWFya3M6IEJlbmNobWFya01ldHJpY3MgfCBudWxsO1xyXG4gIHByb2Nlc3NvcnM6IFByb2Nlc3NvckluZm9bXTtcclxuICBsYXN0VXBkYXRlZDogbnVtYmVyIHwgbnVsbDtcclxuICBzdGF0dXNFcnJvcjogc3RyaW5nIHwgbnVsbDtcclxuICB0aHJtbEVycm9yOiBzdHJpbmcgfCBudWxsO1xyXG4gIGJlbmNobWFya0Vycm9yOiBzdHJpbmcgfCBudWxsO1xyXG4gIHByb2Nlc3NvckVycm9yOiBzdHJpbmcgfCBudWxsO1xyXG4gIHJhdGVMaW1pdGVkOiBib29sZWFuO1xyXG4gIGlzUG9sbGluZzogYm9vbGVhbjtcclxuICBzdGFydFBvbGxpbmc6ICgpID0+IHZvaWQ7XHJcbiAgc3RvcFBvbGxpbmc6ICgpID0+IHZvaWQ7XHJcbiAgcG9sbE9uY2U6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbn1cclxuXHJcbmxldCBwb2xsVGltZXI6IFJldHVyblR5cGU8dHlwZW9mIHNldEludGVydmFsPiB8IG51bGwgPSBudWxsO1xyXG5sZXQgc3Vic2NyaWJlckNvdW50ID0gMDtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VCYWNrZW5kRGF0YVN0b3JlID0gY3JlYXRlPEJhY2tlbmREYXRhU3RhdGU+KChzZXQsIGdldCkgPT4gKHtcclxuICBzaW11bGF0aW9uU3RhdHVzOiBudWxsLFxyXG4gIHRocm1sRW5lcmd5OiBudWxsLFxyXG4gIHRocm1sRW5lcmd5VGltZXN0YW1wOiBudWxsLFxyXG4gIGJlbmNobWFya3M6IG51bGwsXHJcbiAgcHJvY2Vzc29yczogW10sXHJcbiAgbGFzdFVwZGF0ZWQ6IG51bGwsXHJcbiAgc3RhdHVzRXJyb3I6IG51bGwsXHJcbiAgdGhybWxFcnJvcjogbnVsbCxcclxuICBiZW5jaG1hcmtFcnJvcjogbnVsbCxcclxuICBwcm9jZXNzb3JFcnJvcjogbnVsbCxcclxuICByYXRlTGltaXRlZDogZmFsc2UsXHJcbiAgaXNQb2xsaW5nOiBmYWxzZSxcclxuICBzdGFydFBvbGxpbmc6ICgpID0+IHtcclxuICAgIHN1YnNjcmliZXJDb3VudCArPSAxO1xyXG4gICAgaWYgKHBvbGxUaW1lcikgcmV0dXJuO1xyXG4gICAgcG9sbFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICBnZXQoKS5wb2xsT25jZSgpLmNhdGNoKCgpID0+IHtcclxuICAgICAgICAvKiBlcnJvcnMgaGFuZGxlZCBpbiBzdGF0ZSAqL1xyXG4gICAgICB9KTtcclxuICAgIH0sIFBPTExfSU5URVJWQUxfTVMpO1xyXG4gICAgdm9pZCBnZXQoKS5wb2xsT25jZSgpO1xyXG4gIH0sXHJcbiAgc3RvcFBvbGxpbmc6ICgpID0+IHtcclxuICAgIGlmIChzdWJzY3JpYmVyQ291bnQgPiAwKSB7XHJcbiAgICAgIHN1YnNjcmliZXJDb3VudCAtPSAxO1xyXG4gICAgfVxyXG4gICAgaWYgKHN1YnNjcmliZXJDb3VudCA9PT0gMCAmJiBwb2xsVGltZXIpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbChwb2xsVGltZXIpO1xyXG4gICAgICBwb2xsVGltZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgcG9sbE9uY2U6IGFzeW5jICgpID0+IHtcclxuICAgIGlmIChnZXQoKS5pc1BvbGxpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc2V0KHsgaXNQb2xsaW5nOiB0cnVlIH0pO1xyXG5cclxuICAgIGNvbnN0IGZldGNoSnNvbiA9IGFzeW5jIChwYXRoOiBzdHJpbmcpID0+IHtcclxuICAgICAgY29uc3Qgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7fTtcclxuICAgICAgaWYgKHR5cGVvZiBBYm9ydFNpZ25hbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcInRpbWVvdXRcIiBpbiBBYm9ydFNpZ25hbCkge1xyXG4gICAgICAgIG9wdGlvbnMuc2lnbmFsID0gQWJvcnRTaWduYWwudGltZW91dChSRVFVRVNUX1RJTUVPVVRfTVMpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0V9JHtwYXRofWAsIG9wdGlvbnMpO1xyXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYXRlX2xpbWl0ZWRcIik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICAgIH07XHJcblxyXG4gICAgbGV0IHJhdGVMaW1pdGVkID0gZmFsc2U7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCBmZXRjaEpzb24oXCIvc2ltdWxhdGlvbi9zdGF0dXNcIik7XHJcbiAgICAgICAgc2V0KHtcclxuICAgICAgICAgIHNpbXVsYXRpb25TdGF0dXM6IHN0YXR1cyxcclxuICAgICAgICAgIHN0YXR1c0Vycm9yOiBudWxsLFxyXG4gICAgICAgICAgcmF0ZUxpbWl0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IFwicmF0ZV9saW1pdGVkXCIpIHtcclxuICAgICAgICAgIHJhdGVMaW1pdGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHNldCh7IHJhdGVMaW1pdGVkOiB0cnVlLCBzdGF0dXNFcnJvcjogXCJSYXRlIGxpbWl0IGV4Y2VlZGVkXCIgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNldCh7IHN0YXR1c0Vycm9yOiBtZXNzYWdlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBlbmVyZ3kgPSBhd2FpdCBmZXRjaEpzb24oYC90aHJtbC9lbmVyZ3lgKTtcclxuICAgICAgICBzZXQoe1xyXG4gICAgICAgICAgdGhybWxFbmVyZ3k6IHR5cGVvZiBlbmVyZ3k/LmVuZXJneSA9PT0gXCJudW1iZXJcIiA/IGVuZXJneS5lbmVyZ3kgOiBudWxsLFxyXG4gICAgICAgICAgdGhybWxFbmVyZ3lUaW1lc3RhbXA6IHR5cGVvZiBlbmVyZ3k/LnRpbWVzdGFtcCA9PT0gXCJudW1iZXJcIiA/IGVuZXJneS50aW1lc3RhbXAgOiBudWxsLFxyXG4gICAgICAgICAgdGhybWxFcnJvcjogbnVsbCxcclxuICAgICAgICB9KTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xyXG4gICAgICAgIGlmIChtZXNzYWdlID09PSBcInJhdGVfbGltaXRlZFwiKSB7XHJcbiAgICAgICAgICByYXRlTGltaXRlZCA9IHRydWU7XHJcbiAgICAgICAgICBzZXQoeyB0aHJtbEVycm9yOiBcIlJhdGUgbGltaXQgZXhjZWVkZWRcIiwgcmF0ZUxpbWl0ZWQ6IHRydWUgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNldCh7IHRocm1sRXJyb3I6IG1lc3NhZ2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGJlbmNoID0gYXdhaXQgZmV0Y2hKc29uKGAvc2FtcGxlci9iZW5jaG1hcmtzYCk7XHJcbiAgICAgICAgc2V0KHsgYmVuY2htYXJrczogYmVuY2gsIGJlbmNobWFya0Vycm9yOiBudWxsIH0pO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IFwicmF0ZV9saW1pdGVkXCIpIHtcclxuICAgICAgICAgIHJhdGVMaW1pdGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHNldCh7IGJlbmNobWFya0Vycm9yOiBcIlJhdGUgbGltaXQgZXhjZWVkZWRcIiwgcmF0ZUxpbWl0ZWQ6IHRydWUgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNldCh7IGJlbmNobWFya0Vycm9yOiBtZXNzYWdlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwcm9jID0gYXdhaXQgZmV0Y2hKc29uKGAvcHJvY2Vzc29yL2xpc3RgKTtcclxuICAgICAgICBjb25zdCBwcm9jZXNzb3JzOiBQcm9jZXNzb3JJbmZvW10gPSBBcnJheS5pc0FycmF5KHByb2M/LnByb2Nlc3NvcnMpID8gcHJvYy5wcm9jZXNzb3JzIDogW107XHJcbiAgICAgICAgc2V0KHsgcHJvY2Vzc29ycywgcHJvY2Vzc29yRXJyb3I6IG51bGwgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuICAgICAgICBpZiAobWVzc2FnZSA9PT0gXCJyYXRlX2xpbWl0ZWRcIikge1xyXG4gICAgICAgICAgcmF0ZUxpbWl0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgc2V0KHsgcHJvY2Vzc29yRXJyb3I6IFwiUmF0ZSBsaW1pdCBleGNlZWRlZFwiLCByYXRlTGltaXRlZDogdHJ1ZSB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2V0KHsgcHJvY2Vzc29yRXJyb3I6IG1lc3NhZ2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXJhdGVMaW1pdGVkKSB7XHJcbiAgICAgICAgc2V0KHsgcmF0ZUxpbWl0ZWQ6IGZhbHNlIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXQoeyBpc1BvbGxpbmc6IGZhbHNlLCBsYXN0VXBkYXRlZDogRGF0ZS5ub3coKSB9KTtcclxuICAgIH1cclxuICB9LFxyXG59KSk7XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJwcm9jZXNzIiwiQVBJX0JBU0UiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwicGFyc2VQb2xsTXMiLCJ2YWx1ZSIsImZhbGxiYWNrIiwicGFyc2VkIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJQT0xMX0lOVEVSVkFMX01TIiwiTkVYVF9QVUJMSUNfU1RBVFVTX1BPTExfTVMiLCJSRVFVRVNUX1RJTUVPVVRfTVMiLCJORVhUX1BVQkxJQ19TVEFUVVNfUkVRVUVTVF9USU1FT1VUX01TIiwicG9sbFRpbWVyIiwic3Vic2NyaWJlckNvdW50IiwidXNlQmFja2VuZERhdGFTdG9yZSIsInNldCIsImdldCIsInNpbXVsYXRpb25TdGF0dXMiLCJ0aHJtbEVuZXJneSIsInRocm1sRW5lcmd5VGltZXN0YW1wIiwiYmVuY2htYXJrcyIsInByb2Nlc3NvcnMiLCJsYXN0VXBkYXRlZCIsInN0YXR1c0Vycm9yIiwidGhybWxFcnJvciIsImJlbmNobWFya0Vycm9yIiwicHJvY2Vzc29yRXJyb3IiLCJyYXRlTGltaXRlZCIsImlzUG9sbGluZyIsInN0YXJ0UG9sbGluZyIsInNldEludGVydmFsIiwicG9sbE9uY2UiLCJjYXRjaCIsInN0b3BQb2xsaW5nIiwiY2xlYXJJbnRlcnZhbCIsImZldGNoSnNvbiIsInBhdGgiLCJvcHRpb25zIiwiQWJvcnRTaWduYWwiLCJzaWduYWwiLCJ0aW1lb3V0IiwicmVzcG9uc2UiLCJmZXRjaCIsInN0YXR1cyIsIkVycm9yIiwib2siLCJqc29uIiwiZXJyb3IiLCJtZXNzYWdlIiwiU3RyaW5nIiwiZW5lcmd5IiwidGltZXN0YW1wIiwiYmVuY2giLCJwcm9jIiwiQXJyYXkiLCJpc0FycmF5IiwiRGF0ZSIsIm5vdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/stores/backendData.ts\n"));

/***/ })

});